<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>casacore: ao::uvector&lt; Tp, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">casacore
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceao.html">ao</a></li><li class="navelem"><a class="el" href="classao_1_1uvector.html">uvector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classao_1_1uvector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ao::uvector&lt; Tp, Alloc &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__uvector.html">Class uvector and related functions.</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A container similar to std::vector, but one that allows construction without initializing its elements.  
 <a href="classao_1_1uvector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="uvector_8h_source.html">uvector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ao::uvector&lt; Tp, Alloc &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classao_1_1uvector.png" usemap="#ao::uvector&lt; Tp, Alloc &gt;_map" alt=""/>
  <map id="ao::uvector&lt; Tp, Alloc &gt;_map" name="ao::uvector&lt; Tp, Alloc &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a71db057aafa119005b4dee13c4db52cf"><td class="memItemLeft" align="right" valign="top">typedef Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a71db057aafa119005b4dee13c4db52cf">value_type</a></td></tr>
<tr class="memdesc:a71db057aafa119005b4dee13c4db52cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type.  <a href="#a71db057aafa119005b4dee13c4db52cf">More...</a><br/></td></tr>
<tr class="separator:a71db057aafa119005b4dee13c4db52cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0f4b56eca3a8e5b76bcc2de5cffcda"><td class="memItemLeft" align="right" valign="top">typedef Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a6e0f4b56eca3a8e5b76bcc2de5cffcda">allocator_type</a></td></tr>
<tr class="memdesc:a6e0f4b56eca3a8e5b76bcc2de5cffcda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of allocator used to allocate and deallocate space.  <a href="#a6e0f4b56eca3a8e5b76bcc2de5cffcda">More...</a><br/></td></tr>
<tr class="separator:a6e0f4b56eca3a8e5b76bcc2de5cffcda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653d02899bdbb5f56e3085020e435a7e"><td class="memItemLeft" align="right" valign="top">typedef Tp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a653d02899bdbb5f56e3085020e435a7e">reference</a></td></tr>
<tr class="memdesc:a653d02899bdbb5f56e3085020e435a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to element type.  <a href="#a653d02899bdbb5f56e3085020e435a7e">More...</a><br/></td></tr>
<tr class="separator:a653d02899bdbb5f56e3085020e435a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276633c9c49f4f4341feb20d58bbea26"><td class="memItemLeft" align="right" valign="top">typedef const Tp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a276633c9c49f4f4341feb20d58bbea26">const_reference</a></td></tr>
<tr class="memdesc:a276633c9c49f4f4341feb20d58bbea26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant reference to element type.  <a href="#a276633c9c49f4f4341feb20d58bbea26">More...</a><br/></td></tr>
<tr class="separator:a276633c9c49f4f4341feb20d58bbea26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56141f76e1742adacd4a22b0cfbce59e"><td class="memItemLeft" align="right" valign="top">typedef Tp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a56141f76e1742adacd4a22b0cfbce59e">pointer</a></td></tr>
<tr class="memdesc:a56141f76e1742adacd4a22b0cfbce59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to element type.  <a href="#a56141f76e1742adacd4a22b0cfbce59e">More...</a><br/></td></tr>
<tr class="separator:a56141f76e1742adacd4a22b0cfbce59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1117840801f4059221f50d62fbaed9"><td class="memItemLeft" align="right" valign="top">typedef const Tp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a6c1117840801f4059221f50d62fbaed9">const_pointer</a></td></tr>
<tr class="memdesc:a6c1117840801f4059221f50d62fbaed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to constant element type.  <a href="#a6c1117840801f4059221f50d62fbaed9">More...</a><br/></td></tr>
<tr class="separator:a6c1117840801f4059221f50d62fbaed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597be551193c3a7d8d8a9ba57b2d21ad"><td class="memItemLeft" align="right" valign="top">typedef Tp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a></td></tr>
<tr class="memdesc:a597be551193c3a7d8d8a9ba57b2d21ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type.  <a href="#a597be551193c3a7d8d8a9ba57b2d21ad">More...</a><br/></td></tr>
<tr class="separator:a597be551193c3a7d8d8a9ba57b2d21ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011d6c3bfe6cabe6984019064522762c"><td class="memItemLeft" align="right" valign="top">typedef const Tp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a></td></tr>
<tr class="memdesc:a011d6c3bfe6cabe6984019064522762c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type of constant elements.  <a href="#a011d6c3bfe6cabe6984019064522762c">More...</a><br/></td></tr>
<tr class="separator:a011d6c3bfe6cabe6984019064522762c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43730bd384eabef86420b4f18260f197"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a43730bd384eabef86420b4f18260f197">reverse_iterator</a></td></tr>
<tr class="memdesc:a43730bd384eabef86420b4f18260f197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator type.  <a href="#a43730bd384eabef86420b4f18260f197">More...</a><br/></td></tr>
<tr class="separator:a43730bd384eabef86420b4f18260f197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25f986e75fa5090132984e31783ebb0"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ac25f986e75fa5090132984e31783ebb0">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ac25f986e75fa5090132984e31783ebb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator of constant elements.  <a href="#ac25f986e75fa5090132984e31783ebb0">More...</a><br/></td></tr>
<tr class="separator:ac25f986e75fa5090132984e31783ebb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda3a6b0829c0245e14ffa70152cee70"><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#adda3a6b0829c0245e14ffa70152cee70">difference_type</a></td></tr>
<tr class="memdesc:adda3a6b0829c0245e14ffa70152cee70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference between to iterators.  <a href="#adda3a6b0829c0245e14ffa70152cee70">More...</a><br/></td></tr>
<tr class="separator:adda3a6b0829c0245e14ffa70152cee70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b2cbb86306b29cda7237156950bc8f"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a></td></tr>
<tr class="memdesc:af8b2cbb86306b29cda7237156950bc8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for indexing elements.  <a href="#af8b2cbb86306b29cda7237156950bc8f">More...</a><br/></td></tr>
<tr class="separator:af8b2cbb86306b29cda7237156950bc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2c30fa610be46118af297f37f27ca1"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#afe2c30fa610be46118af297f37f27ca1">size_type</a></td></tr>
<tr class="memdesc:afe2c30fa610be46118af297f37f27ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for indexing elements.  <a href="#afe2c30fa610be46118af297f37f27ca1">More...</a><br/></td></tr>
<tr class="separator:afe2c30fa610be46118af297f37f27ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0a5f71a18d12bcdd15af33f6f7bf4925"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a0a5f71a18d12bcdd15af33f6f7bf4925">uvector</a> (const <a class="el" href="classao_1_1uvector.html#a6e0f4b56eca3a8e5b76bcc2de5cffcda">allocator_type</a> &amp;allocator=Alloc()) noexcept</td></tr>
<tr class="memdesc:a0a5f71a18d12bcdd15af33f6f7bf4925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty uvector.  <a href="#a0a5f71a18d12bcdd15af33f6f7bf4925">More...</a><br/></td></tr>
<tr class="separator:a0a5f71a18d12bcdd15af33f6f7bf4925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d234595295b78c788ed2140d8b1a89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ae5d234595295b78c788ed2140d8b1a89">uvector</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> n)</td></tr>
<tr class="memdesc:ae5d234595295b78c788ed2140d8b1a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with given amount of elements, without initializing these.  <a href="#ae5d234595295b78c788ed2140d8b1a89">More...</a><br/></td></tr>
<tr class="separator:ae5d234595295b78c788ed2140d8b1a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f3c0817ed668be39ffebfdb1cfeb72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ae5f3c0817ed668be39ffebfdb1cfeb72">uvector</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> n, const <a class="el" href="classao_1_1uvector.html#a71db057aafa119005b4dee13c4db52cf">value_type</a> &amp;val, const <a class="el" href="classao_1_1uvector.html#a6e0f4b56eca3a8e5b76bcc2de5cffcda">allocator_type</a> &amp;allocator=Alloc())</td></tr>
<tr class="memdesc:ae5f3c0817ed668be39ffebfdb1cfeb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with given amount of elements and set these to a specific value.  <a href="#ae5f3c0817ed668be39ffebfdb1cfeb72">More...</a><br/></td></tr>
<tr class="separator:ae5f3c0817ed668be39ffebfdb1cfeb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5467232a346a461969386d55b45437"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a7a5467232a346a461969386d55b45437"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a7a5467232a346a461969386d55b45437">uvector</a> (InputIterator <a class="el" href="malloc_8h.html#a40bccbd73bd260de50b2b7feb2a528dc">first</a>, InputIterator last, const <a class="el" href="classao_1_1uvector.html#a6e0f4b56eca3a8e5b76bcc2de5cffcda">allocator_type</a> &amp;allocator=Alloc())</td></tr>
<tr class="memdesc:a7a5467232a346a461969386d55b45437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector by copying elements from a range.  <a href="#a7a5467232a346a461969386d55b45437">More...</a><br/></td></tr>
<tr class="separator:a7a5467232a346a461969386d55b45437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab9ebda59065a14e8401fb5ed0497dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#abab9ebda59065a14e8401fb5ed0497dc">uvector</a> (const <a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;other)</td></tr>
<tr class="memdesc:abab9ebda59065a14e8401fb5ed0497dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construct a uvector.  <a href="#abab9ebda59065a14e8401fb5ed0497dc">More...</a><br/></td></tr>
<tr class="separator:abab9ebda59065a14e8401fb5ed0497dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33eb364955d9dc097b97b6babe84d720"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a33eb364955d9dc097b97b6babe84d720">uvector</a> (const <a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;other, const <a class="el" href="classao_1_1uvector.html#a6e0f4b56eca3a8e5b76bcc2de5cffcda">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a33eb364955d9dc097b97b6babe84d720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construct a uvector with custom allocator.  <a href="#a33eb364955d9dc097b97b6babe84d720">More...</a><br/></td></tr>
<tr class="separator:a33eb364955d9dc097b97b6babe84d720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3497a068dd5662316d6a1dc6327cfe7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a3497a068dd5662316d6a1dc6327cfe7f">uvector</a> (<a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a3497a068dd5662316d6a1dc6327cfe7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move construct a uvector.  <a href="#a3497a068dd5662316d6a1dc6327cfe7f">More...</a><br/></td></tr>
<tr class="separator:a3497a068dd5662316d6a1dc6327cfe7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ebf4a255853677de835e04ff3581c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#af9ebf4a255853677de835e04ff3581c3">uvector</a> (<a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&amp;other, const <a class="el" href="classao_1_1uvector.html#a6e0f4b56eca3a8e5b76bcc2de5cffcda">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:af9ebf4a255853677de835e04ff3581c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move construct a uvector with custom allocator.  <a href="#af9ebf4a255853677de835e04ff3581c3">More...</a><br/></td></tr>
<tr class="separator:af9ebf4a255853677de835e04ff3581c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64d97b346360ed05c2b6febdcbc0f2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ac64d97b346360ed05c2b6febdcbc0f2a">uvector</a> (std::initializer_list&lt; Tp &gt; initlist, const <a class="el" href="classao_1_1uvector.html#a6e0f4b56eca3a8e5b76bcc2de5cffcda">allocator_type</a> &amp;allocator=Alloc())</td></tr>
<tr class="memdesc:ac64d97b346360ed05c2b6febdcbc0f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a uvector from a initializer list.  <a href="#ac64d97b346360ed05c2b6febdcbc0f2a">More...</a><br/></td></tr>
<tr class="separator:ac64d97b346360ed05c2b6febdcbc0f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0384ea33901f406fc1e98b4757ce17cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a0384ea33901f406fc1e98b4757ce17cb">~uvector</a> () noexcept</td></tr>
<tr class="memdesc:a0384ea33901f406fc1e98b4757ce17cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a0384ea33901f406fc1e98b4757ce17cb">More...</a><br/></td></tr>
<tr class="separator:a0384ea33901f406fc1e98b4757ce17cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c460db08f23572e8895d8891f76730a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html">uvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a0c460db08f23572e8895d8891f76730a">operator=</a> (const <a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;other)</td></tr>
<tr class="memdesc:a0c460db08f23572e8895d8891f76730a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign another uvector to this uvector.  <a href="#a0c460db08f23572e8895d8891f76730a">More...</a><br/></td></tr>
<tr class="separator:a0c460db08f23572e8895d8891f76730a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29fca669efe2f1dc46de39607752059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html">uvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ae29fca669efe2f1dc46de39607752059">operator=</a> (<a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&amp;other) noexcept(std::allocator_traits&lt; Alloc &gt;::propagate_on_container_move_assignment::value||allocator_is_always_equal::value)</td></tr>
<tr class="memdesc:ae29fca669efe2f1dc46de39607752059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign another uvector to this uvector.  <a href="#ae29fca669efe2f1dc46de39607752059">More...</a><br/></td></tr>
<tr class="separator:ae29fca669efe2f1dc46de39607752059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7475fb5e6696984a7bf85bb5818b2aaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a7475fb5e6696984a7bf85bb5818b2aaf">begin</a> () noexcept</td></tr>
<tr class="memdesc:a7475fb5e6696984a7bf85bb5818b2aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator to first element.  <a href="#a7475fb5e6696984a7bf85bb5818b2aaf">More...</a><br/></td></tr>
<tr class="separator:a7475fb5e6696984a7bf85bb5818b2aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a480d1be5a65f7110e4f1a34724756"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a78a480d1be5a65f7110e4f1a34724756">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a78a480d1be5a65f7110e4f1a34724756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant iterator to first element.  <a href="#a78a480d1be5a65f7110e4f1a34724756">More...</a><br/></td></tr>
<tr class="separator:a78a480d1be5a65f7110e4f1a34724756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92761da8791e8e10b65281d9ef6c39cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a92761da8791e8e10b65281d9ef6c39cf">end</a> () noexcept</td></tr>
<tr class="memdesc:a92761da8791e8e10b65281d9ef6c39cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator to element past last element.  <a href="#a92761da8791e8e10b65281d9ef6c39cf">More...</a><br/></td></tr>
<tr class="separator:a92761da8791e8e10b65281d9ef6c39cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a3ba594d1bb8a88670aa9fbb018adf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a93a3ba594d1bb8a88670aa9fbb018adf">end</a> () const noexcept</td></tr>
<tr class="memdesc:a93a3ba594d1bb8a88670aa9fbb018adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant iterator to element past last element.  <a href="#a93a3ba594d1bb8a88670aa9fbb018adf">More...</a><br/></td></tr>
<tr class="separator:a93a3ba594d1bb8a88670aa9fbb018adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d98dd5e689aeb68db234484515f96e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a43730bd384eabef86420b4f18260f197">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ac0d98dd5e689aeb68db234484515f96e">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:ac0d98dd5e689aeb68db234484515f96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reverse iterator to last element.  <a href="#ac0d98dd5e689aeb68db234484515f96e">More...</a><br/></td></tr>
<tr class="separator:ac0d98dd5e689aeb68db234484515f96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3325a0a78cd6fb6ba7293c85da2c10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#ac25f986e75fa5090132984e31783ebb0">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a2e3325a0a78cd6fb6ba7293c85da2c10">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a2e3325a0a78cd6fb6ba7293c85da2c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant reverse iterator to last element.  <a href="#a2e3325a0a78cd6fb6ba7293c85da2c10">More...</a><br/></td></tr>
<tr class="separator:a2e3325a0a78cd6fb6ba7293c85da2c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580e426b99d03410df6e57dc50da8c33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a43730bd384eabef86420b4f18260f197">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a580e426b99d03410df6e57dc50da8c33">rend</a> () noexcept</td></tr>
<tr class="memdesc:a580e426b99d03410df6e57dc50da8c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reverse iterator to element before first element.  <a href="#a580e426b99d03410df6e57dc50da8c33">More...</a><br/></td></tr>
<tr class="separator:a580e426b99d03410df6e57dc50da8c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c763e0f42637fbe9e63cf87734d7223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#ac25f986e75fa5090132984e31783ebb0">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a5c763e0f42637fbe9e63cf87734d7223">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a5c763e0f42637fbe9e63cf87734d7223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant reverse iterator to element before first element.  <a href="#a5c763e0f42637fbe9e63cf87734d7223">More...</a><br/></td></tr>
<tr class="separator:a5c763e0f42637fbe9e63cf87734d7223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55134b90a07642e7374ee7361d620f72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a55134b90a07642e7374ee7361d620f72">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a55134b90a07642e7374ee7361d620f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant iterator to first element.  <a href="#a55134b90a07642e7374ee7361d620f72">More...</a><br/></td></tr>
<tr class="separator:a55134b90a07642e7374ee7361d620f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d13a83df89d072e4bbea587f47e35a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a87d13a83df89d072e4bbea587f47e35a">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a87d13a83df89d072e4bbea587f47e35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant iterator to element past last element.  <a href="#a87d13a83df89d072e4bbea587f47e35a">More...</a><br/></td></tr>
<tr class="separator:a87d13a83df89d072e4bbea587f47e35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd31db66931f8cc780b53d1711ced0d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#ac25f986e75fa5090132984e31783ebb0">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#acd31db66931f8cc780b53d1711ced0d8">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:acd31db66931f8cc780b53d1711ced0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant reverse iterator to last element.  <a href="#acd31db66931f8cc780b53d1711ced0d8">More...</a><br/></td></tr>
<tr class="separator:acd31db66931f8cc780b53d1711ced0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f772273ac3ddaf9adc600f781d2e52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#ac25f986e75fa5090132984e31783ebb0">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a22f772273ac3ddaf9adc600f781d2e52">crend</a> () const noexcept</td></tr>
<tr class="memdesc:a22f772273ac3ddaf9adc600f781d2e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant reverse iterator to element before first element.  <a href="#a22f772273ac3ddaf9adc600f781d2e52">More...</a><br/></td></tr>
<tr class="separator:a22f772273ac3ddaf9adc600f781d2e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce3e9629d364cbcb7d0e878c127801f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a3ce3e9629d364cbcb7d0e878c127801f">size</a> () const noexcept</td></tr>
<tr class="memdesc:a3ce3e9629d364cbcb7d0e878c127801f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of elements in container.  <a href="#a3ce3e9629d364cbcb7d0e878c127801f">More...</a><br/></td></tr>
<tr class="separator:a3ce3e9629d364cbcb7d0e878c127801f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a2f7c95a33b257c176b8edb3d7e880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ae8a2f7c95a33b257c176b8edb3d7e880">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:ae8a2f7c95a33b257c176b8edb3d7e880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum number of elements that this container can hold.  <a href="#ae8a2f7c95a33b257c176b8edb3d7e880">More...</a><br/></td></tr>
<tr class="separator:ae8a2f7c95a33b257c176b8edb3d7e880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438e78bce885a37dc76c7b1bef016355"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a438e78bce885a37dc76c7b1bef016355">resize</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> n)</td></tr>
<tr class="memdesc:a438e78bce885a37dc76c7b1bef016355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the number of elements in the container.  <a href="#a438e78bce885a37dc76c7b1bef016355">More...</a><br/></td></tr>
<tr class="separator:a438e78bce885a37dc76c7b1bef016355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846b103e8ff6f675f481197127b4a389"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a846b103e8ff6f675f481197127b4a389">resize</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> n, const Tp &amp;val)</td></tr>
<tr class="memdesc:a846b103e8ff6f675f481197127b4a389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the number of elements in the container.  <a href="#a846b103e8ff6f675f481197127b4a389">More...</a><br/></td></tr>
<tr class="separator:a846b103e8ff6f675f481197127b4a389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad9f7960b8a324c03b6983f7ff31330"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a3ad9f7960b8a324c03b6983f7ff31330">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a3ad9f7960b8a324c03b6983f7ff31330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements the container can currently hold without reallocating storage.  <a href="#a3ad9f7960b8a324c03b6983f7ff31330">More...</a><br/></td></tr>
<tr class="separator:a3ad9f7960b8a324c03b6983f7ff31330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834534d95e4406d971a9c2599cefc790"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a834534d95e4406d971a9c2599cefc790">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a834534d95e4406d971a9c2599cefc790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the container is currently empty.  <a href="#a834534d95e4406d971a9c2599cefc790">More...</a><br/></td></tr>
<tr class="separator:a834534d95e4406d971a9c2599cefc790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c17d4bacbb3983c24a1477b15ec4bc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a5c17d4bacbb3983c24a1477b15ec4bc7">reserve</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> n)</td></tr>
<tr class="memdesc:a5c17d4bacbb3983c24a1477b15ec4bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve space for a number of elements, to prevent the overhead of extra reallocations.  <a href="#a5c17d4bacbb3983c24a1477b15ec4bc7">More...</a><br/></td></tr>
<tr class="separator:a5c17d4bacbb3983c24a1477b15ec4bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08863dcb6f57dd9f7fec8190ed2055cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a08863dcb6f57dd9f7fec8190ed2055cc">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a08863dcb6f57dd9f7fec8190ed2055cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the capacity of the container such that no extra space is hold.  <a href="#a08863dcb6f57dd9f7fec8190ed2055cc">More...</a><br/></td></tr>
<tr class="separator:a08863dcb6f57dd9f7fec8190ed2055cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab025e61401da9f352c82b211377d3c66"><td class="memItemLeft" align="right" valign="top">Tp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ab025e61401da9f352c82b211377d3c66">operator[]</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> index) noexcept</td></tr>
<tr class="memdesc:ab025e61401da9f352c82b211377d3c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the element at the given index.  <a href="#ab025e61401da9f352c82b211377d3c66">More...</a><br/></td></tr>
<tr class="separator:ab025e61401da9f352c82b211377d3c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f353b9ea4d9b3fde8bc035efb257ee7"><td class="memItemLeft" align="right" valign="top">const Tp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a2f353b9ea4d9b3fde8bc035efb257ee7">operator[]</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> index) const noexcept</td></tr>
<tr class="memdesc:a2f353b9ea4d9b3fde8bc035efb257ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a constant reference to the element at the given index.  <a href="#a2f353b9ea4d9b3fde8bc035efb257ee7">More...</a><br/></td></tr>
<tr class="separator:a2f353b9ea4d9b3fde8bc035efb257ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f17d41f81b07231a38115d4337ad85"><td class="memItemLeft" align="right" valign="top">Tp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ab2f17d41f81b07231a38115d4337ad85">at</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> index)</td></tr>
<tr class="memdesc:ab2f17d41f81b07231a38115d4337ad85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the element at the given index with bounds checking.  <a href="#ab2f17d41f81b07231a38115d4337ad85">More...</a><br/></td></tr>
<tr class="separator:ab2f17d41f81b07231a38115d4337ad85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c33ca25d3257762f6c86e6cc571446"><td class="memItemLeft" align="right" valign="top">const Tp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ac1c33ca25d3257762f6c86e6cc571446">at</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> index) const </td></tr>
<tr class="memdesc:ac1c33ca25d3257762f6c86e6cc571446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a constant reference to the element at the given index with bounds checking.  <a href="#ac1c33ca25d3257762f6c86e6cc571446">More...</a><br/></td></tr>
<tr class="separator:ac1c33ca25d3257762f6c86e6cc571446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee98ea97e491f3ee31ca28e2d832ce53"><td class="memItemLeft" align="right" valign="top">Tp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#aee98ea97e491f3ee31ca28e2d832ce53">front</a> () noexcept</td></tr>
<tr class="memdesc:aee98ea97e491f3ee31ca28e2d832ce53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reference to first element in container.  <a href="#aee98ea97e491f3ee31ca28e2d832ce53">More...</a><br/></td></tr>
<tr class="separator:aee98ea97e491f3ee31ca28e2d832ce53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa415b08862cffdcacadf13c3212af303"><td class="memItemLeft" align="right" valign="top">const Tp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#aa415b08862cffdcacadf13c3212af303">front</a> () const noexcept</td></tr>
<tr class="memdesc:aa415b08862cffdcacadf13c3212af303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant reference to first element in container.  <a href="#aa415b08862cffdcacadf13c3212af303">More...</a><br/></td></tr>
<tr class="separator:aa415b08862cffdcacadf13c3212af303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351232c0a0ca4e981ab64276d37ecb51"><td class="memItemLeft" align="right" valign="top">Tp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a351232c0a0ca4e981ab64276d37ecb51">back</a> () noexcept</td></tr>
<tr class="memdesc:a351232c0a0ca4e981ab64276d37ecb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reference to last element in container.  <a href="#a351232c0a0ca4e981ab64276d37ecb51">More...</a><br/></td></tr>
<tr class="separator:a351232c0a0ca4e981ab64276d37ecb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f388e6de64028142fab43234f50d4c"><td class="memItemLeft" align="right" valign="top">const Tp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a77f388e6de64028142fab43234f50d4c">back</a> () const noexcept</td></tr>
<tr class="memdesc:a77f388e6de64028142fab43234f50d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant reference to last element in container.  <a href="#a77f388e6de64028142fab43234f50d4c">More...</a><br/></td></tr>
<tr class="separator:a77f388e6de64028142fab43234f50d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2475deee7f0d64164eedebbd2910cc55"><td class="memItemLeft" align="right" valign="top">Tp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a2475deee7f0d64164eedebbd2910cc55">data</a> () noexcept</td></tr>
<tr class="memdesc:a2475deee7f0d64164eedebbd2910cc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to internal storage.  <a href="#a2475deee7f0d64164eedebbd2910cc55">More...</a><br/></td></tr>
<tr class="separator:a2475deee7f0d64164eedebbd2910cc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928c9d33d2c1b4c2cb917a8b58135a14"><td class="memItemLeft" align="right" valign="top">const Tp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a928c9d33d2c1b4c2cb917a8b58135a14">data</a> () const noexcept</td></tr>
<tr class="memdesc:a928c9d33d2c1b4c2cb917a8b58135a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant pointer to internal storage.  <a href="#a928c9d33d2c1b4c2cb917a8b58135a14">More...</a><br/></td></tr>
<tr class="separator:a928c9d33d2c1b4c2cb917a8b58135a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb06505af16be08f01f5a0028da9fe88"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:acb06505af16be08f01f5a0028da9fe88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#acb06505af16be08f01f5a0028da9fe88">assign</a> (InputIterator <a class="el" href="malloc_8h.html#a40bccbd73bd260de50b2b7feb2a528dc">first</a>, InputIterator last)</td></tr>
<tr class="memdesc:acb06505af16be08f01f5a0028da9fe88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign this container to be equal to the given range.  <a href="#acb06505af16be08f01f5a0028da9fe88">More...</a><br/></td></tr>
<tr class="separator:acb06505af16be08f01f5a0028da9fe88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f47d3741444fa997327c2f6f7b3e6c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a6f47d3741444fa997327c2f6f7b3e6c0">assign</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> n, const Tp &amp;val)</td></tr>
<tr class="memdesc:a6f47d3741444fa997327c2f6f7b3e6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the container and assign the given value to all elements.  <a href="#a6f47d3741444fa997327c2f6f7b3e6c0">More...</a><br/></td></tr>
<tr class="separator:a6f47d3741444fa997327c2f6f7b3e6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634a276af97bd750a36177b701a9d146"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a634a276af97bd750a36177b701a9d146">assign</a> (std::initializer_list&lt; Tp &gt; initlist)</td></tr>
<tr class="memdesc:a634a276af97bd750a36177b701a9d146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign this container to an initializer list.  <a href="#a634a276af97bd750a36177b701a9d146">More...</a><br/></td></tr>
<tr class="separator:a634a276af97bd750a36177b701a9d146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf96370233197b0a9161ccbe6fd12cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#adcf96370233197b0a9161ccbe6fd12cd">push_back</a> (const Tp &amp;item)</td></tr>
<tr class="memdesc:adcf96370233197b0a9161ccbe6fd12cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given value to the end of the container.  <a href="#adcf96370233197b0a9161ccbe6fd12cd">More...</a><br/></td></tr>
<tr class="separator:adcf96370233197b0a9161ccbe6fd12cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2204216d5a93b14845859bfdefa4dbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ae2204216d5a93b14845859bfdefa4dbc">push_back</a> (Tp &amp;&amp;item)</td></tr>
<tr class="memdesc:ae2204216d5a93b14845859bfdefa4dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given value to the end of the container by moving it in.  <a href="#ae2204216d5a93b14845859bfdefa4dbc">More...</a><br/></td></tr>
<tr class="separator:ae2204216d5a93b14845859bfdefa4dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5bf48390f54e1dfcf812d484b5135b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#aab5bf48390f54e1dfcf812d484b5135b">pop_back</a> ()</td></tr>
<tr class="memdesc:aab5bf48390f54e1dfcf812d484b5135b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last element from the container.  <a href="#aab5bf48390f54e1dfcf812d484b5135b">More...</a><br/></td></tr>
<tr class="separator:aab5bf48390f54e1dfcf812d484b5135b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98ccf7b248bb73ee8805f9a65f9a6a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#af98ccf7b248bb73ee8805f9a65f9a6a9">insert</a> (<a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> position, const Tp &amp;item)</td></tr>
<tr class="memdesc:af98ccf7b248bb73ee8805f9a65f9a6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element at a given position.  <a href="#af98ccf7b248bb73ee8805f9a65f9a6a9">More...</a><br/></td></tr>
<tr class="separator:af98ccf7b248bb73ee8805f9a65f9a6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a3f5fceafd44237491931013f6d0e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#aa1a3f5fceafd44237491931013f6d0e6">insert</a> (<a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> position, <a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> n, const Tp &amp;val)</td></tr>
<tr class="memdesc:aa1a3f5fceafd44237491931013f6d0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements at a given position and initialize them with a value.  <a href="#aa1a3f5fceafd44237491931013f6d0e6">More...</a><br/></td></tr>
<tr class="separator:aa1a3f5fceafd44237491931013f6d0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa7fe6ffc176a2b0c0c64d5f881737d"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a7aa7fe6ffc176a2b0c0c64d5f881737d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a7aa7fe6ffc176a2b0c0c64d5f881737d">insert</a> (<a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> position, InputIterator <a class="el" href="malloc_8h.html#a40bccbd73bd260de50b2b7feb2a528dc">first</a>, InputIterator last)</td></tr>
<tr class="memdesc:a7aa7fe6ffc176a2b0c0c64d5f881737d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements at a given position and initialize them from a range.  <a href="#a7aa7fe6ffc176a2b0c0c64d5f881737d">More...</a><br/></td></tr>
<tr class="separator:a7aa7fe6ffc176a2b0c0c64d5f881737d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac20e88d7cd2f10f3d0073de746ba7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#aac20e88d7cd2f10f3d0073de746ba7c0">insert</a> (<a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> position, Tp &amp;&amp;item)</td></tr>
<tr class="memdesc:aac20e88d7cd2f10f3d0073de746ba7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element at a given position by moving it in.  <a href="#aac20e88d7cd2f10f3d0073de746ba7c0">More...</a><br/></td></tr>
<tr class="separator:aac20e88d7cd2f10f3d0073de746ba7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88716bb0affe3a4949b99f2a63851117"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a88716bb0affe3a4949b99f2a63851117">insert</a> (<a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> position, std::initializer_list&lt; Tp &gt; initlist)</td></tr>
<tr class="memdesc:a88716bb0affe3a4949b99f2a63851117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements at a given position and initialize them from a initializer list.  <a href="#a88716bb0affe3a4949b99f2a63851117">More...</a><br/></td></tr>
<tr class="separator:a88716bb0affe3a4949b99f2a63851117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834bab716da5d5eae98f203511e072b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a834bab716da5d5eae98f203511e072b7">erase</a> (<a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> position)</td></tr>
<tr class="memdesc:a834bab716da5d5eae98f203511e072b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an element from the container.  <a href="#a834bab716da5d5eae98f203511e072b7">More...</a><br/></td></tr>
<tr class="separator:a834bab716da5d5eae98f203511e072b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc616c537e5915439524719f856b6a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#adbc616c537e5915439524719f856b6a1">erase</a> (<a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> <a class="el" href="malloc_8h.html#a40bccbd73bd260de50b2b7feb2a528dc">first</a>, <a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> last)</td></tr>
<tr class="memdesc:adbc616c537e5915439524719f856b6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a range of elements from the container.  <a href="#adbc616c537e5915439524719f856b6a1">More...</a><br/></td></tr>
<tr class="separator:adbc616c537e5915439524719f856b6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda06e94cc27f64265d786795969f922"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#adda06e94cc27f64265d786795969f922">swap</a> (<a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:adda06e94cc27f64265d786795969f922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of this uvector with the given uvector.  <a href="#adda06e94cc27f64265d786795969f922">More...</a><br/></td></tr>
<tr class="separator:adda06e94cc27f64265d786795969f922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc11179ac391addb252718f9134689d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a7fc11179ac391addb252718f9134689d">clear</a> ()</td></tr>
<tr class="memdesc:a7fc11179ac391addb252718f9134689d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements from the container.  <a href="#a7fc11179ac391addb252718f9134689d">More...</a><br/></td></tr>
<tr class="separator:a7fc11179ac391addb252718f9134689d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b27abe6c7d0c75a71eaaa9bd42afc2"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac5b27abe6c7d0c75a71eaaa9bd42afc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ac5b27abe6c7d0c75a71eaaa9bd42afc2">emplace</a> (<a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> position, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ac5b27abe6c7d0c75a71eaaa9bd42afc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element at a given position by constructing it in place.  <a href="#ac5b27abe6c7d0c75a71eaaa9bd42afc2">More...</a><br/></td></tr>
<tr class="separator:ac5b27abe6c7d0c75a71eaaa9bd42afc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635aa35da74c9de2a3e62e54f8a4ddfb"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a635aa35da74c9de2a3e62e54f8a4ddfb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a635aa35da74c9de2a3e62e54f8a4ddfb">emplace_back</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a635aa35da74c9de2a3e62e54f8a4ddfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given value to the end of the container by constructing it in place.  <a href="#a635aa35da74c9de2a3e62e54f8a4ddfb">More...</a><br/></td></tr>
<tr class="separator:a635aa35da74c9de2a3e62e54f8a4ddfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ae154a74e75c0db67dcab01fde637e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a6e0f4b56eca3a8e5b76bcc2de5cffcda">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#af2ae154a74e75c0db67dcab01fde637e">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:af2ae154a74e75c0db67dcab01fde637e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the allocator.  <a href="#af2ae154a74e75c0db67dcab01fde637e">More...</a><br/></td></tr>
<tr class="separator:af2ae154a74e75c0db67dcab01fde637e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0352642a9593ed793434525113213a9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a0352642a9593ed793434525113213a9a">insert_uninitialized</a> (<a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> position, <a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> n)</td></tr>
<tr class="memdesc:a0352642a9593ed793434525113213a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">&mdash; NON STANDARD METHODS &mdash;  <a href="#a0352642a9593ed793434525113213a9a">More...</a><br/></td></tr>
<tr class="separator:a0352642a9593ed793434525113213a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf220f5a31cf9a836c86b7fe655ad48"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:abaf220f5a31cf9a836c86b7fe655ad48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#abaf220f5a31cf9a836c86b7fe655ad48">push_back</a> (InputIterator <a class="el" href="malloc_8h.html#a40bccbd73bd260de50b2b7feb2a528dc">first</a>, InputIterator last)</td></tr>
<tr class="memdesc:abaf220f5a31cf9a836c86b7fe655ad48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a range of items to the end of the container.  <a href="#abaf220f5a31cf9a836c86b7fe655ad48">More...</a><br/></td></tr>
<tr class="separator:abaf220f5a31cf9a836c86b7fe655ad48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e54db140700aa9fe0ac5cad57e64d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a58e54db140700aa9fe0ac5cad57e64d2">push_back</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> n, const Tp &amp;val)</td></tr>
<tr class="memdesc:a58e54db140700aa9fe0ac5cad57e64d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add elements at the end and initialize them with a value.  <a href="#a58e54db140700aa9fe0ac5cad57e64d2">More...</a><br/></td></tr>
<tr class="separator:a58e54db140700aa9fe0ac5cad57e64d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140d21adbed27c0c8f3b8e2628561abf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a140d21adbed27c0c8f3b8e2628561abf">push_back</a> (std::initializer_list&lt; Tp &gt; initlist)</td></tr>
<tr class="memdesc:a140d21adbed27c0c8f3b8e2628561abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add elements from an initializer list to the end of the container.  <a href="#a140d21adbed27c0c8f3b8e2628561abf">More...</a><br/></td></tr>
<tr class="separator:a140d21adbed27c0c8f3b8e2628561abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7d62a0dcc15c42668e662180b1208f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a0c7d62a0dcc15c42668e662180b1208f">push_back_uninitialized</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> n)</td></tr>
<tr class="memdesc:a0c7d62a0dcc15c42668e662180b1208f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add elements at the end without initializing them.  <a href="#a0c7d62a0dcc15c42668e662180b1208f">More...</a><br/></td></tr>
<tr class="separator:a0c7d62a0dcc15c42668e662180b1208f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a8ce4262f4d9f2325b2e23937917d63b9"><td class="memItemLeft" align="right" valign="top">typedef std::false_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a8ce4262f4d9f2325b2e23937917d63b9">allocator_is_always_equal</a></td></tr>
<tr class="separator:a8ce4262f4d9f2325b2e23937917d63b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a9bb191fc76b0bd9acd5c0f9f4a7dccff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a56141f76e1742adacd4a22b0cfbce59e">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a9bb191fc76b0bd9acd5c0f9f4a7dccff">allocate</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> n)</td></tr>
<tr class="separator:a9bb191fc76b0bd9acd5c0f9f4a7dccff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0743d81f64e1d3eb2ef6092140148313"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a0743d81f64e1d3eb2ef6092140148313">deallocate</a> () noexcept</td></tr>
<tr class="separator:a0743d81f64e1d3eb2ef6092140148313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a7501365172868535c42866baa31df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a27a7501365172868535c42866baa31df">deallocate</a> (<a class="el" href="classao_1_1uvector.html#a56141f76e1742adacd4a22b0cfbce59e">pointer</a> <a class="el" href="classao_1_1uvector.html#a7475fb5e6696984a7bf85bb5818b2aaf">begin</a>, <a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> n) noexcept</td></tr>
<tr class="separator:a27a7501365172868535c42866baa31df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432f3dc2e69dfa2c01ae8a915a9ada1a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a432f3dc2e69dfa2c01ae8a915a9ada1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a432f3dc2e69dfa2c01ae8a915a9ada1a">construct_from_range</a> (InputIterator <a class="el" href="malloc_8h.html#a40bccbd73bd260de50b2b7feb2a528dc">first</a>, InputIterator last, std::false_type)</td></tr>
<tr class="separator:a432f3dc2e69dfa2c01ae8a915a9ada1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fcfa9ae1d997cdd601c0813cb89ab8"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:ad2fcfa9ae1d997cdd601c0813cb89ab8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ad2fcfa9ae1d997cdd601c0813cb89ab8">construct_from_range</a> (Integral n, Integral val, std::true_type)</td></tr>
<tr class="separator:ad2fcfa9ae1d997cdd601c0813cb89ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae228f0096ecfc7349ef9afdbae0120d0"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ae228f0096ecfc7349ef9afdbae0120d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ae228f0096ecfc7349ef9afdbae0120d0">construct_from_range</a> (InputIterator <a class="el" href="malloc_8h.html#a40bccbd73bd260de50b2b7feb2a528dc">first</a>, InputIterator last, std::forward_iterator_tag)</td></tr>
<tr class="separator:ae228f0096ecfc7349ef9afdbae0120d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5eed0606d17dd25f1335cd11d4249a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ada5eed0606d17dd25f1335cd11d4249a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ada5eed0606d17dd25f1335cd11d4249a">assign_from_range</a> (InputIterator <a class="el" href="malloc_8h.html#a40bccbd73bd260de50b2b7feb2a528dc">first</a>, InputIterator last, std::false_type)</td></tr>
<tr class="separator:ada5eed0606d17dd25f1335cd11d4249a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a63797c9e16e54a1eea8652ff0aca6"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:a53a63797c9e16e54a1eea8652ff0aca6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a53a63797c9e16e54a1eea8652ff0aca6">assign_from_range</a> (Integral n, Integral val, std::true_type)</td></tr>
<tr class="memdesc:a53a63797c9e16e54a1eea8652ff0aca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called from assign(iter,iter) when Tp is an integral.  <a href="#a53a63797c9e16e54a1eea8652ff0aca6">More...</a><br/></td></tr>
<tr class="separator:a53a63797c9e16e54a1eea8652ff0aca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025f88cefff664210d62d0e8b35fb493"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a025f88cefff664210d62d0e8b35fb493"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a025f88cefff664210d62d0e8b35fb493">assign_from_range</a> (InputIterator <a class="el" href="malloc_8h.html#a40bccbd73bd260de50b2b7feb2a528dc">first</a>, InputIterator last, std::forward_iterator_tag)</td></tr>
<tr class="separator:a025f88cefff664210d62d0e8b35fb493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb291fe14be711588058761d89a1540"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:afbb291fe14be711588058761d89a1540"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#afbb291fe14be711588058761d89a1540">insert_from_range</a> (<a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> position, InputIterator <a class="el" href="malloc_8h.html#a40bccbd73bd260de50b2b7feb2a528dc">first</a>, InputIterator last, std::false_type)</td></tr>
<tr class="separator:afbb291fe14be711588058761d89a1540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885e5b9c35bf1ff2fcda0b56eff7a9b8"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:a885e5b9c35bf1ff2fcda0b56eff7a9b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a885e5b9c35bf1ff2fcda0b56eff7a9b8">insert_from_range</a> (<a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> position, Integral n, Integral val, std::true_type)</td></tr>
<tr class="separator:a885e5b9c35bf1ff2fcda0b56eff7a9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4552f65896573411fd7d681c845bedda"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a4552f65896573411fd7d681c845bedda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a4552f65896573411fd7d681c845bedda">insert_from_range</a> (<a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> position, InputIterator <a class="el" href="malloc_8h.html#a40bccbd73bd260de50b2b7feb2a528dc">first</a>, InputIterator last, std::forward_iterator_tag)</td></tr>
<tr class="separator:a4552f65896573411fd7d681c845bedda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadcec79408db861875bbf713d671a5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#afadcec79408db861875bbf713d671a5b">check_bounds</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> index) const </td></tr>
<tr class="separator:afadcec79408db861875bbf713d671a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa415f9761d7b2506d932d2cf35491698"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#aa415f9761d7b2506d932d2cf35491698">enlarge_size</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> extra_space_needed) const noexcept</td></tr>
<tr class="separator:aa415f9761d7b2506d932d2cf35491698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3c71ad7051bf305fc4ba4ef332a19f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a6e3c71ad7051bf305fc4ba4ef332a19f">enlarge</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> newSize)</td></tr>
<tr class="separator:a6e3c71ad7051bf305fc4ba4ef332a19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7605f103523646b28409243fede267"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#aba7605f103523646b28409243fede267">enlarge_for_insert</a> (<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> newSize, <a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> insert_position, <a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> insert_count)</td></tr>
<tr class="separator:aba7605f103523646b28409243fede267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8011d1c2f2368b573f403484112c3b07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html">uvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a8011d1c2f2368b573f403484112c3b07">assign_copy_from</a> (const <a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;other, std::false_type)</td></tr>
<tr class="memdesc:a8011d1c2f2368b573f403484112c3b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of operator=(const&amp;) without propagate_on_container_copy_assignment  <a href="#a8011d1c2f2368b573f403484112c3b07">More...</a><br/></td></tr>
<tr class="separator:a8011d1c2f2368b573f403484112c3b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fda69cbbd6a798d0e34fcfabc74659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html">uvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a02fda69cbbd6a798d0e34fcfabc74659">assign_copy_from</a> (const <a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;other, std::true_type)</td></tr>
<tr class="memdesc:a02fda69cbbd6a798d0e34fcfabc74659"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of operator=(const&amp;) with propagate_on_container_copy_assignment  <a href="#a02fda69cbbd6a798d0e34fcfabc74659">More...</a><br/></td></tr>
<tr class="separator:a02fda69cbbd6a798d0e34fcfabc74659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067b6e2e288abce9328b2c4f9be3962e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html">uvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a067b6e2e288abce9328b2c4f9be3962e">assign_move_from</a> (<a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&amp;other, std::false_type) noexcept(allocator_is_always_equal::value)</td></tr>
<tr class="memdesc:a067b6e2e288abce9328b2c4f9be3962e"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of <a class="el" href="classao_1_1uvector.html#a0c460db08f23572e8895d8891f76730a" title="Assign another uvector to this uvector. ">operator=()</a> without propagate_on_container_move_assignment  <a href="#a067b6e2e288abce9328b2c4f9be3962e">More...</a><br/></td></tr>
<tr class="separator:a067b6e2e288abce9328b2c4f9be3962e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb56c887436101adb2173bae70c10ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html">uvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a5cb56c887436101adb2173bae70c10ec">assign_move_from</a> (<a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&amp;other, std::true_type) noexcept</td></tr>
<tr class="memdesc:a5cb56c887436101adb2173bae70c10ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of <a class="el" href="classao_1_1uvector.html#a0c460db08f23572e8895d8891f76730a" title="Assign another uvector to this uvector. ">operator=()</a> with propagate_on_container_move_assignment  <a href="#a5cb56c887436101adb2173bae70c10ec">More...</a><br/></td></tr>
<tr class="separator:a5cb56c887436101adb2173bae70c10ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f037cc0e7c4f8799601b620a3d9e46c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a8f037cc0e7c4f8799601b620a3d9e46c">swap</a> (<a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;other, std::true_type) noexcept</td></tr>
<tr class="memdesc:a8f037cc0e7c4f8799601b620a3d9e46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of swap with propagate_on_container_swap  <a href="#a8f037cc0e7c4f8799601b620a3d9e46c">More...</a><br/></td></tr>
<tr class="separator:a8f037cc0e7c4f8799601b620a3d9e46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e9b31e539c21a5bd4fbfab4ac68af2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a53e9b31e539c21a5bd4fbfab4ac68af2">swap</a> (<a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;other, std::false_type) noexcept</td></tr>
<tr class="memdesc:a53e9b31e539c21a5bd4fbfab4ac68af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of swap without propagate_on_container_swap  <a href="#a53e9b31e539c21a5bd4fbfab4ac68af2">More...</a><br/></td></tr>
<tr class="separator:a53e9b31e539c21a5bd4fbfab4ac68af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a699aca94ccc931ec1a53bd342d0d1"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a18a699aca94ccc931ec1a53bd342d0d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a18a699aca94ccc931ec1a53bd342d0d1">push_back_range</a> (InputIterator <a class="el" href="malloc_8h.html#a40bccbd73bd260de50b2b7feb2a528dc">first</a>, InputIterator last, std::false_type)</td></tr>
<tr class="separator:a18a699aca94ccc931ec1a53bd342d0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578597c310dff5db5d5fa35697ff25e1"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:a578597c310dff5db5d5fa35697ff25e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a578597c310dff5db5d5fa35697ff25e1">push_back_range</a> (Integral n, Integral val, std::true_type)</td></tr>
<tr class="memdesc:a578597c310dff5db5d5fa35697ff25e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called from push_back(iter,iter) when Tp is an integral.  <a href="#a578597c310dff5db5d5fa35697ff25e1">More...</a><br/></td></tr>
<tr class="separator:a578597c310dff5db5d5fa35697ff25e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d28873fce89100602ceac8a3d872b77"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a3d28873fce89100602ceac8a3d872b77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a3d28873fce89100602ceac8a3d872b77">push_back_range</a> (InputIterator <a class="el" href="malloc_8h.html#a40bccbd73bd260de50b2b7feb2a528dc">first</a>, InputIterator last, std::forward_iterator_tag)</td></tr>
<tr class="separator:a3d28873fce89100602ceac8a3d872b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae628f800fdf44b2f1b2137fc187c7fbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a56141f76e1742adacd4a22b0cfbce59e">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ae628f800fdf44b2f1b2137fc187c7fbc">_begin</a></td></tr>
<tr class="separator:ae628f800fdf44b2f1b2137fc187c7fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7452cde30f09bdb3173471bac870258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a56141f76e1742adacd4a22b0cfbce59e">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#ac7452cde30f09bdb3173471bac870258">_end</a></td></tr>
<tr class="separator:ac7452cde30f09bdb3173471bac870258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b98e3dde99abe591909a785851506fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classao_1_1uvector.html#a56141f76e1742adacd4a22b0cfbce59e">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classao_1_1uvector.html#a3b98e3dde99abe591909a785851506fa">_endOfStorage</a></td></tr>
<tr class="separator:a3b98e3dde99abe591909a785851506fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt;<br/>
class ao::uvector&lt; Tp, Alloc &gt;</h3>

<p>A container similar to std::vector, but one that allows construction without initializing its elements. </p>
<p>This container is similar to a std::vector, except that it can be constructed without initializing its elements. This saves the overhead of initialization, hence the constructor <a class="el" href="classao_1_1uvector.html#ae5d234595295b78c788ed2140d8b1a89">uvector(size_t)</a> is significantly faster than the corresponding std::vector constructor, and has no overhead compared to a manually allocated array.</p>
<p>Probably its greatest strength lies in the construction of containers with a number of elements that is runtime defined, but that will be initialized later. For example:</p>
<div class="fragment"><div class="line">* <span class="comment">// Open a file</span></div>
<div class="line">* ifstream file(<span class="stringliteral">&quot;myfile.bin&quot;</span>);</div>
<div class="line">* </div>
<div class="line">* <span class="comment">// Construct a buffer for this file</span></div>
<div class="line">* uvector&lt;char&gt; buffer(buffer_size);</div>
<div class="line">* </div>
<div class="line">* <span class="comment">// Read some data into the buffer</span></div>
<div class="line">* file.read(&amp;buffer[0], buffer_size);</div>
<div class="line">* </div>
</div><!-- fragment --><p>However, it has a few more use-cases with improved performance over std::vector. This is possible because of more strengent requirements on the element's type.</p>
<p>The container will behave correctly with any trivial type, but will not work for almost all non-trivial types.</p>
<p>The methods with different semantics compared to std::vector are:</p>
<ul>
<li><a class="el" href="classao_1_1uvector.html#ae5d234595295b78c788ed2140d8b1a89">uvector(size_t n)</a></li>
<li><a class="el" href="classao_1_1uvector.html#a438e78bce885a37dc76c7b1bef016355">resize(size_t n)</a></li>
</ul>
<p>Also the following new members are introduced:</p>
<ul>
<li><a class="el" href="classao_1_1uvector.html#a0352642a9593ed793434525113213a9a">insert_uninitialized(const_iterator position, size_t n)</a></li>
<li><a class="el" href="classao_1_1uvector.html#abaf220f5a31cf9a836c86b7fe655ad48">push_back(InputIterator first, InputIterator last)</a></li>
<li><a class="el" href="classao_1_1uvector.html#a58e54db140700aa9fe0ac5cad57e64d2">push_back(size_t n, const Tp&amp; val)</a></li>
<li><a class="el" href="classao_1_1uvector.html#a140d21adbed27c0c8f3b8e2628561abf">push_back(std::initializer_list&lt;Tp&gt; initlist)</a></li>
<li><a class="el" href="classao_1_1uvector.html#a0c7d62a0dcc15c42668e662180b1208f">push_back_uninitialized(size_t n)</a></li>
</ul>
<p>All other members work exactly like std::vector's members, although some are slightly faster because of the stricter requirements on the element type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tp</td><td>Container's element type </td></tr>
    <tr><td class="paramname">Alloc</td><td>Allocator type. Default is to use the std::allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Andr Offringa </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Andr Offringa, 2013, distributed under the GPL license version 3. </dd></dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00073">73</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a8ce4262f4d9f2325b2e23937917d63b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::false_type <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html#a8ce4262f4d9f2325b2e23937917d63b9">allocator_is_always_equal</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00075">75</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6e0f4b56eca3a8e5b76bcc2de5cffcda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html#a6e0f4b56eca3a8e5b76bcc2de5cffcda">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of allocator used to allocate and deallocate space. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00086">86</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a011d6c3bfe6cabe6984019064522762c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const Tp* <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator type of constant elements. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00098">98</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6c1117840801f4059221f50d62fbaed9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const Tp* <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html#a6c1117840801f4059221f50d62fbaed9">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to constant element type. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00094">94</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a276633c9c49f4f4341feb20d58bbea26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const Tp&amp; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html#a276633c9c49f4f4341feb20d58bbea26">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant reference to element type. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00090">90</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac25f986e75fa5090132984e31783ebb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&gt; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html#ac25f986e75fa5090132984e31783ebb0">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse iterator of constant elements. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00102">102</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="adda3a6b0829c0245e14ffa70152cee70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html#adda3a6b0829c0245e14ffa70152cee70">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Difference between to iterators. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00104">104</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a597be551193c3a7d8d8a9ba57b2d21ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tp* <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator type. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00096">96</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a56141f76e1742adacd4a22b0cfbce59e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tp* <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html#a56141f76e1742adacd4a22b0cfbce59e">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to element type. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00092">92</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a653d02899bdbb5f56e3085020e435a7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tp&amp; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html#a653d02899bdbb5f56e3085020e435a7e">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference to element type. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00088">88</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a43730bd384eabef86420b4f18260f197"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a>&gt; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html#a43730bd384eabef86420b4f18260f197">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse iterator type. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00100">100</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="af8b2cbb86306b29cda7237156950bc8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used for indexing elements. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00106">106</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="afe2c30fa610be46118af297f37f27ca1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html#afe2c30fa610be46118af297f37f27ca1">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used for indexing elements. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00108">108</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a71db057aafa119005b4dee13c4db52cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tp <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html#a71db057aafa119005b4dee13c4db52cf">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element type. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00084">84</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0a5f71a18d12bcdd15af33f6f7bf4925"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html">uvector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classao_1_1uvector.html#a6e0f4b56eca3a8e5b76bcc2de5cffcda">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Alloc()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty uvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>Allocator used for allocating and deallocating memory. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00117">117</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae5d234595295b78c788ed2140d8b1a89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html">uvector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a vector with given amount of elements, without initializing these. </p>
<p>This constructor deviates from std::vector's behaviour, because it will not value construct its elements. It is therefore faster than the corresponding constructor of std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements that the uvector will be initialized with. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00128">128</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae5f3c0817ed668be39ffebfdb1cfeb72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html">uvector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classao_1_1uvector.html#a71db057aafa119005b4dee13c4db52cf">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classao_1_1uvector.html#a6e0f4b56eca3a8e5b76bcc2de5cffcda">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a vector with given amount of elements and set these to a specific value. </p>
<p>This constructor will initialize its members with the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements that the uvector will be initialized with. </td></tr>
    <tr><td class="paramname">val</td><td>Value to initialize all elements with </td></tr>
    <tr><td class="paramname">allocator</td><td>Allocator used for allocating and deallocating memory. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00141">141</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7a5467232a346a461969386d55b45437"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html">uvector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classao_1_1uvector.html#a6e0f4b56eca3a8e5b76bcc2de5cffcda">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a vector by copying elements from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to range start </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to range end </td></tr>
    <tr><td class="paramname">allocator</td><td>Allocator used for allocating and deallocating memory. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00156">156</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="abab9ebda59065a14e8401fb5ed0497dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html">uvector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy construct a uvector. </p>
<p>The allocator of the new uvector will be initialized from <code>std::allocator_traits&lt;Alloc&gt;::select_on_container_copy_construction(other)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Source uvector to be copied from. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00167">167</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a33eb364955d9dc097b97b6babe84d720"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html">uvector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classao_1_1uvector.html#a6e0f4b56eca3a8e5b76bcc2de5cffcda">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy construct a uvector with custom allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Source uvector to be copied from. </td></tr>
    <tr><td class="paramname">allocator</td><td>Allocator used for allocating and deallocating memory. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00180">180</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3497a068dd5662316d6a1dc6327cfe7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html">uvector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move construct a uvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Source uvector to be moved from. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00192">192</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="af9ebf4a255853677de835e04ff3581c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html">uvector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classao_1_1uvector.html#a6e0f4b56eca3a8e5b76bcc2de5cffcda">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move construct a uvector with custom allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Source uvector to be moved from. </td></tr>
    <tr><td class="paramname">allocator</td><td>Allocator used for allocating and deallocating memory. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00207">207</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac64d97b346360ed05c2b6febdcbc0f2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::<a class="el" href="classao_1_1uvector.html">uvector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; Tp &gt;&#160;</td>
          <td class="paramname"><em>initlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classao_1_1uvector.html#a6e0f4b56eca3a8e5b76bcc2de5cffcda">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a uvector from a initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initlist</td><td>Initializer list used for initializing the new uvector. </td></tr>
    <tr><td class="paramname">allocator</td><td>Allocator used for allocating and deallocating memory. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00222">222</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0384ea33901f406fc1e98b4757ce17cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::~<a class="el" href="classao_1_1uvector.html">uvector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00237">237</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9bb191fc76b0bd9acd5c0f9f4a7dccff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a56141f76e1742adacd4a22b0cfbce59e">pointer</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00839">839</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="uvector_8h_source.html#l00467">ao::uvector&lt; value_t &gt;::assign()</a>, <a class="el" href="uvector_8h_source.html#l01007">ao::uvector&lt; value_t &gt;::assign_copy_from()</a>, <a class="el" href="uvector_8h_source.html#l00894">ao::uvector&lt; value_t &gt;::assign_from_range()</a>, <a class="el" href="uvector_8h_source.html#l00862">ao::uvector&lt; value_t &gt;::construct_from_range()</a>, <a class="el" href="uvector_8h_source.html#l00985">ao::uvector&lt; value_t &gt;::enlarge()</a>, <a class="el" href="uvector_8h_source.html#l00995">ao::uvector&lt; value_t &gt;::enlarge_for_insert()</a>, <a class="el" href="uvector_8h_source.html#l00368">ao::uvector&lt; value_t &gt;::reserve()</a>, <a class="el" href="uvector_8h_source.html#l00313">ao::uvector&lt; value_t &gt;::resize()</a>, and <a class="el" href="uvector_8h_source.html#l00388">ao::uvector&lt; value_t &gt;::shrink_to_fit()</a>.</p>

</div>
</div>
<a class="anchor" id="acb06505af16be08f01f5a0028da9fe88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign this container to be equal to the given range. </p>
<p>The container will be resized to fit the length of the given range. Iterators are invalidated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the beginning of the range. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator past the end of the range. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00457">457</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6f47d3741444fa997327c2f6f7b3e6c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the container and assign the given value to all elements. </p>
<p>Iterators are invalidated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>New size of container </td></tr>
    <tr><td class="paramname">val</td><td>Value to be assigned to all elements. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00467">467</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a634a276af97bd750a36177b701a9d146"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; Tp &gt;&#160;</td>
          <td class="paramname"><em>initlist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign this container to an initializer list. </p>
<p>The container will be resized to fit the length of the given initializer list. Iterators are invalidated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initlist</td><td>List of values to assign to the container. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00485">485</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8011d1c2f2368b573f403484112c3b07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html">uvector</a>&amp; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::assign_copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::false_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>implementation of operator=(const&amp;) without propagate_on_container_copy_assignment </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l01007">1007</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="uvector_8h_source.html#l01022">ao::uvector&lt; value_t &gt;::assign_copy_from()</a>, <a class="el" href="uvector_8h_source.html#l01042">ao::uvector&lt; value_t &gt;::assign_move_from()</a>, and <a class="el" href="uvector_8h_source.html#l00246">ao::uvector&lt; value_t &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a02fda69cbbd6a798d0e34fcfabc74659"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html">uvector</a>&amp; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::assign_copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::true_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>implementation of operator=(const&amp;) with propagate_on_container_copy_assignment </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l01022">1022</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ada5eed0606d17dd25f1335cd11d4249a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::assign_from_range </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::false_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00886">886</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a53a63797c9e16e54a1eea8652ff0aca6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Integral &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::assign_from_range </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::true_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is called from assign(iter,iter) when Tp is an integral. </p>
<p>In that case, the user tried to call assign(n, &amp;val), but it got caught by the wrong overload. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00894">894</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a025f88cefff664210d62d0e8b35fb493"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::assign_from_range </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_iterator_tag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00908">908</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a067b6e2e288abce9328b2c4f9be3962e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html">uvector</a>&amp; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::assign_move_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::false_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>implementation of <a class="el" href="classao_1_1uvector.html#a0c460db08f23572e8895d8891f76730a" title="Assign another uvector to this uvector. ">operator=()</a> without propagate_on_container_move_assignment </p>
<p>We should not propagate the allocator and the allocators are different. This means we can not swap the allocated space, since then we would deallocate the space with a different allocator type. Therefore, we need to copy: </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l01042">1042</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="uvector_8h_source.html#l00255">ao::uvector&lt; value_t &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a5cb56c887436101adb2173bae70c10ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html">uvector</a>&amp; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::assign_move_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::true_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>implementation of <a class="el" href="classao_1_1uvector.html#a0c460db08f23572e8895d8891f76730a" title="Assign another uvector to this uvector. ">operator=()</a> with propagate_on_container_move_assignment </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l01065">1065</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab2f17d41f81b07231a38115d4337ad85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tp&amp; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the element at the given index with bounds checking. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>when given index is past the last element. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00417">417</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac1c33ca25d3257762f6c86e6cc571446"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Tp&amp; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a constant reference to the element at the given index with bounds checking. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>when given index is past the last element. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00426">426</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a351232c0a0ca4e981ab64276d37ecb51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tp&amp; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get reference to last element in container. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00439">439</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="stochasticencoder_8h_source.html#l00248">dyscostman::StochasticEncoder&lt; ValueType &gt;::Dictionary::largest_value()</a>.</p>

</div>
</div>
<a class="anchor" id="a77f388e6de64028142fab43234f50d4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Tp&amp; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get constant reference to last element in container. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00442">442</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7475fb5e6696984a7bf85bb5818b2aaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get iterator to first element. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00263">263</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="stochasticencoder_8h_source.html#l00241">dyscostman::StochasticEncoder&lt; ValueType &gt;::Dictionary::begin()</a>, <a class="el" href="uvector_8h_source.html#l00296">ao::uvector&lt; value_t &gt;::crend()</a>, <a class="el" href="uvector_8h_source.html#l00849">ao::uvector&lt; value_t &gt;::deallocate()</a>, <a class="el" href="stochasticencoder_8h_source.html#l00227">dyscostman::StochasticEncoder&lt; ValueType &gt;::Dictionary::lower_bound_slow()</a>, and <a class="el" href="uvector_8h_source.html#l00281">ao::uvector&lt; value_t &gt;::rend()</a>.</p>

</div>
</div>
<a class="anchor" id="a78a480d1be5a65f7110e4f1a34724756"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get constant iterator to first element. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00266">266</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ad9f7960b8a324c03b6983f7ff31330"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of elements the container can currently hold without reallocating storage. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00353">353</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="uvector_8h_source.html#l00467">ao::uvector&lt; value_t &gt;::assign()</a>, <a class="el" href="uvector_8h_source.html#l01007">ao::uvector&lt; value_t &gt;::assign_copy_from()</a>, <a class="el" href="uvector_8h_source.html#l00894">ao::uvector&lt; value_t &gt;::assign_from_range()</a>, <a class="el" href="stochasticencoder_8h_source.html#l00251">dyscostman::StochasticEncoder&lt; ValueType &gt;::Dictionary::capacity()</a>, <a class="el" href="uvector_8h_source.html#l00844">ao::uvector&lt; value_t &gt;::deallocate()</a>, <a class="el" href="uvector_8h_source.html#l00569">ao::uvector&lt; value_t &gt;::insert()</a>, <a class="el" href="uvector_8h_source.html#l00935">ao::uvector&lt; value_t &gt;::insert_from_range()</a>, <a class="el" href="uvector_8h_source.html#l00762">ao::uvector&lt; value_t &gt;::insert_uninitialized()</a>, <a class="el" href="uvector_8h_source.html#l00797">ao::uvector&lt; value_t &gt;::push_back()</a>, <a class="el" href="uvector_8h_source.html#l01125">ao::uvector&lt; value_t &gt;::push_back_range()</a>, <a class="el" href="uvector_8h_source.html#l00368">ao::uvector&lt; value_t &gt;::reserve()</a>, <a class="el" href="uvector_8h_source.html#l00313">ao::uvector&lt; value_t &gt;::resize()</a>, and <a class="el" href="uvector_8h_source.html#l00388">ao::uvector&lt; value_t &gt;::shrink_to_fit()</a>.</p>

</div>
</div>
<a class="anchor" id="a55134b90a07642e7374ee7361d620f72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get constant iterator to first element. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00287">287</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a87d13a83df89d072e4bbea587f47e35a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get constant iterator to element past last element. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00290">290</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="afadcec79408db861875bbf713d671a5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::check_bounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00974">974</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="uvector_8h_source.html#l00417">ao::uvector&lt; value_t &gt;::at()</a>.</p>

</div>
</div>
<a class="anchor" id="a7fc11179ac391addb252718f9134689d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all elements from the container. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00701">701</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a432f3dc2e69dfa2c01ae8a915a9ada1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::construct_from_range </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::false_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00856">856</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad2fcfa9ae1d997cdd601c0813cb89ab8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Integral &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::construct_from_range </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::true_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00862">862</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae228f0096ecfc7349ef9afdbae0120d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::construct_from_range </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_iterator_tag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00871">871</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="acd31db66931f8cc780b53d1711ced0d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#ac25f986e75fa5090132984e31783ebb0">const_reverse_iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get constant reverse iterator to last element. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00293">293</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a22f772273ac3ddaf9adc600f781d2e52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#ac25f986e75fa5090132984e31783ebb0">const_reverse_iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get constant reverse iterator to element before first element. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00296">296</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2475deee7f0d64164eedebbd2910cc55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tp* <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to internal storage. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00445">445</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a928c9d33d2c1b4c2cb917a8b58135a14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Tp* <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get constant pointer to internal storage. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00448">448</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0743d81f64e1d3eb2ef6092140148313"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::deallocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00844">844</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="uvector_8h_source.html#l00467">ao::uvector&lt; value_t &gt;::assign()</a>, <a class="el" href="uvector_8h_source.html#l01007">ao::uvector&lt; value_t &gt;::assign_copy_from()</a>, <a class="el" href="uvector_8h_source.html#l00894">ao::uvector&lt; value_t &gt;::assign_from_range()</a>, <a class="el" href="uvector_8h_source.html#l01042">ao::uvector&lt; value_t &gt;::assign_move_from()</a>, <a class="el" href="uvector_8h_source.html#l00844">ao::uvector&lt; value_t &gt;::deallocate()</a>, <a class="el" href="uvector_8h_source.html#l00985">ao::uvector&lt; value_t &gt;::enlarge()</a>, <a class="el" href="uvector_8h_source.html#l00995">ao::uvector&lt; value_t &gt;::enlarge_for_insert()</a>, <a class="el" href="uvector_8h_source.html#l00368">ao::uvector&lt; value_t &gt;::reserve()</a>, <a class="el" href="uvector_8h_source.html#l00313">ao::uvector&lt; value_t &gt;::resize()</a>, <a class="el" href="uvector_8h_source.html#l00388">ao::uvector&lt; value_t &gt;::shrink_to_fit()</a>, and <a class="el" href="uvector_8h_source.html#l00237">ao::uvector&lt; value_t &gt;::~uvector()</a>.</p>

</div>
</div>
<a class="anchor" id="a27a7501365172868535c42866baa31df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#a56141f76e1742adacd4a22b0cfbce59e">pointer</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00849">849</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac5b27abe6c7d0c75a71eaaa9bd42afc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element at a given position by constructing it in place. </p>
<p>All iterators will be invalidated. This operation needs to move all elements after the new element, and can therefore be expensive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position of the new element. The new element will be added before the old element at that position. </td></tr>
    <tr><td class="paramname">args</td><td>List of arguments to be forwarded to construct the new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the new element. </dd></dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00715">715</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a635aa35da74c9de2a3e62e54f8a4ddfb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given value to the end of the container by constructing it in place. </p>
<p>Iterators are invalidated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>List of arguments to be forwarded to construct the new element. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00736">736</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a834534d95e4406d971a9c2599cefc790"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the container is currently empty. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a class="el" href="classao_1_1uvector.html#a3ce3e9629d364cbcb7d0e878c127801f">size()</a> == 0. </dd></dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00357">357</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a92761da8791e8e10b65281d9ef6c39cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get iterator to element past last element. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00269">269</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="uvector_8h_source.html#l00293">ao::uvector&lt; value_t &gt;::crbegin()</a>, <a class="el" href="stochasticencoder_8h_source.html#l00243">dyscostman::StochasticEncoder&lt; ValueType &gt;::Dictionary::end()</a>, and <a class="el" href="uvector_8h_source.html#l00275">ao::uvector&lt; value_t &gt;::rbegin()</a>.</p>

</div>
</div>
<a class="anchor" id="a93a3ba594d1bb8a88670aa9fbb018adf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get constant iterator to element past last element. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00272">272</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6e3c71ad7051bf305fc4ba4ef332a19f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::enlarge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00985">985</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="uvector_8h_source.html#l00736">ao::uvector&lt; value_t &gt;::emplace_back()</a>, <a class="el" href="uvector_8h_source.html#l00507">ao::uvector&lt; value_t &gt;::push_back()</a>, and <a class="el" href="uvector_8h_source.html#l01125">ao::uvector&lt; value_t &gt;::push_back_range()</a>.</p>

</div>
</div>
<a class="anchor" id="aba7605f103523646b28409243fede267"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::enlarge_for_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>insert_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>insert_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00995">995</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="uvector_8h_source.html#l00715">ao::uvector&lt; value_t &gt;::emplace()</a>, <a class="el" href="uvector_8h_source.html#l00544">ao::uvector&lt; value_t &gt;::insert()</a>, <a class="el" href="uvector_8h_source.html#l00935">ao::uvector&lt; value_t &gt;::insert_from_range()</a>, and <a class="el" href="uvector_8h_source.html#l00762">ao::uvector&lt; value_t &gt;::insert_uninitialized()</a>.</p>

</div>
</div>
<a class="anchor" id="aa415f9761d7b2506d932d2cf35491698"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::enlarge_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>extra_space_needed</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00980">980</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="uvector_8h_source.html#l00715">ao::uvector&lt; value_t &gt;::emplace()</a>, <a class="el" href="uvector_8h_source.html#l00736">ao::uvector&lt; value_t &gt;::emplace_back()</a>, <a class="el" href="uvector_8h_source.html#l00544">ao::uvector&lt; value_t &gt;::insert()</a>, <a class="el" href="uvector_8h_source.html#l00935">ao::uvector&lt; value_t &gt;::insert_from_range()</a>, <a class="el" href="uvector_8h_source.html#l00762">ao::uvector&lt; value_t &gt;::insert_uninitialized()</a>, <a class="el" href="uvector_8h_source.html#l00507">ao::uvector&lt; value_t &gt;::push_back()</a>, <a class="el" href="uvector_8h_source.html#l01125">ao::uvector&lt; value_t &gt;::push_back_range()</a>, and <a class="el" href="uvector_8h_source.html#l00313">ao::uvector&lt; value_t &gt;::resize()</a>.</p>

</div>
</div>
<a class="anchor" id="a834bab716da5d5eae98f203511e072b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete an element from the container. </p>
<p>This operation moves all elements past the removed element, and can therefore be expensive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position of element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element past the delete element. </dd></dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00663">663</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="adbc616c537e5915439524719f856b6a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a range of elements from the container. </p>
<p>This operation moves all elements past the removed elements, and can therefore be expensive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Position of first element to be removed. </td></tr>
    <tr><td class="paramname">last</td><td>Position past last element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element past the delete element. </dd></dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00677">677</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="aee98ea97e491f3ee31ca28e2d832ce53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tp&amp; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get reference to first element in container. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00433">433</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="stochasticencoder_8h_source.html#l00249">dyscostman::StochasticEncoder&lt; ValueType &gt;::Dictionary::smallest_value()</a>.</p>

</div>
</div>
<a class="anchor" id="aa415b08862cffdcacadf13c3212af303"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Tp&amp; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get constant reference to first element in container. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00436">436</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="af2ae154a74e75c0db67dcab01fde637e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a6e0f4b56eca3a8e5b76bcc2de5cffcda">allocator_type</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the allocator. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00745">745</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="af98ccf7b248bb73ee8805f9a65f9a6a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element at a given position. </p>
<p>All iterators will be invalidated. This operation needs to move all elements after the new element, and can therefore be expensive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position of the new element. The new element will be added before the old element at that position. </td></tr>
    <tr><td class="paramname">item</td><td>Value of the new item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the new element. </dd></dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00544">544</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa1a3f5fceafd44237491931013f6d0e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements at a given position and initialize them with a value. </p>
<p>All iterators will be invalidated. This operation needs to move all elements after the new element, and can therefore be expensive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position of the new elements. The new elements will be added before the old element at that position. </td></tr>
    <tr><td class="paramname">n</td><td>Number of elements to add. </td></tr>
    <tr><td class="paramname">val</td><td>Value of the new item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first new element. </dd></dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00569">569</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7aa7fe6ffc176a2b0c0c64d5f881737d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements at a given position and initialize them from a range. </p>
<p>All iterators will be invalidated. This operation needs to move all elements after the new element, and can therefore be expensive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position of the new elements. The new elements will be added before the old element at that position. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the beginning of the range. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator past the end of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first new element. </dd></dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00595">595</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="aac20e88d7cd2f10f3d0073de746ba7c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tp &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element at a given position by moving it in. </p>
<p>All iterators will be invalidated. This operation needs to move all elements after the new element, and can therefore be expensive.</p>
<p>Note that this container can only hold simple types that do not perform allocations. Therefore, there is probably no benefit in moving the new item in over copying it in with <a class="el" href="classao_1_1uvector.html#af98ccf7b248bb73ee8805f9a65f9a6a9">insert(const_iterator, const Tp&amp;)</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position of the new element. The new element will be added before the old element at that position. </td></tr>
    <tr><td class="paramname">item</td><td>Value of the new item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the new element. </dd></dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00612">612</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a88716bb0affe3a4949b99f2a63851117"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; Tp &gt;&#160;</td>
          <td class="paramname"><em>initlist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements at a given position and initialize them from a initializer list. </p>
<p>All iterators will be invalidated. This operation needs to move all elements after the new element, and can therefore be expensive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position of the new elements. The new elements will be added before the old element at that position. </td></tr>
    <tr><td class="paramname">initlist</td><td>List of items to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first new element. </dd></dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00636">636</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="afbb291fe14be711588058761d89a1540"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::insert_from_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::false_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00928">928</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a885e5b9c35bf1ff2fcda0b56eff7a9b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Integral &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::insert_from_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::true_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00935">935</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4552f65896573411fd7d681c845bedda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::insert_from_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_iterator_tag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00952">952</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0352642a9593ed793434525113213a9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a597be551193c3a7d8d8a9ba57b2d21ad">iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::insert_uninitialized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#a011d6c3bfe6cabe6984019064522762c">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&mdash; NON STANDARD METHODS &mdash; </p>
<p>Insert elements at a given position without initializing them.</p>
<p>All iterators will be invalidated. This operation needs to move all elements after the new element, and can therefore be expensive. It will not initialize the new elements, and is therefore faster than <a class="el" href="classao_1_1uvector.html#aa1a3f5fceafd44237491931013f6d0e6">insert(const_iterator, size_t, const Tp&amp;)</a>.</p>
<p>This method is non-standard: it is not present in std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position of the new elements. The new elements will be added before the old element at that position. </td></tr>
    <tr><td class="paramname">n</td><td>Number of elements to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00762">762</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae8a2f7c95a33b257c176b8edb3d7e880"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum number of elements that this container can hold. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00302">302</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0c460db08f23572e8895d8891f76730a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html">uvector</a>&amp; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign another uvector to this uvector. </p>
<p>The allocator of the uvector will be assigned to <code>other</code> when std::allocator_traits&lt;Alloc&gt;::propagate_on_container_copy_assignment() is of true_type. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00246">246</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae29fca669efe2f1dc46de39607752059"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html">uvector</a>&amp; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign another uvector to this uvector. </p>
<p>The allocator of the uvector will be assigned to <code>other</code> when std::allocator_traits&lt;Alloc&gt;::propagate_on_container_move_assignment() is of true_type. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00255">255</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab025e61401da9f352c82b211377d3c66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tp&amp; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the element at the given index. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00409">409</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2f353b9ea4d9b3fde8bc035efb257ee7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Tp&amp; <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a constant reference to the element at the given index. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00412">412</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="aab5bf48390f54e1dfcf812d484b5135b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the last element from the container. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00531">531</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="adcf96370233197b0a9161ccbe6fd12cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given value to the end of the container. </p>
<p>Iterators are invalidated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Value of new element. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00507">507</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae2204216d5a93b14845859bfdefa4dbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">Tp &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given value to the end of the container by moving it in. </p>
<p>Iterators are invalidated.</p>
<p>Note that this container can only hold simple types that do not perform allocations. Therefore, there is probably no benefit in moving the new item in over copying it in with <a class="el" href="classao_1_1uvector.html#adcf96370233197b0a9161ccbe6fd12cd">push_back(const Tp&amp;)</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Value of new element. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00522">522</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="abaf220f5a31cf9a836c86b7fe655ad48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a range of items to the end of the container. </p>
<p>All iterators will be invalidated.</p>
<p>This method is non-standard: it is not present in std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the beginning of the range. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator past the end of the range. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00785">785</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a58e54db140700aa9fe0ac5cad57e64d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add elements at the end and initialize them with a value. </p>
<p>All iterators will be invalidated.</p>
<p>This method is non-standard: it is not present in std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements to add. </td></tr>
    <tr><td class="paramname">val</td><td>Value of the new items. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00797">797</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a140d21adbed27c0c8f3b8e2628561abf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; Tp &gt;&#160;</td>
          <td class="paramname"><em>initlist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add elements from an initializer list to the end of the container. </p>
<p>All iterators will be invalidated.</p>
<p>This method is non-standard: it is not present in std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initlist</td><td>The list with values to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00813">813</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a18a699aca94ccc931ec1a53bd342d0d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::push_back_range </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::false_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l01117">1117</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a578597c310dff5db5d5fa35697ff25e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Integral &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::push_back_range </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::true_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is called from push_back(iter,iter) when Tp is an integral. </p>
<p>In that case, the user tried to call push_back(n, &amp;val), but it got caught by the wrong overload. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l01125">1125</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3d28873fce89100602ceac8a3d872b77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::push_back_range </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_iterator_tag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l01136">1136</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0c7d62a0dcc15c42668e662180b1208f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::push_back_uninitialized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add elements at the end without initializing them. </p>
<p>All iterators will be invalidated.</p>
<p>This method is non-standard: it is not present in std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00832">832</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac0d98dd5e689aeb68db234484515f96e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a43730bd384eabef86420b4f18260f197">reverse_iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get reverse iterator to last element. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00275">275</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2e3325a0a78cd6fb6ba7293c85da2c10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#ac25f986e75fa5090132984e31783ebb0">const_reverse_iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get constant reverse iterator to last element. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00278">278</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a580e426b99d03410df6e57dc50da8c33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a43730bd384eabef86420b4f18260f197">reverse_iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get reverse iterator to element before first element. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00281">281</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5c763e0f42637fbe9e63cf87734d7223"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#ac25f986e75fa5090132984e31783ebb0">const_reverse_iterator</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get constant reverse iterator to element before first element. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00284">284</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5c17d4bacbb3983c24a1477b15ec4bc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve space for a number of elements, to prevent the overhead of extra reallocations. </p>
<p>This has no effect on the working of the uvector, except that it might change the current capacity. This can enhance performance when a large number of elements are added, and an approximate size is known a priori.</p>
<p>This method might cause a reallocation, causing iterators to be invalidated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements to reserve space for. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00368">368</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="stochasticencoder_8h_source.html#l00170">dyscostman::StochasticEncoder&lt; ValueType &gt;::Dictionary::reserve()</a>.</p>

</div>
</div>
<a class="anchor" id="a438e78bce885a37dc76c7b1bef016355"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the number of elements in the container. </p>
<p>If the new size is larger than the current size, new values will be left uninitialized. Therefore, it is more efficient than <code><a class="el" href="classao_1_1uvector.html#a438e78bce885a37dc76c7b1bef016355" title="Change the number of elements in the container. ">resize(size_t)</a></code> in <code>std::vector</code>, as well as <a class="el" href="classao_1_1uvector.html#a846b103e8ff6f675f481197127b4a389">resize(size_t, const Tp&amp;)</a>. If the new size is smaller than the current size, the container will be truncated and elements past the new size will be removed. No destructor of the removed elements will be called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The new size of the container. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00313">313</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="uvector_8h_source.html#l00832">ao::uvector&lt; value_t &gt;::push_back_uninitialized()</a>, and <a class="el" href="stochasticencoder_8h_source.html#l00172">dyscostman::StochasticEncoder&lt; ValueType &gt;::Dictionary::resize()</a>.</p>

</div>
</div>
<a class="anchor" id="a846b103e8ff6f675f481197127b4a389"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the number of elements in the container. </p>
<p>If the new size is larger than the current size, new values will be initialized by the given value. If the new size is smaller than the current size, the container will be truncated and elements past the new size will be removed. No destructor of the removed elements will be called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The new size of the container. </td></tr>
    <tr><td class="paramname">val</td><td>New value of elements that get added to the container. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00336">336</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a08863dcb6f57dd9f7fec8190ed2055cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the capacity of the container such that no extra space is hold. </p>
<p>This has no effect on the working of the uvector, except that it might change the current capacity. This can reduce the current memory usage of the container.</p>
<p>This method might cause a reallocation, causing iterators to be invalidated. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00388">388</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ce3e9629d364cbcb7d0e878c127801f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#af8b2cbb86306b29cda7237156950bc8f">size_t</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of elements in container. </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00299">299</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="uvector_8h_source.html#l01007">ao::uvector&lt; value_t &gt;::assign_copy_from()</a>, <a class="el" href="uvector_8h_source.html#l00974">ao::uvector&lt; value_t &gt;::check_bounds()</a>, <a class="el" href="uvector_8h_source.html#l00985">ao::uvector&lt; value_t &gt;::enlarge()</a>, <a class="el" href="uvector_8h_source.html#l00995">ao::uvector&lt; value_t &gt;::enlarge_for_insert()</a>, <a class="el" href="uvector_8h_source.html#l00980">ao::uvector&lt; value_t &gt;::enlarge_size()</a>, <a class="el" href="uvector_8h_source.html#l00569">ao::uvector&lt; value_t &gt;::insert()</a>, <a class="el" href="uvector_8h_source.html#l00935">ao::uvector&lt; value_t &gt;::insert_from_range()</a>, <a class="el" href="uvector_8h_source.html#l00762">ao::uvector&lt; value_t &gt;::insert_uninitialized()</a>, <a class="el" href="stochasticencoder_8h_source.html#l00245">dyscostman::StochasticEncoder&lt; ValueType &gt;::Dictionary::largest_symbol()</a>, <a class="el" href="stochasticencoder_8h_source.html#l00182">dyscostman::StochasticEncoder&lt; ValueType &gt;::Dictionary::lower_bound()</a>, <a class="el" href="stochasticencoder_8h_source.html#l00209">dyscostman::StochasticEncoder&lt; ValueType &gt;::Dictionary::lower_bound_fast()</a>, <a class="el" href="stochasticencoder_8h_source.html#l00227">dyscostman::StochasticEncoder&lt; ValueType &gt;::Dictionary::lower_bound_slow()</a>, <a class="el" href="uvector_8h_source.html#l00797">ao::uvector&lt; value_t &gt;::push_back()</a>, <a class="el" href="uvector_8h_source.html#l01125">ao::uvector&lt; value_t &gt;::push_back_range()</a>, <a class="el" href="uvector_8h_source.html#l00832">ao::uvector&lt; value_t &gt;::push_back_uninitialized()</a>, <a class="el" href="uvector_8h_source.html#l00368">ao::uvector&lt; value_t &gt;::reserve()</a>, <a class="el" href="uvector_8h_source.html#l00336">ao::uvector&lt; value_t &gt;::resize()</a>, <a class="el" href="uvector_8h_source.html#l00388">ao::uvector&lt; value_t &gt;::shrink_to_fit()</a>, and <a class="el" href="stochasticencoder_8h_source.html#l00250">dyscostman::StochasticEncoder&lt; ValueType &gt;::Dictionary::size()</a>.</p>

</div>
</div>
<a class="anchor" id="adda06e94cc27f64265d786795969f922"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the contents of this uvector with the given uvector. </p>
<p>Iterators to both vectors will remain valid and will point into to the swapped container afterwards. This function will never reallocate space.</p>
<p>The allocator will be swapped when the <code>propagate_on_container_swap</code> of the respective <code>allocator_trait</code> is <code>true_type</code>. Its behaviour is undefined when the allocators do not compare equal and <code>propagate_on_container_swap</code> is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Other uvector whose contents it to be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00695">695</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="uvector_8h_source.html#l00695">ao::uvector&lt; value_t &gt;::swap()</a>, and <a class="el" href="uvector_8h_source.html#l01234">ao::swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f037cc0e7c4f8799601b620a3d9e46c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::true_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>implementation of swap with propagate_on_container_swap </p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l01079">1079</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a53e9b31e539c21a5bd4fbfab4ac68af2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classao_1_1uvector.html">uvector</a>&lt; Tp, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::false_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>implementation of swap without propagate_on_container_swap </p>
<p>We have two choices here:</p>
<ul>
<li>Do not swap the allocators. For stateful allocators, we would need to reallocate memory, and iterators would not be valid UNLESS they were stored as indices. However, containers with stateful allocators are not allowed to be swapped unless the allocators are equal, in which case swapping is not necessary.</li>
<li>Swap the allocators. This would not reallocate memory and iterators remain valid, but the trait ignores propagate_on_container_swap.</li>
</ul>
<p>The standard says: "Allocator replacement is performed by copy assignment, move assignment, or swapping of the allocator only if allocator_traits&lt;allocatortype&gt;:: propagate_on_container_copy_assignment::value, allocator_traits&lt;allocatortype&gt;::propagate_on_container_move_assignment::value, or allocator_traits&lt;allocatortype&gt;::propagate_on_container_swap::value is true within the implementation of the corresponding container operation. The behavior of a call to a containers swap function is undefined unless the objects being swapped have allocators that compare equal or allocator_traits&lt;allocatortype&gt;::propagate_on_container_swap::value is true."</p>

<p>Definition at line <a class="el" href="uvector_8h_source.html#l01088">1088</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae628f800fdf44b2f1b2137fc187c7fbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a56141f76e1742adacd4a22b0cfbce59e">pointer</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::_begin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00111">111</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="uvector_8h_source.html#l00467">ao::uvector&lt; value_t &gt;::assign()</a>, <a class="el" href="uvector_8h_source.html#l01007">ao::uvector&lt; value_t &gt;::assign_copy_from()</a>, <a class="el" href="uvector_8h_source.html#l00894">ao::uvector&lt; value_t &gt;::assign_from_range()</a>, <a class="el" href="uvector_8h_source.html#l01042">ao::uvector&lt; value_t &gt;::assign_move_from()</a>, <a class="el" href="uvector_8h_source.html#l00417">ao::uvector&lt; value_t &gt;::at()</a>, <a class="el" href="uvector_8h_source.html#l00263">ao::uvector&lt; value_t &gt;::begin()</a>, <a class="el" href="uvector_8h_source.html#l00353">ao::uvector&lt; value_t &gt;::capacity()</a>, <a class="el" href="uvector_8h_source.html#l00287">ao::uvector&lt; value_t &gt;::cbegin()</a>, <a class="el" href="uvector_8h_source.html#l00701">ao::uvector&lt; value_t &gt;::clear()</a>, <a class="el" href="uvector_8h_source.html#l00862">ao::uvector&lt; value_t &gt;::construct_from_range()</a>, <a class="el" href="uvector_8h_source.html#l00445">ao::uvector&lt; value_t &gt;::data()</a>, <a class="el" href="uvector_8h_source.html#l00844">ao::uvector&lt; value_t &gt;::deallocate()</a>, <a class="el" href="uvector_8h_source.html#l00715">ao::uvector&lt; value_t &gt;::emplace()</a>, <a class="el" href="uvector_8h_source.html#l00357">ao::uvector&lt; value_t &gt;::empty()</a>, <a class="el" href="uvector_8h_source.html#l00985">ao::uvector&lt; value_t &gt;::enlarge()</a>, <a class="el" href="uvector_8h_source.html#l00995">ao::uvector&lt; value_t &gt;::enlarge_for_insert()</a>, <a class="el" href="uvector_8h_source.html#l00433">ao::uvector&lt; value_t &gt;::front()</a>, <a class="el" href="uvector_8h_source.html#l00544">ao::uvector&lt; value_t &gt;::insert()</a>, <a class="el" href="uvector_8h_source.html#l00935">ao::uvector&lt; value_t &gt;::insert_from_range()</a>, <a class="el" href="uvector_8h_source.html#l00762">ao::uvector&lt; value_t &gt;::insert_uninitialized()</a>, <a class="el" href="uvector_8h_source.html#l00409">ao::uvector&lt; value_t &gt;::operator[]()</a>, <a class="el" href="uvector_8h_source.html#l00368">ao::uvector&lt; value_t &gt;::reserve()</a>, <a class="el" href="uvector_8h_source.html#l00313">ao::uvector&lt; value_t &gt;::resize()</a>, <a class="el" href="uvector_8h_source.html#l00388">ao::uvector&lt; value_t &gt;::shrink_to_fit()</a>, <a class="el" href="uvector_8h_source.html#l00299">ao::uvector&lt; value_t &gt;::size()</a>, <a class="el" href="uvector_8h_source.html#l01079">ao::uvector&lt; value_t &gt;::swap()</a>, and <a class="el" href="uvector_8h_source.html#l00141">ao::uvector&lt; value_t &gt;::uvector()</a>.</p>

</div>
</div>
<a class="anchor" id="ac7452cde30f09bdb3173471bac870258"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a56141f76e1742adacd4a22b0cfbce59e">pointer</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::_end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00111">111</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="uvector_8h_source.html#l00467">ao::uvector&lt; value_t &gt;::assign()</a>, <a class="el" href="uvector_8h_source.html#l01007">ao::uvector&lt; value_t &gt;::assign_copy_from()</a>, <a class="el" href="uvector_8h_source.html#l00894">ao::uvector&lt; value_t &gt;::assign_from_range()</a>, <a class="el" href="uvector_8h_source.html#l01042">ao::uvector&lt; value_t &gt;::assign_move_from()</a>, <a class="el" href="uvector_8h_source.html#l00439">ao::uvector&lt; value_t &gt;::back()</a>, <a class="el" href="uvector_8h_source.html#l00290">ao::uvector&lt; value_t &gt;::cend()</a>, <a class="el" href="uvector_8h_source.html#l00701">ao::uvector&lt; value_t &gt;::clear()</a>, <a class="el" href="uvector_8h_source.html#l00862">ao::uvector&lt; value_t &gt;::construct_from_range()</a>, <a class="el" href="uvector_8h_source.html#l00715">ao::uvector&lt; value_t &gt;::emplace()</a>, <a class="el" href="uvector_8h_source.html#l00736">ao::uvector&lt; value_t &gt;::emplace_back()</a>, <a class="el" href="uvector_8h_source.html#l00357">ao::uvector&lt; value_t &gt;::empty()</a>, <a class="el" href="uvector_8h_source.html#l00269">ao::uvector&lt; value_t &gt;::end()</a>, <a class="el" href="uvector_8h_source.html#l00985">ao::uvector&lt; value_t &gt;::enlarge()</a>, <a class="el" href="uvector_8h_source.html#l00995">ao::uvector&lt; value_t &gt;::enlarge_for_insert()</a>, <a class="el" href="uvector_8h_source.html#l00663">ao::uvector&lt; value_t &gt;::erase()</a>, <a class="el" href="uvector_8h_source.html#l00544">ao::uvector&lt; value_t &gt;::insert()</a>, <a class="el" href="uvector_8h_source.html#l00935">ao::uvector&lt; value_t &gt;::insert_from_range()</a>, <a class="el" href="uvector_8h_source.html#l00762">ao::uvector&lt; value_t &gt;::insert_uninitialized()</a>, <a class="el" href="uvector_8h_source.html#l00531">ao::uvector&lt; value_t &gt;::pop_back()</a>, <a class="el" href="uvector_8h_source.html#l00507">ao::uvector&lt; value_t &gt;::push_back()</a>, <a class="el" href="uvector_8h_source.html#l01125">ao::uvector&lt; value_t &gt;::push_back_range()</a>, <a class="el" href="uvector_8h_source.html#l00368">ao::uvector&lt; value_t &gt;::reserve()</a>, <a class="el" href="uvector_8h_source.html#l00313">ao::uvector&lt; value_t &gt;::resize()</a>, <a class="el" href="uvector_8h_source.html#l00388">ao::uvector&lt; value_t &gt;::shrink_to_fit()</a>, <a class="el" href="uvector_8h_source.html#l00299">ao::uvector&lt; value_t &gt;::size()</a>, <a class="el" href="uvector_8h_source.html#l01079">ao::uvector&lt; value_t &gt;::swap()</a>, and <a class="el" href="uvector_8h_source.html#l00167">ao::uvector&lt; value_t &gt;::uvector()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b98e3dde99abe591909a785851506fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp, typename Alloc = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classao_1_1uvector.html#a56141f76e1742adacd4a22b0cfbce59e">pointer</a> <a class="el" href="classao_1_1uvector.html">ao::uvector</a>&lt; Tp, Alloc &gt;::_endOfStorage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uvector_8h_source.html#l00111">111</a> of file <a class="el" href="uvector_8h_source.html">uvector.h</a>.</p>

<p>Referenced by <a class="el" href="uvector_8h_source.html#l00467">ao::uvector&lt; value_t &gt;::assign()</a>, <a class="el" href="uvector_8h_source.html#l01007">ao::uvector&lt; value_t &gt;::assign_copy_from()</a>, <a class="el" href="uvector_8h_source.html#l00894">ao::uvector&lt; value_t &gt;::assign_from_range()</a>, <a class="el" href="uvector_8h_source.html#l01042">ao::uvector&lt; value_t &gt;::assign_move_from()</a>, <a class="el" href="uvector_8h_source.html#l00353">ao::uvector&lt; value_t &gt;::capacity()</a>, <a class="el" href="uvector_8h_source.html#l00862">ao::uvector&lt; value_t &gt;::construct_from_range()</a>, <a class="el" href="uvector_8h_source.html#l00715">ao::uvector&lt; value_t &gt;::emplace()</a>, <a class="el" href="uvector_8h_source.html#l00736">ao::uvector&lt; value_t &gt;::emplace_back()</a>, <a class="el" href="uvector_8h_source.html#l00985">ao::uvector&lt; value_t &gt;::enlarge()</a>, <a class="el" href="uvector_8h_source.html#l00995">ao::uvector&lt; value_t &gt;::enlarge_for_insert()</a>, <a class="el" href="uvector_8h_source.html#l00544">ao::uvector&lt; value_t &gt;::insert()</a>, <a class="el" href="uvector_8h_source.html#l00507">ao::uvector&lt; value_t &gt;::push_back()</a>, <a class="el" href="uvector_8h_source.html#l00368">ao::uvector&lt; value_t &gt;::reserve()</a>, <a class="el" href="uvector_8h_source.html#l00313">ao::uvector&lt; value_t &gt;::resize()</a>, <a class="el" href="uvector_8h_source.html#l00388">ao::uvector&lt; value_t &gt;::shrink_to_fit()</a>, and <a class="el" href="uvector_8h_source.html#l01079">ao::uvector&lt; value_t &gt;::swap()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tables/Dysco/<a class="el" href="uvector_8h_source.html">uvector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
