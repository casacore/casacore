<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>casacore: casacore::Array&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">casacore
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecasacore.html">casacore</a></li><li class="navelem"><a class="el" href="classcasacore_1_1Array.html">Array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcasacore_1_1Array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">casacore::Array&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Arrays__module.html">Arrays_module</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>template &lt;class T, class U&gt; class vector;  
 <a href="classcasacore_1_1Array.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Array_8h_source.html">Array.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for casacore::Array&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcasacore_1_1Array.png" usemap="#casacore::Array&lt; T &gt;_map" alt=""/>
  <map id="casacore::Array&lt; T &gt;_map" name="casacore::Array&lt; T &gt;_map">
<area href="classcasacore_1_1ArrayBase.html" title="Non-templated base class for templated Array class. " alt="casacore::ArrayBase" shape="rect" coords="0,0,826,24"/>
<area href="classcasacore_1_1Cube.html" title="A 3-D Specialization of the Array class. " alt="casacore::Cube&lt; T &gt;" shape="rect" coords="836,112,1662,136"/>
<area href="classcasacore_1_1Matrix.html" title="A 2-D Specialization of the Array class. " alt="casacore::Matrix&lt; T &gt;" shape="rect" coords="836,168,1662,192"/>
<area href="classcasacore_1_1Vector.html" title="A 1-D Specialization of the Array class. " alt="casacore::Vector&lt; T &gt;" shape="rect" coords="836,224,1662,248"/>
<area href="classcasacore_1_1Cube.html" alt="casacore::Cube&lt; casacore::RigidVector&lt; Double, 2 &gt; &gt;" shape="rect" coords="836,280,1662,304"/>
<area href="classcasacore_1_1Matrix.html" alt="casacore::Matrix&lt; casacore::GaussianBeam &gt;" shape="rect" coords="836,336,1662,360"/>
<area href="classcasacore_1_1Matrix.html" alt="casacore::Matrix&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;" shape="rect" coords="836,392,1662,416"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; ArgType &gt;" shape="rect" coords="836,448,1662,472"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; AutoDiff&lt; T &gt; &gt;" shape="rect" coords="836,504,1662,528"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; AutoDiffA&lt; T &gt; &gt;" shape="rect" coords="836,560,1662,584"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::AutoDiff&lt; Double &gt; &gt;" shape="rect" coords="836,616,1662,640"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::MDirection &gt;" shape="rect" coords="836,672,1662,696"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::MeasComet * &gt;" shape="rect" coords="836,728,1662,752"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::MFrequency &gt;" shape="rect" coords="836,784,1662,808"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::MPosition &gt;" shape="rect" coords="836,840,1662,864"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::Quantum &gt;" shape="rect" coords="836,896,1662,920"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::Quantum&lt; Double &gt; &gt;" shape="rect" coords="836,952,1662,976"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::RORecordFieldPtr&lt; Double &gt; &gt;" shape="rect" coords="836,1008,1662,1032"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::Slicer * &gt;" shape="rect" coords="836,1064,1662,1088"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;" shape="rect" coords="836,1120,1662,1144"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::Unit &gt;" shape="rect" coords="836,1176,1662,1200"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::Vector&lt; Range &gt; &gt;" shape="rect" coords="836,1232,1662,1256"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;::base &gt; &gt;" shape="rect" coords="836,1288,1662,1312"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;::base &gt; &gt;" shape="rect" coords="836,1344,1662,1368"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;::base &gt; &gt;" shape="rect" coords="836,1400,1662,1424"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; Domain &gt;" shape="rect" coords="836,1456,1662,1480"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; double &gt;" shape="rect" coords="836,1512,1662,1536"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; Type &gt;" shape="rect" coords="836,1568,1662,1592"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::ArgType &gt;" shape="rect" coords="836,1624,1662,1648"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;" shape="rect" coords="836,1680,1662,1704"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::DiffType &gt;" shape="rect" coords="836,1736,1662,1760"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::ArgType &gt;" shape="rect" coords="836,1792,1662,1816"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;" shape="rect" coords="836,1848,1662,1872"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::DiffType &gt;" shape="rect" coords="836,1904,1662,1928"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::ArgType &gt;" shape="rect" coords="836,1960,1662,1984"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;" shape="rect" coords="836,2016,1662,2040"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::DiffType &gt;" shape="rect" coords="836,2072,1662,2096"/>
<area href="classcasacore_1_1Vector.html" alt="casacore::Vector&lt; uInt &gt;" shape="rect" coords="836,2128,1662,2152"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array_1_1BaseIteratorSTL.html">BaseIteratorSTL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the function <a class="el" href="classcasacore_1_1Array.html#a29c4632d120dfa99fd2c3549593feb67" title="Get the begin iterator object for any array. ">begin()</a> and <a class="el" href="classcasacore_1_1Array.html#ad40f8c12830ed55a35c7d2e7a5fc24e5">end()</a> for a detailed description of the STL iterator capability.  <a href="classcasacore_1_1Array_1_1BaseIteratorSTL.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array_1_1ConstIteratorSTL.html">ConstIteratorSTL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array_1_1IteratorSTL.html">IteratorSTL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeae23521ec2f6e539be36e048b99f28f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aeae23521ec2f6e539be36e048b99f28f">Array</a> ()</td></tr>
<tr class="memdesc:aeae23521ec2f6e539be36e048b99f28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result has dimensionality of zero, and nelements is zero.  <a href="#aeae23521ec2f6e539be36e048b99f28f">More...</a><br/></td></tr>
<tr class="separator:aeae23521ec2f6e539be36e048b99f28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad388cd5a3e1befde8f63668eadf0e4e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ad388cd5a3e1befde8f63668eadf0e4e0">Array</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>)</td></tr>
<tr class="memdesc:ad388cd5a3e1befde8f63668eadf0e4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array of the given shape, i.e.  <a href="#ad388cd5a3e1befde8f63668eadf0e4e0">More...</a><br/></td></tr>
<tr class="separator:ad388cd5a3e1befde8f63668eadf0e4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bd21afe5a7cefde26d5dfd2afb43d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a91bd21afe5a7cefde26d5dfd2afb43d1">Array</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, <a class="el" href="classcasacore_1_1ArrayInitPolicy.html">ArrayInitPolicy</a> initPolicy)</td></tr>
<tr class="memdesc:a91bd21afe5a7cefde26d5dfd2afb43d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array of the given shape, i.e.  <a href="#a91bd21afe5a7cefde26d5dfd2afb43d1">More...</a><br/></td></tr>
<tr class="separator:a91bd21afe5a7cefde26d5dfd2afb43d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466c3cc776cf7e71d3de7907857d00d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a466c3cc776cf7e71d3de7907857d00d3">Array</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, const T &amp;initialValue)</td></tr>
<tr class="memdesc:a466c3cc776cf7e71d3de7907857d00d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array of the given shape and initialize it with the initial value.  <a href="#a466c3cc776cf7e71d3de7907857d00d3">More...</a><br/></td></tr>
<tr class="separator:a466c3cc776cf7e71d3de7907857d00d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89e9bbc0c48f2140a44848c919d50e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ab89e9bbc0c48f2140a44848c919d50e5">Array</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:ab89e9bbc0c48f2140a44848c919d50e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">After construction, this and other reference the same storage.  <a href="#ab89e9bbc0c48f2140a44848c919d50e5">More...</a><br/></td></tr>
<tr class="separator:ab89e9bbc0c48f2140a44848c919d50e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3fbd04b2dcb3f3db853d7b0160e3e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a1a3fbd04b2dcb3f3db853d7b0160e3e8">Array</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, T *storage, <a class="el" href="group__Arrays__module.html#ga44401e80192e152e570fc445a95f534b">StorageInitPolicy</a> policy=<a class="el" href="group__Arrays__module.html#gga44401e80192e152e570fc445a95f534ba46b2e4579af5e1f449bb55cfd9f1c9bc">COPY</a>)</td></tr>
<tr class="memdesc:a1a3fbd04b2dcb3f3db853d7b0160e3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> of a given shape from a pointer.  <a href="#a1a3fbd04b2dcb3f3db853d7b0160e3e8">More...</a><br/></td></tr>
<tr class="separator:a1a3fbd04b2dcb3f3db853d7b0160e3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad772865a89355fef5c1b1a6c54052271"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ad772865a89355fef5c1b1a6c54052271">Array</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, T *storage, <a class="el" href="group__Arrays__module.html#ga44401e80192e152e570fc445a95f534b">StorageInitPolicy</a> policy, <a class="el" href="classcasacore_1_1AbstractAllocator.html">AbstractAllocator</a>&lt; T &gt; const &amp;allocator)</td></tr>
<tr class="memdesc:ad772865a89355fef5c1b1a6c54052271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> of a given shape from a pointer.  <a href="#ad772865a89355fef5c1b1a6c54052271">More...</a><br/></td></tr>
<tr class="separator:ad772865a89355fef5c1b1a6c54052271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fbe516a9c57a7883d929717e29de07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a18fbe516a9c57a7883d929717e29de07">Array</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, const T *storage)</td></tr>
<tr class="memdesc:a18fbe516a9c57a7883d929717e29de07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> of a given shape from a pointer.  <a href="#a18fbe516a9c57a7883d929717e29de07">More...</a><br/></td></tr>
<tr class="separator:a18fbe516a9c57a7883d929717e29de07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b39f39dfe91c8c17970a3552716c6f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a76b39f39dfe91c8c17970a3552716c6f">~Array</a> ()</td></tr>
<tr class="memdesc:a76b39f39dfe91c8c17970a3552716c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees up storage only if this array was the last reference to it.  <a href="#a76b39f39dfe91c8c17970a3552716c6f">More...</a><br/></td></tr>
<tr class="separator:a76b39f39dfe91c8c17970a3552716c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113a6ddf2cffe1cd2c5c053fe6898b60"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcasacore_1_1CountedPtr.html">CountedPtr</a>&lt; <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a113a6ddf2cffe1cd2c5c053fe6898b60">makeArray</a> () const </td></tr>
<tr class="memdesc:a113a6ddf2cffe1cd2c5c053fe6898b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an empty array of the same template type.  <a href="#a113a6ddf2cffe1cd2c5c053fe6898b60">More...</a><br/></td></tr>
<tr class="separator:a113a6ddf2cffe1cd2c5c053fe6898b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8a40e02af1ef593ee2a0a2cc902d4c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a0b8a40e02af1ef593ee2a0a2cc902d4c">assign</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a0b8a40e02af1ef593ee2a0a2cc902d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the other array to this array.  <a href="#a0b8a40e02af1ef593ee2a0a2cc902d4c">More...</a><br/></td></tr>
<tr class="separator:a0b8a40e02af1ef593ee2a0a2cc902d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1f40ef57bf36fed3c1324058e480fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a7d1f40ef57bf36fed3c1324058e480fc">assignBase</a> (const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;other, <a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> checkType=<a class="el" href="namespacecasacore.html#ad5c850f9e177173e0f7d0ad57091501d">True</a>)</td></tr>
<tr class="memdesc:a7d1f40ef57bf36fed3c1324058e480fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the source array to this array.  <a href="#a7d1f40ef57bf36fed3c1324058e480fc">More...</a><br/></td></tr>
<tr class="separator:a7d1f40ef57bf36fed3c1324058e480fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c9856db5a41305e6a0e13cd8a9e5b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ad9c9856db5a41305e6a0e13cd8a9e5b0">set</a> (const T &amp;<a class="el" href="namespacecasacore.html#ac188f9709620e307c2f721d6bc43607f">value</a>)</td></tr>
<tr class="memdesc:ad9c9856db5a41305e6a0e13cd8a9e5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set every element of the array to "value." Also could use the assignment operator which assigns an array from a scalar.  <a href="#ad9c9856db5a41305e6a0e13cd8a9e5b0">More...</a><br/></td></tr>
<tr class="separator:ad9c9856db5a41305e6a0e13cd8a9e5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b91653a1fc412334e8d25ba1c02b53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ad3b91653a1fc412334e8d25ba1c02b53">apply</a> (T(*function)(T))</td></tr>
<tr class="memdesc:ad3b91653a1fc412334e8d25ba1c02b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the function to every element of the array.  <a href="#ad3b91653a1fc412334e8d25ba1c02b53">More...</a><br/></td></tr>
<tr class="separator:ad3b91653a1fc412334e8d25ba1c02b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9ffbd7aee081b184714d2e1a4bcffb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a4e9ffbd7aee081b184714d2e1a4bcffb">apply</a> (T(*function)(const T &amp;))</td></tr>
<tr class="memdesc:a4e9ffbd7aee081b184714d2e1a4bcffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version takes a function which takes a const T reference and returns a T.  <a href="#a4e9ffbd7aee081b184714d2e1a4bcffb">More...</a><br/></td></tr>
<tr class="separator:a4e9ffbd7aee081b184714d2e1a4bcffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84301685e214874f2da0b1399a01e46a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a84301685e214874f2da0b1399a01e46a">apply</a> (const <a class="el" href="classcasacore_1_1Functional.html">Functional</a>&lt; T, T &gt; &amp;function)</td></tr>
<tr class="memdesc:a84301685e214874f2da0b1399a01e46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version applies a functional.  <a href="#a84301685e214874f2da0b1399a01e46a">More...</a><br/></td></tr>
<tr class="separator:a84301685e214874f2da0b1399a01e46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfb6bd1f6e0a70dc1c2909739e09d07"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#adcfb6bd1f6e0a70dc1c2909739e09d07">reference</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:adcfb6bd1f6e0a70dc1c2909739e09d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">After invocation, this array and other reference the same storage.  <a href="#adcfb6bd1f6e0a70dc1c2909739e09d07">More...</a><br/></td></tr>
<tr class="separator:adcfb6bd1f6e0a70dc1c2909739e09d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef46ed4a47d84d5207f112c0acfe2b42"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aef46ed4a47d84d5207f112c0acfe2b42">operator=</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:aef46ed4a47d84d5207f112c0acfe2b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the values in other to this.  <a href="#aef46ed4a47d84d5207f112c0acfe2b42">More...</a><br/></td></tr>
<tr class="separator:aef46ed4a47d84d5207f112c0acfe2b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa79567b18d4d7635bbbd700cf57ebbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#afa79567b18d4d7635bbbd700cf57ebbb">operator=</a> (const T &amp;<a class="el" href="namespacecasacore.html#ac188f9709620e307c2f721d6bc43607f">value</a>)</td></tr>
<tr class="memdesc:afa79567b18d4d7635bbbd700cf57ebbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set every element of this array to "value".  <a href="#afa79567b18d4d7635bbbd700cf57ebbb">More...</a><br/></td></tr>
<tr class="separator:afa79567b18d4d7635bbbd700cf57ebbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833f0646ac4bfdb1f992c2c582bf5b92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a833f0646ac4bfdb1f992c2c582bf5b92">operator=</a> (const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T &gt; &amp;<a class="el" href="namespacecasacore.html#ac570e761f6a12e7166c7bbd30f465ff3">marray</a>)</td></tr>
<tr class="memdesc:a833f0646ac4bfdb1f992c2c582bf5b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy to this those values in marray whose corresponding elements in marray's mask are True.  <a href="#a833f0646ac4bfdb1f992c2c582bf5b92">More...</a><br/></td></tr>
<tr class="separator:a833f0646ac4bfdb1f992c2c582bf5b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903c81abde2a3fa8a6eb175d25d7fa13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a903c81abde2a3fa8a6eb175d25d7fa13">copy</a> (<a class="el" href="classcasacore_1_1ArrayInitPolicy.html">ArrayInitPolicy</a> policy=<a class="el" href="structcasacore_1_1ArrayInitPolicies.html#a054537161fe4b86d81f1a11aba453cc8">ArrayInitPolicies::NO_INIT</a>) const </td></tr>
<tr class="memdesc:a903c81abde2a3fa8a6eb175d25d7fa13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This makes a copy of the array and returns it.  <a href="#a903c81abde2a3fa8a6eb175d25d7fa13">More...</a><br/></td></tr>
<tr class="separator:a903c81abde2a3fa8a6eb175d25d7fa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fb387d33b6a9fe6e33e5fde2dd5055"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ad3fb387d33b6a9fe6e33e5fde2dd5055">copyMatchingPart</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;from)</td></tr>
<tr class="memdesc:ad3fb387d33b6a9fe6e33e5fde2dd5055"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies the matching part of from array to this array.  <a href="#ad3fb387d33b6a9fe6e33e5fde2dd5055">More...</a><br/></td></tr>
<tr class="separator:ad3fb387d33b6a9fe6e33e5fde2dd5055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e7341087c1aa29f72fb847ddca2884"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a31e7341087c1aa29f72fb847ddca2884">unique</a> ()</td></tr>
<tr class="memdesc:a31e7341087c1aa29f72fb847ddca2884"><td class="mdescLeft">&#160;</td><td class="mdescRight">This ensures that this array does not reference any other storage.  <a href="#a31e7341087c1aa29f72fb847ddca2884">More...</a><br/></td></tr>
<tr class="separator:a31e7341087c1aa29f72fb847ddca2884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f4def83148d8921e637020c8f98f46"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a27f4def83148d8921e637020c8f98f46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a27f4def83148d8921e637020c8f98f46">tovector</a> (vector&lt; T, U &gt; &amp;out) const </td></tr>
<tr class="memdesc:a27f4def83148d8921e637020c8f98f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an STL vector from an <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a>.  <a href="#a27f4def83148d8921e637020c8f98f46">More...</a><br/></td></tr>
<tr class="separator:a27f4def83148d8921e637020c8f98f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5577d38a7e03a3c7cee76153c04b32"><td class="memItemLeft" align="right" valign="top">vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#afb5577d38a7e03a3c7cee76153c04b32">tovector</a> () const </td></tr>
<tr class="separator:afb5577d38a7e03a3c7cee76153c04b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0dc902bbca281026448bffe4393d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aeb0dc902bbca281026448bffe4393d54">reform</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>) const </td></tr>
<tr class="memdesc:aeb0dc902bbca281026448bffe4393d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is occasionally useful to have an array which access the same storage appear to have a different shape.  <a href="#aeb0dc902bbca281026448bffe4393d54">More...</a><br/></td></tr>
<tr class="separator:aeb0dc902bbca281026448bffe4393d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7191ff9dce3e7592c5302420e68db7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a8a7191ff9dce3e7592c5302420e68db7">reformOrResize</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;newShape, <a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> resizePercentage=0, <a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> resizeIfNeeded=<a class="el" href="namespacecasacore.html#ad5c850f9e177173e0f7d0ad57091501d">True</a>)</td></tr>
<tr class="memdesc:a8a7191ff9dce3e7592c5302420e68db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Having an array that can be reused without requiring reallocation can be useful for large arrays.  <a href="#a8a7191ff9dce3e7592c5302420e68db7">More...</a><br/></td></tr>
<tr class="separator:a8a7191ff9dce3e7592c5302420e68db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4132a776f32afde01796adeacb3854e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a4132a776f32afde01796adeacb3854e5">adjustLastAxis</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;newShape, <a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> resizePercentage=0, bool resizeIfNeeded=<a class="el" href="namespacecasacore.html#ad5c850f9e177173e0f7d0ad57091501d">True</a>)</td></tr>
<tr class="memdesc:a4132a776f32afde01796adeacb3854e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this method to extend or reduce the last dimension of an array.  <a href="#a4132a776f32afde01796adeacb3854e5">More...</a><br/></td></tr>
<tr class="separator:a4132a776f32afde01796adeacb3854e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a14e5d098fa3067b7161e757a01873"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#af7a14e5d098fa3067b7161e757a01873">capacity</a> () const </td></tr>
<tr class="memdesc:af7a14e5d098fa3067b7161e757a01873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements allocated.  <a href="#af7a14e5d098fa3067b7161e757a01873">More...</a><br/></td></tr>
<tr class="separator:af7a14e5d098fa3067b7161e757a01873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2052b6c9055542b4658a7ee566fb7df3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a2052b6c9055542b4658a7ee566fb7df3">nonDegenerate</a> (<a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> startingAxis=0, <a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> throwIfError=<a class="el" href="namespacecasacore.html#ad5c850f9e177173e0f7d0ad57091501d">True</a>) const </td></tr>
<tr class="memdesc:a2052b6c9055542b4658a7ee566fb7df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">These member functions remove degenerate (ie.  <a href="#a2052b6c9055542b4658a7ee566fb7df3">More...</a><br/></td></tr>
<tr class="separator:a2052b6c9055542b4658a7ee566fb7df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40080fab3132561a599c7f1e0376a820"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a40080fab3132561a599c7f1e0376a820">nonDegenerate</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;ignoreAxes) const </td></tr>
<tr class="separator:a40080fab3132561a599c7f1e0376a820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f6e893c0ecbd8e62fc2f496a164146"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a29f6e893c0ecbd8e62fc2f496a164146">nonDegenerate</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;other, <a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> startingAxis=0, <a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> throwIfError=<a class="el" href="namespacecasacore.html#ad5c850f9e177173e0f7d0ad57091501d">True</a>)</td></tr>
<tr class="separator:a29f6e893c0ecbd8e62fc2f496a164146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b27b4cc852373ab6f6fc2325815d67b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a7b27b4cc852373ab6f6fc2325815d67b">nonDegenerate</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;other, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;ignoreAxes)</td></tr>
<tr class="separator:a7b27b4cc852373ab6f6fc2325815d67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f043e07c0784ab1119f1eda6dc69bd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a6f043e07c0784ab1119f1eda6dc69bd8">removeDegenerate</a> (<a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> startingAxis=0, <a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> throwIfError=<a class="el" href="namespacecasacore.html#ad5c850f9e177173e0f7d0ad57091501d">True</a>)</td></tr>
<tr class="memdesc:a6f043e07c0784ab1119f1eda6dc69bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove degenerate axes from this <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> object.  <a href="#a6f043e07c0784ab1119f1eda6dc69bd8">More...</a><br/></td></tr>
<tr class="separator:a6f043e07c0784ab1119f1eda6dc69bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ccae2df54a57485d5bdb8505be8d3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a95ccae2df54a57485d5bdb8505be8d3a">removeDegenerate</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;ignoreAxes)</td></tr>
<tr class="separator:a95ccae2df54a57485d5bdb8505be8d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6babfe2cc4f73266221f89dcb44bee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#adc6babfe2cc4f73266221f89dcb44bee">addDegenerate</a> (<a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> numAxes) const </td></tr>
<tr class="memdesc:adc6babfe2cc4f73266221f89dcb44bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function returns an <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> reference with the specified number of extra axes, all of length one, appended to the end of the <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a>.  <a href="#adc6babfe2cc4f73266221f89dcb44bee">More...</a><br/></td></tr>
<tr class="separator:adc6babfe2cc4f73266221f89dcb44bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae63ef4e985df2824007d508d533b9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a3ae63ef4e985df2824007d508d533b9c">addDegenerate</a> (<a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> numAxes)</td></tr>
<tr class="separator:a3ae63ef4e985df2824007d508d533b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2553c2d285cd9ad504bb9fefd5398136"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a2553c2d285cd9ad504bb9fefd5398136">resize</a> ()</td></tr>
<tr class="memdesc:a2553c2d285cd9ad504bb9fefd5398136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make this array a different shape.  <a href="#a2553c2d285cd9ad504bb9fefd5398136">More...</a><br/></td></tr>
<tr class="separator:a2553c2d285cd9ad504bb9fefd5398136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9c2a6de6dee1f2915b46777d77fb23"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a2f9c2a6de6dee1f2915b46777d77fb23">resize</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;newShape, <a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> copyValues=<a class="el" href="namespacecasacore.html#a11ef6530f2dc946f54d220fe416bfd41">False</a>)</td></tr>
<tr class="memdesc:a2f9c2a6de6dee1f2915b46777d77fb23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the array and optionally copy the values.  <a href="#a2f9c2a6de6dee1f2915b46777d77fb23">More...</a><br/></td></tr>
<tr class="separator:a2f9c2a6de6dee1f2915b46777d77fb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b6337a49142f6118661c515cbaedee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a47b6337a49142f6118661c515cbaedee">resize</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;newShape, <a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> copyValues, <a class="el" href="classcasacore_1_1ArrayInitPolicy.html">ArrayInitPolicy</a> policy)</td></tr>
<tr class="memdesc:a47b6337a49142f6118661c515cbaedee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the array and optionally copy the values.  <a href="#a47b6337a49142f6118661c515cbaedee">More...</a><br/></td></tr>
<tr class="separator:a47b6337a49142f6118661c515cbaedee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc6100c12c9ef15752d40d5b14663aa"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a1dc6100c12c9ef15752d40d5b14663aa">operator()</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;)</td></tr>
<tr class="memdesc:a1dc6100c12c9ef15752d40d5b14663aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a single element of the array.  <a href="#a1dc6100c12c9ef15752d40d5b14663aa">More...</a><br/></td></tr>
<tr class="separator:a1dc6100c12c9ef15752d40d5b14663aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2187c435a64c63a7b9caa92889d1ad"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a1d2187c435a64c63a7b9caa92889d1ad">operator()</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;) const </td></tr>
<tr class="separator:a1d2187c435a64c63a7b9caa92889d1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b66a755ee54dacaa33f2eb1e3bf520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ad4b66a755ee54dacaa33f2eb1e3bf520">operator()</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;start, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1Array.html#ad40f8c12830ed55a35c7d2e7a5fc24e5">end</a>)</td></tr>
<tr class="memdesc:ad4b66a755ee54dacaa33f2eb1e3bf520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to an array section extending from start to end (inclusive).  <a href="#ad4b66a755ee54dacaa33f2eb1e3bf520">More...</a><br/></td></tr>
<tr class="separator:ad4b66a755ee54dacaa33f2eb1e3bf520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580418b8bb7187c932c3fa5343cda0aa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a580418b8bb7187c932c3fa5343cda0aa">operator()</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;start, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1Array.html#ad40f8c12830ed55a35c7d2e7a5fc24e5">end</a>) const </td></tr>
<tr class="separator:a580418b8bb7187c932c3fa5343cda0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1344333c735857a91213ca9f97a3b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a2b1344333c735857a91213ca9f97a3b0">operator()</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;start, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1Array.html#ad40f8c12830ed55a35c7d2e7a5fc24e5">end</a>, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;inc)</td></tr>
<tr class="memdesc:a2b1344333c735857a91213ca9f97a3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Along the ith axis, every inc[i]'th element is chosen.  <a href="#a2b1344333c735857a91213ca9f97a3b0">More...</a><br/></td></tr>
<tr class="separator:a2b1344333c735857a91213ca9f97a3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e2b72d291af446829fe8c949d0af1a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a80e2b72d291af446829fe8c949d0af1a">operator()</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;start, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1Array.html#ad40f8c12830ed55a35c7d2e7a5fc24e5">end</a>, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;inc) const </td></tr>
<tr class="separator:a80e2b72d291af446829fe8c949d0af1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af825a7cefd9142d6ad86e0ea798494d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#af825a7cefd9142d6ad86e0ea798494d0">operator()</a> (const <a class="el" href="classcasacore_1_1Slicer.html">Slicer</a> &amp;)</td></tr>
<tr class="memdesc:af825a7cefd9142d6ad86e0ea798494d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to an array section using a <a class="el" href="classcasacore_1_1Slicer.html" title="Specify which elements to extract from an n-dimensional array. ">Slicer</a>.  <a href="#af825a7cefd9142d6ad86e0ea798494d0">More...</a><br/></td></tr>
<tr class="separator:af825a7cefd9142d6ad86e0ea798494d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3ea7c6f8061cf7ce10464b7780787a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a0c3ea7c6f8061cf7ce10464b7780787a">operator()</a> (const <a class="el" href="classcasacore_1_1Slicer.html">Slicer</a> &amp;) const </td></tr>
<tr class="separator:a0c3ea7c6f8061cf7ce10464b7780787a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab448c3e82ee0f8742ce1b4530b9d0aa6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcasacore_1_1CountedPtr.html">CountedPtr</a>&lt; <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ab448c3e82ee0f8742ce1b4530b9d0aa6">getSection</a> (const <a class="el" href="classcasacore_1_1Slicer.html">Slicer</a> &amp;) const </td></tr>
<tr class="memdesc:ab448c3e82ee0f8742ce1b4530b9d0aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to a section of an array.  <a href="#ab448c3e82ee0f8742ce1b4530b9d0aa6">More...</a><br/></td></tr>
<tr class="separator:ab448c3e82ee0f8742ce1b4530b9d0aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6053a0385ae1e91ab5db7f590441673"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ab6053a0385ae1e91ab5db7f590441673">operator[]</a> (size_t i) const </td></tr>
<tr class="memdesc:ab6053a0385ae1e91ab5db7f590441673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the subset given by the i-th value of the last axis.  <a href="#ab6053a0385ae1e91ab5db7f590441673">More...</a><br/></td></tr>
<tr class="separator:ab6053a0385ae1e91ab5db7f590441673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1708589aff5ad3adf160fa4c37ab1a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aa1708589aff5ad3adf160fa4c37ab1a6">diagonals</a> (<a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> firstAxis=0, <a class="el" href="namespacecasacore.html#a79c2dfec4363785472512dbf384675a1">Int64</a> diag=0) const </td></tr>
<tr class="memdesc:aa1708589aff5ad3adf160fa4c37ab1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the diagonal of each matrix part in the full array.  <a href="#aa1708589aff5ad3adf160fa4c37ab1a6">More...</a><br/></td></tr>
<tr class="separator:aa1708589aff5ad3adf160fa4c37ab1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4aaa73131f1bb2fe780ee4c6f69d3c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a9a4aaa73131f1bb2fe780ee4c6f69d3c">operator()</a> (const LogicalArray &amp;<a class="el" href="namespacecasacore.html#a7546375a4910a76c4e40307b24fee91b">mask</a>) const </td></tr>
<tr class="memdesc:a9a4aaa73131f1bb2fe780ee4c6f69d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array is masked by the input LogicalArray.  <a href="#a9a4aaa73131f1bb2fe780ee4c6f69d3c">More...</a><br/></td></tr>
<tr class="separator:a9a4aaa73131f1bb2fe780ee4c6f69d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb23ee71849cebe7c526c5ae70322cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a8bb23ee71849cebe7c526c5ae70322cc">operator()</a> (const LogicalArray &amp;<a class="el" href="namespacecasacore.html#a7546375a4910a76c4e40307b24fee91b">mask</a>)</td></tr>
<tr class="separator:a8bb23ee71849cebe7c526c5ae70322cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c71912a00ba77226806173bcbce0427"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a9c71912a00ba77226806173bcbce0427">operator()</a> (const MaskedLogicalArray &amp;<a class="el" href="namespacecasacore.html#a7546375a4910a76c4e40307b24fee91b">mask</a>) const </td></tr>
<tr class="memdesc:a9c71912a00ba77226806173bcbce0427"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array is masked by the input MaskedLogicalArray.  <a href="#a9c71912a00ba77226806173bcbce0427">More...</a><br/></td></tr>
<tr class="separator:a9c71912a00ba77226806173bcbce0427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c84f9ca0005362dc30039325bf2a46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ac7c84f9ca0005362dc30039325bf2a46">operator()</a> (const MaskedLogicalArray &amp;<a class="el" href="namespacecasacore.html#a7546375a4910a76c4e40307b24fee91b">mask</a>)</td></tr>
<tr class="separator:ac7c84f9ca0005362dc30039325bf2a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf33c3457f1097ac0e0da72aaba46ead"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aaf33c3457f1097ac0e0da72aaba46ead">nrefs</a> () const </td></tr>
<tr class="memdesc:aaf33c3457f1097ac0e0da72aaba46ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of references the underlying storage has assigned to it.  <a href="#aaf33c3457f1097ac0e0da72aaba46ead">More...</a><br/></td></tr>
<tr class="separator:aaf33c3457f1097ac0e0da72aaba46ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f26d4be19d73025b3c953763631793"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a47f26d4be19d73025b3c953763631793">ok</a> () const </td></tr>
<tr class="memdesc:a47f26d4be19d73025b3c953763631793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> is consistent.  <a href="#a47f26d4be19d73025b3c953763631793">More...</a><br/></td></tr>
<tr class="separator:a47f26d4be19d73025b3c953763631793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93760dbeebff999483b5f4a12d38d9f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a93760dbeebff999483b5f4a12d38d9f7">conform</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;other) const </td></tr>
<tr class="memdesc:a93760dbeebff999483b5f4a12d38d9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are the shapes identical?  <a href="#a93760dbeebff999483b5f4a12d38d9f7">More...</a><br/></td></tr>
<tr class="separator:a93760dbeebff999483b5f4a12d38d9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af3693fc95174edc9584fa6c926f3b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a8af3693fc95174edc9584fa6c926f3b3">conform</a> (const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T &gt; &amp;other) const </td></tr>
<tr class="separator:a8af3693fc95174edc9584fa6c926f3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f2b7438f5620df00610beeebc69b53"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a43f2b7438f5620df00610beeebc69b53">data</a> ()</td></tr>
<tr class="memdesc:a43f2b7438f5620df00610beeebc69b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the beginning of the array.  <a href="#a43f2b7438f5620df00610beeebc69b53">More...</a><br/></td></tr>
<tr class="separator:a43f2b7438f5620df00610beeebc69b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750fb1194358e4d6a29d1fbf94589769"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a750fb1194358e4d6a29d1fbf94589769">data</a> () const </td></tr>
<tr class="separator:a750fb1194358e4d6a29d1fbf94589769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d20771ba5c91f64f73c6920796e15b"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ad8d20771ba5c91f64f73c6920796e15b">getStorage</a> (<a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> &amp;deleteIt)</td></tr>
<tr class="memdesc:ad8d20771ba5c91f64f73c6920796e15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generally use of this should be shunned, except to use a FORTRAN routine or something similar.  <a href="#ad8d20771ba5c91f64f73c6920796e15b">More...</a><br/></td></tr>
<tr class="separator:ad8d20771ba5c91f64f73c6920796e15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae273f4cde002a53cddceabbc416bdccd"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ae273f4cde002a53cddceabbc416bdccd">getStorage</a> (<a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> &amp;deleteIt) const </td></tr>
<tr class="separator:ae273f4cde002a53cddceabbc416bdccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bd2a608f0993b591b3be50cbfc59d4"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#af8bd2a608f0993b591b3be50cbfc59d4">getVStorage</a> (<a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> &amp;deleteIt)</td></tr>
<tr class="memdesc:af8bd2a608f0993b591b3be50cbfc59d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following functions behave the same as the corresponding getStorage functions in the derived templated <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> class.  <a href="#af8bd2a608f0993b591b3be50cbfc59d4">More...</a><br/></td></tr>
<tr class="separator:af8bd2a608f0993b591b3be50cbfc59d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e7bacdcc17c178d821fda60c695c10"><td class="memItemLeft" align="right" valign="top">virtual const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a57e7bacdcc17c178d821fda60c695c10">getVStorage</a> (<a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> &amp;deleteIt) const </td></tr>
<tr class="separator:a57e7bacdcc17c178d821fda60c695c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27561819689f0bd4085b5146954e0ebf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a27561819689f0bd4085b5146954e0ebf">putStorage</a> (T *&amp;storage, <a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> deleteAndCopy)</td></tr>
<tr class="memdesc:a27561819689f0bd4085b5146954e0ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Array.html#a27561819689f0bd4085b5146954e0ebf" title="putStorage() is normally called after a call to getStorage() (cf). ">putStorage()</a> is normally called after a call to <a class="el" href="classcasacore_1_1Array.html#ad8d20771ba5c91f64f73c6920796e15b" title="Generally use of this should be shunned, except to use a FORTRAN routine or something similar...">getStorage()</a> (cf).  <a href="#a27561819689f0bd4085b5146954e0ebf">More...</a><br/></td></tr>
<tr class="separator:a27561819689f0bd4085b5146954e0ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cbf081480a6fa6df42911989fff631"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a24cbf081480a6fa6df42911989fff631">putVStorage</a> (void *&amp;storage, <a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> deleteAndCopy)</td></tr>
<tr class="separator:a24cbf081480a6fa6df42911989fff631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e125859a0f23cca72cc6baef8bdb8aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a5e125859a0f23cca72cc6baef8bdb8aa">freeStorage</a> (const T *&amp;storage, <a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> deleteIt) const </td></tr>
<tr class="memdesc:a5e125859a0f23cca72cc6baef8bdb8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">If deleteIt is set, delete "storage".  <a href="#a5e125859a0f23cca72cc6baef8bdb8aa">More...</a><br/></td></tr>
<tr class="separator:a5e125859a0f23cca72cc6baef8bdb8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3bc758294efb89bd9a01883738c93d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#afc3bc758294efb89bd9a01883738c93d">freeVStorage</a> (const void *&amp;storage, <a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> deleteIt) const </td></tr>
<tr class="separator:afc3bc758294efb89bd9a01883738c93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced59eeb9ed3325380d264f9324254bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aced59eeb9ed3325380d264f9324254bc">takeStorage</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, T *storage, <a class="el" href="group__Arrays__module.html#ga44401e80192e152e570fc445a95f534b">StorageInitPolicy</a> policy=<a class="el" href="group__Arrays__module.html#gga44401e80192e152e570fc445a95f534ba46b2e4579af5e1f449bb55cfd9f1c9bc">COPY</a>)</td></tr>
<tr class="memdesc:aced59eeb9ed3325380d264f9324254bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the data values with those in the pointer <code>storage</code>.  <a href="#aced59eeb9ed3325380d264f9324254bc">More...</a><br/></td></tr>
<tr class="separator:aced59eeb9ed3325380d264f9324254bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468ea2bb5b23458f62978883a6939115"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a468ea2bb5b23458f62978883a6939115">takeStorage</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, T *storage, <a class="el" href="group__Arrays__module.html#ga44401e80192e152e570fc445a95f534b">StorageInitPolicy</a> policy, <a class="el" href="classcasacore_1_1AbstractAllocator.html">AbstractAllocator</a>&lt; T &gt; const &amp;allocator)</td></tr>
<tr class="memdesc:a468ea2bb5b23458f62978883a6939115"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>policy</code> is <code>COPY</code>, storage of a new copy is allocated by <code>allocator</code>.  <a href="#a468ea2bb5b23458f62978883a6939115">More...</a><br/></td></tr>
<tr class="separator:a468ea2bb5b23458f62978883a6939115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7d7d74d1b8ee910e3bd44a7f901612"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a1d7d7d74d1b8ee910e3bd44a7f901612">takeStorage</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, const T *storage)</td></tr>
<tr class="memdesc:a1d7d7d74d1b8ee910e3bd44a7f901612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since the pointer is const, a copy is always taken.  <a href="#a1d7d7d74d1b8ee910e3bd44a7f901612">More...</a><br/></td></tr>
<tr class="separator:a1d7d7d74d1b8ee910e3bd44a7f901612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f336b87fb81e2ed66c6d2da114a3fb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a14f336b87fb81e2ed66c6d2da114a3fb">takeStorage</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, const T *storage, <a class="el" href="classcasacore_1_1AbstractAllocator.html">AbstractAllocator</a>&lt; T &gt; const &amp;allocator)</td></tr>
<tr class="memdesc:a14f336b87fb81e2ed66c6d2da114a3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since the pointer is const, a copy is always taken.  <a href="#a14f336b87fb81e2ed66c6d2da114a3fb">More...</a><br/></td></tr>
<tr class="separator:a14f336b87fb81e2ed66c6d2da114a3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a61213c596587d4a6257f7e95f8a0e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcasacore_1_1CountedPtr.html">CountedPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classcasacore_1_1ArrayPositionIterator.html">ArrayPositionIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#af2a61213c596587d4a6257f7e95f8a0e">makeIterator</a> (<a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> byDim) const </td></tr>
<tr class="memdesc:af2a61213c596587d4a6257f7e95f8a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classcasacore_1_1ArrayIterator.html" title="Iterate an Array cursor through another Array. ">ArrayIterator</a> object of the correct type.  <a href="#af2a61213c596587d4a6257f7e95f8a0e">More...</a><br/></td></tr>
<tr class="separator:af2a61213c596587d4a6257f7e95f8a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcasacore_1_1ArrayBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcasacore_1_1ArrayBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcasacore_1_1ArrayBase.html">casacore::ArrayBase</a></td></tr>
<tr class="memitem:a053846053b63354f0a4387c41acb2046 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a053846053b63354f0a4387c41acb2046">ArrayBase</a> ()</td></tr>
<tr class="separator:a053846053b63354f0a4387c41acb2046 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ed9204473ba8e56c000aec28f897a9 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a91ed9204473ba8e56c000aec28f897a9">ArrayBase</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>)</td></tr>
<tr class="memdesc:a91ed9204473ba8e56c000aec28f897a9 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array of the given shape, i.e.  <a href="#a91ed9204473ba8e56c000aec28f897a9">More...</a><br/></td></tr>
<tr class="separator:a91ed9204473ba8e56c000aec28f897a9 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c9620b87a61de748defab245f98407 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a30c9620b87a61de748defab245f98407">ArrayBase</a> (const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;other)</td></tr>
<tr class="memdesc:a30c9620b87a61de748defab245f98407 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a30c9620b87a61de748defab245f98407">More...</a><br/></td></tr>
<tr class="separator:a30c9620b87a61de748defab245f98407 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ca33b8556f2a859238343811e9de91 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#ad2ca33b8556f2a859238343811e9de91">operator=</a> (const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;)</td></tr>
<tr class="memdesc:ad2ca33b8556f2a859238343811e9de91 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <a href="#ad2ca33b8556f2a859238343811e9de91">More...</a><br/></td></tr>
<tr class="separator:ad2ca33b8556f2a859238343811e9de91 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e998bdc6fe6690cfeed4aae50ecee1 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a57e998bdc6fe6690cfeed4aae50ecee1">~ArrayBase</a> ()</td></tr>
<tr class="memdesc:a57e998bdc6fe6690cfeed4aae50ecee1 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a57e998bdc6fe6690cfeed4aae50ecee1">More...</a><br/></td></tr>
<tr class="separator:a57e998bdc6fe6690cfeed4aae50ecee1 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae539a569a3083270ebb8332fb9383c74 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#ae539a569a3083270ebb8332fb9383c74">ndim</a> () const </td></tr>
<tr class="memdesc:ae539a569a3083270ebb8332fb9383c74 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimensionality of this array.  <a href="#ae539a569a3083270ebb8332fb9383c74">More...</a><br/></td></tr>
<tr class="separator:ae539a569a3083270ebb8332fb9383c74 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c59e870964872ddfeb2de91e05d8b55 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a9c59e870964872ddfeb2de91e05d8b55">nelements</a> () const </td></tr>
<tr class="memdesc:a9c59e870964872ddfeb2de91e05d8b55 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many elements does this array have? Product of all axis lengths.  <a href="#a9c59e870964872ddfeb2de91e05d8b55">More...</a><br/></td></tr>
<tr class="separator:a9c59e870964872ddfeb2de91e05d8b55 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7934dab73a7952f9fbfb7a887efbe34 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#ad7934dab73a7952f9fbfb7a887efbe34">size</a> () const </td></tr>
<tr class="separator:ad7934dab73a7952f9fbfb7a887efbe34 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf827b05c0360b25c3dc2fb3130ac112 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#acf827b05c0360b25c3dc2fb3130ac112">empty</a> () const </td></tr>
<tr class="memdesc:acf827b05c0360b25c3dc2fb3130ac112 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the array empty (i.e.  <a href="#acf827b05c0360b25c3dc2fb3130ac112">More...</a><br/></td></tr>
<tr class="separator:acf827b05c0360b25c3dc2fb3130ac112 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6466d44961f81840cf49339755efbe2c inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a6466d44961f81840cf49339755efbe2c">contiguousStorage</a> () const </td></tr>
<tr class="memdesc:a6466d44961f81840cf49339755efbe2c inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are the array data contiguous? If they are not contiguous, <code>getStorage</code> (see below) needs to make a copy.  <a href="#a6466d44961f81840cf49339755efbe2c">More...</a><br/></td></tr>
<tr class="separator:a6466d44961f81840cf49339755efbe2c inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddb725358b52d576969897b1e0ef83d inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a> () const </td></tr>
<tr class="memdesc:aaddb725358b52d576969897b1e0ef83d inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of each axis.  <a href="#aaddb725358b52d576969897b1e0ef83d">More...</a><br/></td></tr>
<tr class="separator:aaddb725358b52d576969897b1e0ef83d inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa621866a6785c8a91882b2ee5a2c2e94 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1IPosition.html">IPosition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#aa621866a6785c8a91882b2ee5a2c2e94">endPosition</a> () const </td></tr>
<tr class="memdesc:aa621866a6785c8a91882b2ee5a2c2e94 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function: endPosition(i) = shape(i) - 1; i.e.  <a href="#aa621866a6785c8a91882b2ee5a2c2e94">More...</a><br/></td></tr>
<tr class="separator:aa621866a6785c8a91882b2ee5a2c2e94 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034eb01e79cde1251f17aed40ccfcb45 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a034eb01e79cde1251f17aed40ccfcb45">steps</a> () const </td></tr>
<tr class="memdesc:a034eb01e79cde1251f17aed40ccfcb45 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return steps to be made if stepping one element in a dimension.  <a href="#a034eb01e79cde1251f17aed40ccfcb45">More...</a><br/></td></tr>
<tr class="separator:a034eb01e79cde1251f17aed40ccfcb45 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8459916b0a53b73f16ca03298d752888 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a8459916b0a53b73f16ca03298d752888">validateConformance</a> (const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;) const </td></tr>
<tr class="memdesc:a8459916b0a53b73f16ca03298d752888 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various helper functions.  <a href="#a8459916b0a53b73f16ca03298d752888">More...</a><br/></td></tr>
<tr class="separator:a8459916b0a53b73f16ca03298d752888 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d800f4b3f4d48e4735146fbf5881a8 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a15d800f4b3f4d48e4735146fbf5881a8">validateIndex</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;) const </td></tr>
<tr class="separator:a15d800f4b3f4d48e4735146fbf5881a8 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e45255c14a774bf35d278a1f26aa41 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#ae7e45255c14a774bf35d278a1f26aa41">validateIndex</a> (<a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> index) const </td></tr>
<tr class="separator:ae7e45255c14a774bf35d278a1f26aa41 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21350f3f56d9e1b552a51788df61e13c inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a21350f3f56d9e1b552a51788df61e13c">validateIndex</a> (<a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> index1, <a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> index2) const </td></tr>
<tr class="separator:a21350f3f56d9e1b552a51788df61e13c inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d2952078e4e69fef7ba48ceafbde77 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#ae6d2952078e4e69fef7ba48ceafbde77">validateIndex</a> (<a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> index1, <a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> index2, <a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> index3) const </td></tr>
<tr class="separator:ae6d2952078e4e69fef7ba48ceafbde77 inherit pub_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a24c1725f909aae3465c388e4587975d8"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a24c1725f909aae3465c388e4587975d8">ArrayIterator&lt; T &gt;</a></td></tr>
<tr class="memdesc:a24c1725f909aae3465c388e4587975d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through Arrays.  <a href="#a24c1725f909aae3465c388e4587975d8">More...</a><br/></td></tr>
<tr class="separator:a24c1725f909aae3465c388e4587975d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fc06682c9f9c46f1e0e38b7af25b80"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a17fc06682c9f9c46f1e0e38b7af25b80">Matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:a17fc06682c9f9c46f1e0e38b7af25b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Needed to be a friend for <a class="el" href="classcasacore_1_1Matrix.html#ac718778346fa2655be63625d6a7404b2" title="Make this matrix a reference to other. ">Matrix&lt;T&gt;::reference()</a>  <a href="#a17fc06682c9f9c46f1e0e38b7af25b80">More...</a><br/></td></tr>
<tr class="separator:a17fc06682c9f9c46f1e0e38b7af25b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4639e5eaecf7ce267d9dfcb985b576f"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#af4639e5eaecf7ce267d9dfcb985b576f">value_type</a></td></tr>
<tr class="memdesc:af4639e5eaecf7ce267d9dfcb985b576f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the STL-style iterator functions (only forward iterator).  <a href="#af4639e5eaecf7ce267d9dfcb985b576f">More...</a><br/></td></tr>
<tr class="separator:af4639e5eaecf7ce267d9dfcb985b576f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b61adef85b4fd63f94ef41b89a486c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcasacore_1_1Array_1_1IteratorSTL.html">IteratorSTL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a01b61adef85b4fd63f94ef41b89a486c">iterator</a></td></tr>
<tr class="separator:a01b61adef85b4fd63f94ef41b89a486c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3bc7f293b55248806467f721b12177"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcasacore_1_1Array_1_1ConstIteratorSTL.html">ConstIteratorSTL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a3d3bc7f293b55248806467f721b12177">const_iterator</a></td></tr>
<tr class="separator:a3d3bc7f293b55248806467f721b12177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43502f18c6ff10f1702a8d1fbe2c5de8"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a43502f18c6ff10f1702a8d1fbe2c5de8">contiter</a></td></tr>
<tr class="separator:a43502f18c6ff10f1702a8d1fbe2c5de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9b042a8e96ffdea465babce2068de2"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a2f9b042a8e96ffdea465babce2068de2">const_contiter</a></td></tr>
<tr class="separator:a2f9b042a8e96ffdea465babce2068de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b49ac6e6d75049f2fc0e63c121b0205"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1CountedPtr.html">CountedPtr</a>&lt; <a class="el" href="classcasacore_1_1Block.html">Block</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a9b49ac6e6d75049f2fc0e63c121b0205">data_p</a></td></tr>
<tr class="memdesc:a9b49ac6e6d75049f2fc0e63c121b0205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counted block that contains the storage.  <a href="#a9b49ac6e6d75049f2fc0e63c121b0205">More...</a><br/></td></tr>
<tr class="separator:a9b49ac6e6d75049f2fc0e63c121b0205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c874b43e689bf220263aff190b926d"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a27c874b43e689bf220263aff190b926d">begin_p</a></td></tr>
<tr class="memdesc:a27c874b43e689bf220263aff190b926d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pointer is adjusted to point to the first element of the array.  <a href="#a27c874b43e689bf220263aff190b926d">More...</a><br/></td></tr>
<tr class="separator:a27c874b43e689bf220263aff190b926d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7332aed275a0097b203587c4cbe484"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aed7332aed275a0097b203587c4cbe484">end_p</a></td></tr>
<tr class="memdesc:aed7332aed275a0097b203587c4cbe484"><td class="mdescLeft">&#160;</td><td class="mdescRight">The end for an STL-style iteration.  <a href="#aed7332aed275a0097b203587c4cbe484">More...</a><br/></td></tr>
<tr class="separator:aed7332aed275a0097b203587c4cbe484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c4632d120dfa99fd2c3549593feb67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html#a01b61adef85b4fd63f94ef41b89a486c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a29c4632d120dfa99fd2c3549593feb67">begin</a> ()</td></tr>
<tr class="memdesc:a29c4632d120dfa99fd2c3549593feb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the begin iterator object for any array.  <a href="#a29c4632d120dfa99fd2c3549593feb67">More...</a><br/></td></tr>
<tr class="separator:a29c4632d120dfa99fd2c3549593feb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df864540fcaf43159f29d20db414e0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html#a3d3bc7f293b55248806467f721b12177">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a2df864540fcaf43159f29d20db414e0d">begin</a> () const </td></tr>
<tr class="separator:a2df864540fcaf43159f29d20db414e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40f8c12830ed55a35c7d2e7a5fc24e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html#a01b61adef85b4fd63f94ef41b89a486c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#ad40f8c12830ed55a35c7d2e7a5fc24e5">end</a> ()</td></tr>
<tr class="separator:ad40f8c12830ed55a35c7d2e7a5fc24e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289997221953945e421eda3f43cd3d0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html#a3d3bc7f293b55248806467f721b12177">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a289997221953945e421eda3f43cd3d0b">end</a> () const </td></tr>
<tr class="separator:a289997221953945e421eda3f43cd3d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40af0ed02d935164404ae293f0cb2fe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html#a43502f18c6ff10f1702a8d1fbe2c5de8">contiter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a40af0ed02d935164404ae293f0cb2fe0">cbegin</a> ()</td></tr>
<tr class="memdesc:a40af0ed02d935164404ae293f0cb2fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the begin iterator object for a contiguous array.  <a href="#a40af0ed02d935164404ae293f0cb2fe0">More...</a><br/></td></tr>
<tr class="separator:a40af0ed02d935164404ae293f0cb2fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacf4d9240b152727e11a5303aa871ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html#a2f9b042a8e96ffdea465babce2068de2">const_contiter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#acacf4d9240b152727e11a5303aa871ae">cbegin</a> () const </td></tr>
<tr class="separator:acacf4d9240b152727e11a5303aa871ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303e2200ab006fbdcb742ce8c3f1411d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html#a43502f18c6ff10f1702a8d1fbe2c5de8">contiter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a303e2200ab006fbdcb742ce8c3f1411d">cend</a> ()</td></tr>
<tr class="separator:a303e2200ab006fbdcb742ce8c3f1411d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdb0b458d5a85ac1e019c0ebc357689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html#a2f9b042a8e96ffdea465babce2068de2">const_contiter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#aacdb0b458d5a85ac1e019c0ebc357689">cend</a> () const </td></tr>
<tr class="separator:aacdb0b458d5a85ac1e019c0ebc357689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d59506fd7519daf172bf61d97c912e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a2d59506fd7519daf172bf61d97c912e2">Array</a> (<a class="el" href="structcasacore_1_1Allocator__private_1_1AllocSpec.html">Allocator_private::AllocSpec</a>&lt; T &gt; allocator)</td></tr>
<tr class="separator:a2d59506fd7519daf172bf61d97c912e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2724b1b80df6302b787cf8bdf6ad5069"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a2724b1b80df6302b787cf8bdf6ad5069">Array</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, <a class="el" href="classcasacore_1_1ArrayInitPolicy.html">ArrayInitPolicy</a> initPolicy, <a class="el" href="structcasacore_1_1Allocator__private_1_1BulkAllocator.html">Allocator_private::BulkAllocator</a>&lt; T &gt; *allocator)</td></tr>
<tr class="separator:a2724b1b80df6302b787cf8bdf6ad5069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17768bf9121c91bc1f8dd93c04c5da78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a17768bf9121c91bc1f8dd93c04c5da78">copy</a> (<a class="el" href="classcasacore_1_1ArrayInitPolicy.html">ArrayInitPolicy</a> policy, <a class="el" href="structcasacore_1_1Allocator__private_1_1BulkAllocator.html">Allocator_private::BulkAllocator</a>&lt; T &gt; *allocator) const </td></tr>
<tr class="memdesc:a17768bf9121c91bc1f8dd93c04c5da78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a copy using the allocator.  <a href="#a17768bf9121c91bc1f8dd93c04c5da78">More...</a><br/></td></tr>
<tr class="separator:a17768bf9121c91bc1f8dd93c04c5da78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb55fb754d831ca293c898bc5d5b505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcasacore_1_1Allocator__private_1_1BulkAllocator.html">Allocator_private::BulkAllocator</a><br class="typebreak"/>
&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a1eb55fb754d831ca293c898bc5d5b505">nonNewDelAllocator</a> () const </td></tr>
<tr class="memdesc:a1eb55fb754d831ca293c898bc5d5b505"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the current allocator is NewDelAllocator&lt;T&gt;, BulkAllocator for DefaultAllocator&lt;T&gt; is returned, otherwise BulkAllocator for the current allocator is returned.  <a href="#a1eb55fb754d831ca293c898bc5d5b505">More...</a><br/></td></tr>
<tr class="separator:a1eb55fb754d831ca293c898bc5d5b505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faaa738eef0bbe03e23cc09568f302a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcasacore_1_1ArrayInitPolicy.html">ArrayInitPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a8faaa738eef0bbe03e23cc09568f302a">defaultArrayInitPolicy</a> ()</td></tr>
<tr class="separator:a8faaa738eef0bbe03e23cc09568f302a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638e5676067af72eaf21ccda708263f0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a638e5676067af72eaf21ccda708263f0">copyToContiguousStorage</a> (T *dst, <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; const &amp;src, <a class="el" href="classcasacore_1_1ArrayInitPolicy.html">ArrayInitPolicy</a> policy)</td></tr>
<tr class="separator:a638e5676067af72eaf21ccda708263f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b039d8c5e666e8e27506c676a22b129"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a0b039d8c5e666e8e27506c676a22b129">preTakeStorage</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;)</td></tr>
<tr class="memdesc:a0b039d8c5e666e8e27506c676a22b129"><td class="mdescLeft">&#160;</td><td class="mdescRight">pre/post processing hook of <a class="el" href="classcasacore_1_1Array.html#aced59eeb9ed3325380d264f9324254bc" title="Replace the data values with those in the pointer storage. ">takeStorage()</a> for subclasses.  <a href="#a0b039d8c5e666e8e27506c676a22b129">More...</a><br/></td></tr>
<tr class="separator:a0b039d8c5e666e8e27506c676a22b129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510687a00bfad5e5d5919ea8f16db17b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a510687a00bfad5e5d5919ea8f16db17b">postTakeStorage</a> ()</td></tr>
<tr class="separator:a510687a00bfad5e5d5919ea8f16db17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b2937c9796ac9340278c82c7324eed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a91b2937c9796ac9340278c82c7324eed">doNonDegenerate</a> (const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;other, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;ignoreAxes)</td></tr>
<tr class="memdesc:a91b2937c9796ac9340278c82c7324eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the degenerate axes from the <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> object.  <a href="#a91b2937c9796ac9340278c82c7324eed">More...</a><br/></td></tr>
<tr class="separator:a91b2937c9796ac9340278c82c7324eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b50299d3cb42b3c2060ad0cb8a52e6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a5b50299d3cb42b3c2060ad0cb8a52e6b">makeSteps</a> ()</td></tr>
<tr class="memdesc:a5b50299d3cb42b3c2060ad0cb8a52e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the steps and the end for a derived class.  <a href="#a5b50299d3cb42b3c2060ad0cb8a52e6b">More...</a><br/></td></tr>
<tr class="separator:a5b50299d3cb42b3c2060ad0cb8a52e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0c8703894f0b429e5f878225986b9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Array.html#a9a0c8703894f0b429e5f878225986b9e">setEndIter</a> ()</td></tr>
<tr class="memdesc:a9a0c8703894f0b429e5f878225986b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the end iterator.  <a href="#a9a0c8703894f0b429e5f878225986b9e">More...</a><br/></td></tr>
<tr class="separator:a9a0c8703894f0b429e5f878225986b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classcasacore_1_1ArrayBase"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classcasacore_1_1ArrayBase')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classcasacore_1_1ArrayBase.html">casacore::ArrayBase</a></td></tr>
<tr class="memitem:ad816dd218a374c2a8aa405616ed6d25d inherit pub_static_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#ad816dd218a374c2a8aa405616ed6d25d">arrayVersion</a> ()</td></tr>
<tr class="memdesc:ad816dd218a374c2a8aa405616ed6d25d inherit pub_static_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> version for major change (used by ArrayIO).  <a href="#ad816dd218a374c2a8aa405616ed6d25d">More...</a><br/></td></tr>
<tr class="separator:ad816dd218a374c2a8aa405616ed6d25d inherit pub_static_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcasacore_1_1ArrayBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcasacore_1_1ArrayBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcasacore_1_1ArrayBase.html">casacore::ArrayBase</a></td></tr>
<tr class="memitem:a8df875e7897a8243e39f6bc63f4dbc7d inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a8df875e7897a8243e39f6bc63f4dbc7d">baseCopy</a> (const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;that)</td></tr>
<tr class="separator:a8df875e7897a8243e39f6bc63f4dbc7d inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4708874cddaba5a2111a88974fc37fac inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a4708874cddaba5a2111a88974fc37fac">reformOrResize</a> (const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;newShape, <a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> resizeIfNeeded, <a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> nReferences, <a class="el" href="namespacecasacore.html#a79c2dfec4363785472512dbf384675a1">Int64</a> nElementsAllocated, <a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> copyDataIfNeeded, <a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> resizePercentage)</td></tr>
<tr class="memdesc:a4708874cddaba5a2111a88974fc37fac inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either reforms the array if size permits or resizes it to the new shape.  <a href="#a4708874cddaba5a2111a88974fc37fac">More...</a><br/></td></tr>
<tr class="separator:a4708874cddaba5a2111a88974fc37fac inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac840eab4973d227ddac1611a66b7e13e inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#ac840eab4973d227ddac1611a66b7e13e">isStorageContiguous</a> () const </td></tr>
<tr class="memdesc:ac840eab4973d227ddac1611a66b7e13e inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the storage of a subset is contiguous.  <a href="#ac840eab4973d227ddac1611a66b7e13e">More...</a><br/></td></tr>
<tr class="separator:ac840eab4973d227ddac1611a66b7e13e inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41a8e183c0ab44b35b3cccf5ba344a2 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#ac41a8e183c0ab44b35b3cccf5ba344a2">checkVectorShape</a> ()</td></tr>
<tr class="memdesc:ac41a8e183c0ab44b35b3cccf5ba344a2 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the shape of a vector is correct.  <a href="#ac41a8e183c0ab44b35b3cccf5ba344a2">More...</a><br/></td></tr>
<tr class="separator:ac41a8e183c0ab44b35b3cccf5ba344a2 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff72758e9d4bc7a349784896aa0764e inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a2ff72758e9d4bc7a349784896aa0764e">checkMatrixShape</a> ()</td></tr>
<tr class="memdesc:a2ff72758e9d4bc7a349784896aa0764e inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the shape of a matrix is correct.  <a href="#a2ff72758e9d4bc7a349784896aa0764e">More...</a><br/></td></tr>
<tr class="separator:a2ff72758e9d4bc7a349784896aa0764e inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c82bc4afae2c73a2ccc962f88059c0 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#af2c82bc4afae2c73a2ccc962f88059c0">checkCubeShape</a> ()</td></tr>
<tr class="memdesc:af2c82bc4afae2c73a2ccc962f88059c0 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the shape of a cube is correct.  <a href="#af2c82bc4afae2c73a2ccc962f88059c0">More...</a><br/></td></tr>
<tr class="separator:af2c82bc4afae2c73a2ccc962f88059c0 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1ae97d6954c1cbae2a600b6cd401d9 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#aec1ae97d6954c1cbae2a600b6cd401d9">baseReform</a> (<a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;tmp, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;<a class="el" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>, <a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> strict=<a class="el" href="namespacecasacore.html#ad5c850f9e177173e0f7d0ad57091501d">True</a>) const </td></tr>
<tr class="memdesc:aec1ae97d6954c1cbae2a600b6cd401d9 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reform the array to a shape with the same nr of elements.  <a href="#aec1ae97d6954c1cbae2a600b6cd401d9">More...</a><br/></td></tr>
<tr class="separator:aec1ae97d6954c1cbae2a600b6cd401d9 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff75013c8d149ee61e682be1d47e173 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a1ff75013c8d149ee61e682be1d47e173">baseNonDegenerate</a> (const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;other, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;ignoreAxes)</td></tr>
<tr class="memdesc:a1ff75013c8d149ee61e682be1d47e173 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the degenerate axes from the <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> object.  <a href="#a1ff75013c8d149ee61e682be1d47e173">More...</a><br/></td></tr>
<tr class="separator:a1ff75013c8d149ee61e682be1d47e173 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfd7079a0d3ac1a42cdc7fbb728d2c3 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a3cfd7079a0d3ac1a42cdc7fbb728d2c3">baseAddDegenerate</a> (<a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;, <a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> numAxes)</td></tr>
<tr class="memdesc:a3cfd7079a0d3ac1a42cdc7fbb728d2c3 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">These member functions return an <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> reference with the specified number of extra axes, all of length one, appended to the end of the <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a>.  <a href="#a3cfd7079a0d3ac1a42cdc7fbb728d2c3">More...</a><br/></td></tr>
<tr class="separator:a3cfd7079a0d3ac1a42cdc7fbb728d2c3 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ecf3661363376aa05c0bcb585b51cf inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a74ecf3661363376aa05c0bcb585b51cf">makeSubset</a> (<a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;out, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;b, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;e, const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;i)</td></tr>
<tr class="memdesc:a74ecf3661363376aa05c0bcb585b51cf inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a subset of an array.  <a href="#a74ecf3661363376aa05c0bcb585b51cf">More...</a><br/></td></tr>
<tr class="separator:a74ecf3661363376aa05c0bcb585b51cf inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043eca1e808ee63390c68e747a318b21 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a043eca1e808ee63390c68e747a318b21">makeDiagonal</a> (<a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> firstAxis, <a class="el" href="namespacecasacore.html#a79c2dfec4363785472512dbf384675a1">Int64</a> diag)</td></tr>
<tr class="memdesc:a043eca1e808ee63390c68e747a318b21 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the length and stride such that the diagonal of the matrices defined by two consecutive axes is formed.  <a href="#a043eca1e808ee63390c68e747a318b21">More...</a><br/></td></tr>
<tr class="separator:a043eca1e808ee63390c68e747a318b21 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88ae04ab9ead9fdc6983aab3b6faff4 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#ae88ae04ab9ead9fdc6983aab3b6faff4">conform2</a> (const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;other) const </td></tr>
<tr class="memdesc:ae88ae04ab9ead9fdc6983aab3b6faff4 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are the shapes identical?  <a href="#ae88ae04ab9ead9fdc6983aab3b6faff4">More...</a><br/></td></tr>
<tr class="separator:ae88ae04ab9ead9fdc6983aab3b6faff4 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c41931c3a6b36e65daf32efbc145e36 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a8c41931c3a6b36e65daf32efbc145e36">baseMakeSteps</a> ()</td></tr>
<tr class="memdesc:a8c41931c3a6b36e65daf32efbc145e36 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the indexing step sizes.  <a href="#a8c41931c3a6b36e65daf32efbc145e36">More...</a><br/></td></tr>
<tr class="separator:a8c41931c3a6b36e65daf32efbc145e36 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e501660b524141a613fd9e9e931cce8 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a9e501660b524141a613fd9e9e931cce8">throwNdimVector</a> ()</td></tr>
<tr class="memdesc:a9e501660b524141a613fd9e9e931cce8 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw expection if vector dimensionality is incorrect.  <a href="#a9e501660b524141a613fd9e9e931cce8">More...</a><br/></td></tr>
<tr class="separator:a9e501660b524141a613fd9e9e931cce8 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205236c7b82982e21cfd1c2eb708f667 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a205236c7b82982e21cfd1c2eb708f667">copyVectorHelper</a> (const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;other)</td></tr>
<tr class="memdesc:a205236c7b82982e21cfd1c2eb708f667 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for templated <a class="el" href="classcasacore_1_1Vector.html" title="A 1-D Specialization of the Array class. ">Vector</a> class.  <a href="#a205236c7b82982e21cfd1c2eb708f667">More...</a><br/></td></tr>
<tr class="separator:a205236c7b82982e21cfd1c2eb708f667 inherit pro_methods_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcasacore_1_1ArrayBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcasacore_1_1ArrayBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcasacore_1_1ArrayBase.html">casacore::ArrayBase</a></td></tr>
<tr class="memitem:a4d5272ad5674505e20d8945acfe9c666 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a4d5272ad5674505e20d8945acfe9c666">nels_p</a></td></tr>
<tr class="memdesc:a4d5272ad5674505e20d8945acfe9c666 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements in the array.  <a href="#a4d5272ad5674505e20d8945acfe9c666">More...</a><br/></td></tr>
<tr class="separator:a4d5272ad5674505e20d8945acfe9c666 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8454c5d925e0408d27bc460a8cf7ae inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#aff8454c5d925e0408d27bc460a8cf7ae">ndimen_p</a></td></tr>
<tr class="memdesc:aff8454c5d925e0408d27bc460a8cf7ae inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimensionality of the array.  <a href="#aff8454c5d925e0408d27bc460a8cf7ae">More...</a><br/></td></tr>
<tr class="separator:aff8454c5d925e0408d27bc460a8cf7ae inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f17e36ab86d35e3fb9b5bd170f42c05 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a5f17e36ab86d35e3fb9b5bd170f42c05">contiguous_p</a></td></tr>
<tr class="memdesc:a5f17e36ab86d35e3fb9b5bd170f42c05 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are the data contiguous?  <a href="#a5f17e36ab86d35e3fb9b5bd170f42c05">More...</a><br/></td></tr>
<tr class="separator:a5f17e36ab86d35e3fb9b5bd170f42c05 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d08aacff0367d78e33b4d9137e8527 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1IPosition.html">IPosition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#ab1d08aacff0367d78e33b4d9137e8527">length_p</a></td></tr>
<tr class="memdesc:ab1d08aacff0367d78e33b4d9137e8527 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to hold the shape, increment into the underlying storage and originalLength of the array.  <a href="#ab1d08aacff0367d78e33b4d9137e8527">More...</a><br/></td></tr>
<tr class="separator:ab1d08aacff0367d78e33b4d9137e8527 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d5bbd97070fc1e0c5f5a5596c247b0 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1IPosition.html">IPosition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a83d5bbd97070fc1e0c5f5a5596c247b0">inc_p</a></td></tr>
<tr class="separator:a83d5bbd97070fc1e0c5f5a5596c247b0 inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8195fae04c02bad814a4a352747c1ead inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1IPosition.html">IPosition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#a8195fae04c02bad814a4a352747c1ead">originalLength_p</a></td></tr>
<tr class="separator:a8195fae04c02bad814a4a352747c1ead inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19b3969a0875a2ead7c4611de6b2d4f inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcasacore_1_1IPosition.html">IPosition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayBase.html#ad19b3969a0875a2ead7c4611de6b2d4f">steps_p</a></td></tr>
<tr class="memdesc:ad19b3969a0875a2ead7c4611de6b2d4f inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to hold the step to next element in each dimension.  <a href="#ad19b3969a0875a2ead7c4611de6b2d4f">More...</a><br/></td></tr>
<tr class="separator:ad19b3969a0875a2ead7c4611de6b2d4f inherit pro_attribs_classcasacore_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br/>
class casacore::Array&lt; T &gt;</h3>

<p>template &lt;class T, class U&gt; class vector; </p>
<p>forward declarations:</p>
<p><a class="anchor" id="Array_summary"></a> A templated N-D <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> class with zero origin Array&lt;T&gt; is a templated, N-dimensional, <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> class. The origin is zero, but by default indices are zero-based. This <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> class is the base class for specialized Vector&lt;T&gt;, Matrix&lt;T&gt;, and Cube&lt;T&gt; classes.</p>
<p>Indexing into the array, and positions in general, are given with <a class="el" href="classcasacore_1_1IPosition.html" title="A Vector of integers, for indexing into Array&lt;T&gt; objects. ">IPosition</a> (essentially a vector of integers) objects. That is, an N-dimensional array requires a length-N <a class="el" href="classcasacore_1_1IPosition.html" title="A Vector of integers, for indexing into Array&lt;T&gt; objects. ">IPosition</a> to define a position within the array. Unlike <a class="el" href="namespacecasacore_1_1C.html">C</a>, indexing is done with (), not []. Also, the storage order is the same as in FORTRAN, i.e. memory varies most rapidly with the first index. </p>
<div class="fragment"><div class="line"><span class="comment">// axisLengths = [1,2,3,4,5]</span></div>
<div class="line">IPosition axisLengths(5, 1, 2, 3, 4, 5); </div>
<div class="line">Array&lt;Int&gt; ai(axisLengths);         <span class="comment">// ai is a 5 dimensional array of</span></div>
<div class="line"><span class="comment">// integers; indices are 0-based</span></div>
<div class="line"><span class="comment">// =&gt; ai.nelements() == 120</span></div>
<div class="line">Array&lt;Int&gt; ai2(axisLengths);        <span class="comment">// The first element is at index 0</span></div>
<div class="line">IPosition zero(5); zero = 0;        <span class="comment">// [0,0,0,0,0]</span></div>
<div class="line"><span class="comment">//..\.</span></div>
</div><!-- fragment --><p> Indexing into an N-dimensional array is relatively expensive. Normally you will index into a <a class="el" href="classcasacore_1_1Vector.html" title="A 1-D Specialization of the Array class. ">Vector</a>, <a class="el" href="classcasacore_1_1Matrix.html" title="A 2-D Specialization of the Array class. ">Matrix</a>, or <a class="el" href="classcasacore_1_1Cube.html" title="A 3-D Specialization of the Array class. ">Cube</a>. These may be obtained from an N-dimensional array by creating a reference, or by using an <a class="el" href="classcasacore_1_1ArrayIterator.html" title="Iterate an Array cursor through another Array. ">ArrayIterator</a>. The "shape" of the array is an <a class="el" href="classcasacore_1_1IPosition.html" title="A Vector of integers, for indexing into Array&lt;T&gt; objects. ">IPosition</a> which gives the length of each axis.</p>
<p>An <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> may be standalone, or it may refer to another array, or to part of another array (by refer we mean that if you change a pixel in the current array, a pixel in the referred to array also changes, i.e. they share underlying storage). <br/>
<b>Warning:</b><em> One way one array can reference another is through the copy constructor; While this might be what you want, you should probably use the <a class="el" href="classcasacore_1_1Array.html#adcfb6bd1f6e0a70dc1c2909739e09d07" title="After invocation, this array and other reference the same storage. ">reference()</a> member function to make it explicit; The copy constructor is used when arguments are passed by value; normally functions should not pass Arrays by value, rather they should pass a reference or a const reference; On the positive side, returning an array from a function is efficient since no copying need be done; </em><br/>
</p>
<p>Aside from the explicit <a class="el" href="classcasacore_1_1Array.html#adcfb6bd1f6e0a70dc1c2909739e09d07" title="After invocation, this array and other reference the same storage. ">reference()</a> member function, a user will most commonly encounter an array which references another array when he takes an array slice (or section). A slice is a sub-region of an array (which might also have a stride: every nth row, every mth column, ...). </p>
<div class="fragment"><div class="line">IPosition lengths(3,10,20,30);</div>
<div class="line">Array&lt;Int&gt; ai(lengths);         <span class="comment">// A 10x20x30 cube</span></div>
<div class="line">Cube&lt;Int&gt; ci;</div>
<div class="line"><span class="comment">//..\.</span></div>
<div class="line">ci.reference(ai1);              <span class="comment">// ci and ai now reference the same</span></div>
<div class="line"><span class="comment">// storage</span></div>
<div class="line">ci(0,0,0) = 123;                <span class="comment">// Can use Cube indexing</span></div>
<div class="line">ci.xyPlane(2) = 0;              <span class="comment">//     and other member functions</span></div>
<div class="line">IPosition zero(3,0,0,0);</div>
<div class="line">assert(ai(zero) == 123);        <span class="comment">// True because ai, ci are references</span></div>
<div class="line"><span class="comment">//..\.</span></div>
<div class="line">Array&lt;Int&gt; subArray;</div>
<div class="line">IPosition blc(3,0,0,0), trc(3,5,5,5);</div>
<div class="line">subArray.reference(ai(blc, trc));</div>
<div class="line">subArray = 10;                  <span class="comment">// All of subArray, which is the</span></div>
<div class="line"><span class="comment">// subcube from 0,0,0 to 5,5,5 in</span></div>
<div class="line"><span class="comment">// ai, has the value 10.</span></div>
</div><!-- fragment --><p> While the last example has an array slice referenced explicitly by another array variable, normally the user will often only use the slice as a temporary in an expresion, for example: </p>
<div class="fragment"><div class="line">Array&lt;Complex&gt; <a class="code" href="namespacecasacore.html#a72e8481a74e808b5facfb20a2352d075">array</a>;</div>
<div class="line">IPosition blc, trc, offset;</div>
<div class="line"><span class="comment">//..\.</span></div>
<div class="line"><span class="comment">// Copy from one region of the array into another</span></div>
<div class="line"><a class="code" href="namespacecasacore.html#a72e8481a74e808b5facfb20a2352d075">array</a>(blc, trc) = <a class="code" href="namespacecasacore.html#a72e8481a74e808b5facfb20a2352d075">array</a>(blc+offset, trc+offset);</div>
</div><!-- fragment --><p>The <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> classes are intended to operate on relatively large amounts of data. While they haven't been extensively tuned yet, they are relatively efficient in terms of speed. Presently they are not space efficient &ndash; the overhead is about 15 words. While this will be improved (probably to about 1/2 that), these array classes are not appropriate for very large numbers of very small arrays. The Block&lt;T&gt; class may be what you want in this circumstance.</p>
<p>Element by element mathematical and logical operations are available for arrays (defined in aips/ArrayMath.h and aips/ArrayLogical.h). Because arithmetic and logical functions are split out, it is possible to create an Array&lt;T&gt; (and hence Vector&lt;T&gt; etc) for any type T that has a default constructor, assignment operator, and copy constructor. In particular, Array&lt;String&gt; works.</p>
<p>If compiled with the preprocessor symbol AIPS_DEBUG symbol, array consistency ("invariants") will be checked in most member functions, and indexing will be range-checked. This should not be defined for production runs.</p>
<p><br/>
<b>Tip:</b><em> Most of the data members and functions which are "protected" should likely become "private"; </em><br/>
</p>
<h3>To Do</h3>
<ul>
<li>
Integrate into the <a class="el" href="classcasacore_1_1Lattice.html" title="A templated, abstract base class for array-like objects. ">Lattice</a> hierarchy </li>
<li>
Factor out the common functions (shape etc) into a type-independent base class. </li>
</ul>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00166">166</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a2f9b042a8e96ffdea465babce2068de2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::<a class="el" href="classcasacore_1_1Array.html#a2f9b042a8e96ffdea465babce2068de2">const_contiter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00852">852</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3d3bc7f293b55248806467f721b12177"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcasacore_1_1Array_1_1ConstIteratorSTL.html">ConstIteratorSTL</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::<a class="el" href="classcasacore_1_1Array.html#a3d3bc7f293b55248806467f721b12177">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00850">850</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a43502f18c6ff10f1702a8d1fbe2c5de8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::<a class="el" href="classcasacore_1_1Array.html#a43502f18c6ff10f1702a8d1fbe2c5de8">contiter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00851">851</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a01b61adef85b4fd63f94ef41b89a486c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcasacore_1_1Array_1_1IteratorSTL.html">IteratorSTL</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::<a class="el" href="classcasacore_1_1Array.html#a01b61adef85b4fd63f94ef41b89a486c">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00849">849</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="af4639e5eaecf7ce267d9dfcb985b576f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::<a class="el" href="classcasacore_1_1Array.html#af4639e5eaecf7ce267d9dfcb985b576f">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the STL-style iterator functions (only forward iterator). </p>
<p>It makes it possible to iterate through all data elements of an array and to use it common STL functions. The <a class="el" href="classcasacore_1_1Array.html#ad40f8c12830ed55a35c7d2e7a5fc24e5">end()</a> function is relatively expensive, so it should not be used inside a for statement. It is much better to call it beforehand as shown in the example below. Furthermore it is very important to use <code>++iter</code>, because <code>iter++</code> is 4 times slower. </p>
<div class="fragment"><div class="line">Array&lt;Int&gt; arr(shape);</div>
<div class="line"><a class="code" href="classcasacore_1_1Array.html#a01b61adef85b4fd63f94ef41b89a486c">Array&lt;Int&gt;::iterator</a> iterend(arr.end());</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="classcasacore_1_1Array.html#a01b61adef85b4fd63f94ef41b89a486c">Array&lt;Int&gt;::iterator</a> iter=arr.begin(); iter!=iterend; ++iter) {</div>
<div class="line">*iter += 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> class supports random access, so in principle a random iterator could be implemented, but its performance would not be great, especially for non-contiguous arrays. <br/>
Some other STL like functions exist for performance reasons. If the array is contiguous, it is possible to use the <code>cbegin</code> and <code>cend</code> functions which are about 10% faster. <a class="anchor" id="Array_iterator-typedefs"></a> STL-style typedefs. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00848">848</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aeae23521ec2f6e539be36e048b99f28f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result has dimensionality of zero, and nelements is zero. </p>
<p>Storage will be allocated by <code><a class="el" href="classcasacore_1_1DefaultAllocator.html" title="An aligned allocator with the default alignment. ">DefaultAllocator</a>&lt;T&gt;</code>. </p>

</div>
</div>
<a class="anchor" id="ad388cd5a3e1befde8f63668eadf0e4e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an array of the given shape, i.e. </p>
<p>after construction <a class="el" href="namespacecasacore.html#a2eb958ed449eb76058df916fa5e3d7e1" title="1-argument function to get the dimensionality of a lattice. ">array.ndim()</a> == <a class="el" href="namespacecasacore.html#adfd652c4018497747cfa235c8fa22bba" title="1-argument function to get the number of elements in a lattice. ">shape.nelements()</a> and <a class="el" href="namespacecasacore.html#a6c80d55c1617e8540e006c12e3dc990c" title="Function operating on any scalar or array resulting in a Double array containing the shape...">array.shape()</a> == shape. The origin of the <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> is zero. Storage is allocated by <code><a class="el" href="classcasacore_1_1DefaultAllocator.html" title="An aligned allocator with the default alignment. ">DefaultAllocator</a>&lt;T&gt;</code>. Without initPolicy parameter, the initialization of elements depends on type <code>T</code>. When <code>T</code> is a fundamental type like <code>int</code>, elements are NOT initialized. When <code>T</code> is a class type like <code>casacore::Complex</code> or <code>std::string</code>, elements are initialized. This inconsistent behavior confuses programmers and make it hard to write efficient and generic code using template. Especially when <code>T</code> is of type <code>Complex</code> or <code>DComplex</code> and it is unnecessary to initialize, provide initPolicy with value <code>NO_INIT</code> to skip the initialization. Therefore, it is strongly recommended to explicitly provide initPolicy parameter, </p>

</div>
</div>
<a class="anchor" id="a91bd21afe5a7cefde26d5dfd2afb43d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1ArrayInitPolicy.html">ArrayInitPolicy</a>&#160;</td>
          <td class="paramname"><em>initPolicy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an array of the given shape, i.e. </p>
<p>after construction <a class="el" href="namespacecasacore.html#a2eb958ed449eb76058df916fa5e3d7e1" title="1-argument function to get the dimensionality of a lattice. ">array.ndim()</a> == <a class="el" href="namespacecasacore.html#adfd652c4018497747cfa235c8fa22bba" title="1-argument function to get the number of elements in a lattice. ">shape.nelements()</a> and <a class="el" href="namespacecasacore.html#a6c80d55c1617e8540e006c12e3dc990c" title="Function operating on any scalar or array resulting in a Double array containing the shape...">array.shape()</a> == shape. The origin of the <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> is zero. Storage is allocated by <code><a class="el" href="classcasacore_1_1DefaultAllocator.html" title="An aligned allocator with the default alignment. ">DefaultAllocator</a>&lt;T&gt;</code>. When initPolicy parameter is <code>INIT</code>, elements are initialized with the default value of <code>T()</code>. When initPolicy parameter is <code>NO_INIT</code>, elements are NOT initialized and programmers are responsible to initialize elements before they are referred, especially when <code>T</code> is such type like <code>std::string</code>. </p>
<div class="fragment"><div class="line">IPosition <a class="code" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>(1, 10);</div>
<div class="line">Array&lt;Int&gt; ai(shape, <a class="code" href="structcasacore_1_1ArrayInitPolicies.html#a054537161fe4b86d81f1a11aba453cc8">ArrayInitPolicies::NO_INIT</a>);</div>
<div class="line"><span class="keywordtype">size_t</span> nread = fread(ai.data(), <span class="keyword">sizeof</span>(<a class="code" href="namespacecasacore.html#abb6e2c1bac472ca1ebadadf96cc8426f">Int</a>), ai.nelements(), fp);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a466c3cc776cf7e71d3de7907857d00d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initialValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an array of the given shape and initialize it with the initial value. </p>
<p>Storage is allocated by <code><a class="el" href="classcasacore_1_1DefaultAllocator.html" title="An aligned allocator with the default alignment. ">DefaultAllocator</a>&lt;T&gt;</code>. </p>

</div>
</div>
<a class="anchor" id="ab89e9bbc0c48f2140a44848c919d50e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After construction, this and other reference the same storage. </p>

</div>
</div>
<a class="anchor" id="a1a3fbd04b2dcb3f3db853d7b0160e3e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Arrays__module.html#ga44401e80192e152e570fc445a95f534b">StorageInitPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="group__Arrays__module.html#gga44401e80192e152e570fc445a95f534ba46b2e4579af5e1f449bb55cfd9f1c9bc">COPY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> of a given shape from a pointer. </p>
<p>If <code>policy</code> is <code>COPY</code>, storage of a new copy is allocated by <code><a class="el" href="classcasacore_1_1DefaultAllocator.html" title="An aligned allocator with the default alignment. ">DefaultAllocator</a>&lt;T&gt;</code>. If <code>policy</code> is <code>TAKE_OVER</code>, <code>storage</code> will be destructed and released by <code><a class="el" href="classcasacore_1_1NewDelAllocator.html" title="An allocator behaves like operator new[]/delete[]. ">NewDelAllocator</a>&lt;T&gt;</code>. It is strongly recommended to supply an appropriate <code>allocator</code> argument explicitly whenever <code>policy</code> == <code>TAKE_OVER</code> to let <code><a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a></code> to know how to release the <code>storage</code>. </p>

</div>
</div>
<a class="anchor" id="ad772865a89355fef5c1b1a6c54052271"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Arrays__module.html#ga44401e80192e152e570fc445a95f534b">StorageInitPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1AbstractAllocator.html">AbstractAllocator</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> of a given shape from a pointer. </p>
<p>If <code>policy</code> is <code>COPY</code>, storage of a new copy is allocated by the specified allocator. If <code>policy</code> is <code>TAKE_OVER</code>, <code>storage</code> will be destructed and released by the specified allocator. Otherwise, <code>allocator</code> is ignored. It is strongly recommended to allocate and initialize <code>storage</code> with <code><a class="el" href="classcasacore_1_1DefaultAllocator.html" title="An aligned allocator with the default alignment. ">DefaultAllocator</a>&lt;T&gt;</code> rather than new[] or <code><a class="el" href="classcasacore_1_1NewDelAllocator.html" title="An allocator behaves like operator new[]/delete[]. ">NewDelAllocator</a>&lt;T&gt;</code> because new[] can't decouple allocation and initialization. <code><a class="el" href="classcasacore_1_1DefaultAllocator.html" title="An aligned allocator with the default alignment. ">DefaultAllocator</a>&lt;T&gt;</code> is a subclass of std::allocator. You can allocate <code>storage</code> via the allocator as below. </p>
<div class="fragment"><div class="line">FILE *fp =...;</div>
<div class="line"><span class="keyword">typedef</span> DefaultAllocator&lt;Int&gt; Alloc;</div>
<div class="line">Alloc::type alloc;</div>
<div class="line">IPosition <a class="code" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>(1, 10);</div>
<div class="line"><a class="code" href="namespacecasacore.html#abb6e2c1bac472ca1ebadadf96cc8426f">Int</a> *ptr = alloc.allocate(shape.product());</div>
<div class="line"><span class="keywordtype">size_t</span> nread = fread(ptr, <span class="keyword">sizeof</span>(<a class="code" href="namespacecasacore.html#abb6e2c1bac472ca1ebadadf96cc8426f">Int</a>), shape.product(), fp);</div>
<div class="line">Array&lt;Int&gt; ai(shape, ptr, <a class="code" href="group__Arrays__module.html#gga44401e80192e152e570fc445a95f534babd142c8c0fe4378c955bf07646a218de">TAKE_OVER</a>, <a class="code" href="namespacecasacore.html#ac188f9709620e307c2f721d6bc43607f">Alloc::value</a>);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a18fbe516a9c57a7883d929717e29de07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> of a given shape from a pointer. </p>
<p>Because the pointer is const, a copy is always made. The copy is allocated by <code><a class="el" href="classcasacore_1_1DefaultAllocator.html" title="An aligned allocator with the default alignment. ">DefaultAllocator</a>&lt;T&gt;</code>. </p>

</div>
</div>
<a class="anchor" id="a76b39f39dfe91c8c17970a3552716c6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::~<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees up storage only if this array was the last reference to it. </p>

</div>
</div>
<a class="anchor" id="a2d59506fd7519daf172bf61d97c912e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcasacore_1_1Allocator__private_1_1AllocSpec.html">Allocator_private::AllocSpec</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2724b1b80df6302b787cf8bdf6ad5069"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::<a class="el" href="classcasacore_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1ArrayInitPolicy.html">ArrayInitPolicy</a>&#160;</td>
          <td class="paramname"><em>initPolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcasacore_1_1Allocator__private_1_1BulkAllocator.html">Allocator_private::BulkAllocator</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adc6babfe2cc4f73266221f89dcb44bee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::addDegenerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a>&#160;</td>
          <td class="paramname"><em>numAxes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This member function returns an <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> reference with the specified number of extra axes, all of length one, appended to the end of the <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a>. </p>
<p>Note that the <code>reform</code> function can also be used to add extra axes. </p>

</div>
</div>
<a class="anchor" id="a3ae63ef4e985df2824007d508d533b9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::addDegenerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a>&#160;</td>
          <td class="paramname"><em>numAxes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4132a776f32afde01796adeacb3854e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::adjustLastAxis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>newShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a>&#160;</td>
          <td class="paramname"><em>resizePercentage</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resizeIfNeeded</em> = <code><a class="el" href="namespacecasacore.html#ad5c850f9e177173e0f7d0ad57091501d">True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this method to extend or reduce the last dimension of an array. </p>
<p>If sufficient excess capacity exists then the bookkeeping is adjusted to support the new shape. If insufficient storage exists then a new array is allocated (unless resizeIfNeeded is false; then an exception is thrown). If resizing is not required then the data remains untouched; if resizing is required then the data is copied into the new storage. The resizePercentage works the same as for reformOrResize (see above). This method never releases extra storage; use "resize" to do this. <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> may not be sharing storage with another array at call time; an exception will be thrown if the array is shared. Returns true if the array was extension required a <a class="el" href="classcasacore_1_1Array.html#a2553c2d285cd9ad504bb9fefd5398136" title="Make this array a different shape. ">Array&lt;T&gt;::resize</a> operation. </p>

</div>
</div>
<a class="anchor" id="ad3b91653a1fc412334e8d25ba1c02b53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">T(*)(T)&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the function to every element of the array. </p>
<p>This modifies the array in place.</p>
<p>This version takes a function which takes a T and returns a T. </p>

</div>
</div>
<a class="anchor" id="a4e9ffbd7aee081b184714d2e1a4bcffb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">T(*)(const T &amp;)&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version takes a function which takes a const T reference and returns a T. </p>

</div>
</div>
<a class="anchor" id="a84301685e214874f2da0b1399a01e46a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Functional.html">Functional</a>&lt; T, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version applies a functional. </p>

</div>
</div>
<a class="anchor" id="a0b8a40e02af1ef593ee2a0a2cc902d4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the other array to this array. </p>
<p>If the shapes mismatch, this array is resized. </p>

<p>Reimplemented in <a class="el" href="classcasacore_1_1Vector.html#a1e55be755a236cdc8faaebd27adcd6fc">casacore::Vector&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a1e55be755a236cdc8faaebd27adcd6fc">casacore::Vector&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a1e55be755a236cdc8faaebd27adcd6fc">casacore::Vector&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a1e55be755a236cdc8faaebd27adcd6fc">casacore::Vector&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a1e55be755a236cdc8faaebd27adcd6fc">casacore::Vector&lt; Int64 &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a1e55be755a236cdc8faaebd27adcd6fc">casacore::Vector&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a1e55be755a236cdc8faaebd27adcd6fc">casacore::Vector&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a1e55be755a236cdc8faaebd27adcd6fc">casacore::Vector&lt; casacore::String &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#ace2f791273dd634d80c7b1755230d78d">casacore::Matrix&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#ace2f791273dd634d80c7b1755230d78d">casacore::Matrix&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#ace2f791273dd634d80c7b1755230d78d">casacore::Matrix&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#ace2f791273dd634d80c7b1755230d78d">casacore::Matrix&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#ace2f791273dd634d80c7b1755230d78d">casacore::Matrix&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#ace2f791273dd634d80c7b1755230d78d">casacore::Matrix&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#ace2f791273dd634d80c7b1755230d78d">casacore::Matrix&lt; Complex &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#acb333e4a8a60562afe29b9e58c1ea7cb">casacore::Cube&lt; T &gt;</a>, and <a class="el" href="classcasacore_1_1Cube.html#acb333e4a8a60562afe29b9e58c1ea7cb">casacore::Cube&lt; Double &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7d1f40ef57bf36fed3c1324058e480fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::assignBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td>
          <td class="paramname"><em>checkType</em> = <code><a class="el" href="namespacecasacore.html#ad5c850f9e177173e0f7d0ad57091501d">True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the source array to this array. </p>
<p>If <code>checkType==True</code>, it is checked if the underlying template types match. Otherwise, it is only checked in debug mode (for performance). <br/>
The default implementation in <a class="el" href="classcasacore_1_1ArrayBase.html" title="Non-templated base class for templated Array class. ">ArrayBase</a> throws an exception. </p>

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#a200db9e682c4ee343b4e816719626f70">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="a29c4632d120dfa99fd2c3549593feb67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html#a01b61adef85b4fd63f94ef41b89a486c">iterator</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the begin iterator object for any array. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00856">856</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="MArrayLogical_8h_source.html#l00302">casacore::MArrayLogical_global_functions_MArray_logical_operations::allEQ()</a>, <a class="el" href="MArrayLogical_8h_source.html#l00339">casacore::MArrayLogical_global_functions_MArray_logical_operations::anyEQ()</a>, <a class="el" href="ArrayMath_8h_source.html#l00192">casacore::ArrayMath_global_functions_Array_mathematical_operations::arrayContTransform()</a>, <a class="el" href="ArrayMath_8h_source.html#l00307">casacore::ArrayMath_global_functions_Array_mathematical_operations::arrayTransformInPlace()</a>, <a class="el" href="MArrayMath_8h_source.html#l00811">casacore::MArrayMath_global_functions_MArray_mathematical_operations::avdev()</a>, <a class="el" href="PycBasicData_8h_source.html#l00323">casacore::python::to_list&lt; casacore::Array&lt; casacore::String &gt; &gt;::makeobject()</a>, <a class="el" href="PycBasicData_8h_source.html#l00342">casacore::python::to_list&lt; casacore::Vector&lt; casacore::String &gt; &gt;::makeobject()</a>, <a class="el" href="MArrayMath_8h_source.html#l00757">casacore::MArrayMath_global_functions_MArray_mathematical_operations::max()</a>, <a class="el" href="MArrayMath_8h_source.html#l00744">casacore::MArrayMath_global_functions_MArray_mathematical_operations::min()</a>, <a class="el" href="MArrayLogical_8h_source.html#l00396">casacore::MArrayLogical_global_functions_MArray_logical_operations::nfalse()</a>, <a class="el" href="MArrayLogical_8h_source.html#l00382">casacore::MArrayLogical_global_functions_MArray_logical_operations::ntrue()</a>, <a class="el" href="MArrayMath_8h_source.html#l00731">casacore::MArrayMath_global_functions_MArray_mathematical_operations::product()</a>, <a class="el" href="MArrayMath_8h_source.html#l00831">casacore::MArrayMath_global_functions_MArray_mathematical_operations::rms()</a>, <a class="el" href="MArrayMath_8h_source.html#l00705">casacore::MArrayMath_global_functions_MArray_mathematical_operations::sum()</a>, <a class="el" href="MArrayMath_8h_source.html#l00718">casacore::MArrayMath_global_functions_MArray_mathematical_operations::sumsqr()</a>, and <a class="el" href="MArrayMath_8h_source.html#l00779">casacore::MArrayMath_global_functions_MArray_mathematical_operations::variance()</a>.</p>

</div>
</div>
<a class="anchor" id="a2df864540fcaf43159f29d20db414e0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html#a3d3bc7f293b55248806467f721b12177">const_iterator</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00858">858</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="af7a14e5d098fa3067b7161e757a01873"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements allocated. </p>
<p>This value is &gt;= to the value returned by <a class="el" href="classcasacore_1_1ArrayBase.html#ad7934dab73a7952f9fbfb7a887efbe34">size()</a>. </p>

</div>
</div>
<a class="anchor" id="a40af0ed02d935164404ae293f0cb2fe0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html#a43502f18c6ff10f1702a8d1fbe2c5de8">contiter</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the begin iterator object for a contiguous array. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00868">868</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="ArrayMath_8h_source.html#l00192">casacore::ArrayMath_global_functions_Array_mathematical_operations::arrayContTransform()</a>, <a class="el" href="ArrayMath_8h_source.html#l00307">casacore::ArrayMath_global_functions_Array_mathematical_operations::arrayTransformInPlace()</a>, <a class="el" href="MArrayMath_8h_source.html#l00811">casacore::MArrayMath_global_functions_MArray_mathematical_operations::avdev()</a>, <a class="el" href="MArrayMath_8h_source.html#l00757">casacore::MArrayMath_global_functions_MArray_mathematical_operations::max()</a>, <a class="el" href="MArrayMath_8h_source.html#l00744">casacore::MArrayMath_global_functions_MArray_mathematical_operations::min()</a>, <a class="el" href="MArrayLogical_8h_source.html#l00396">casacore::MArrayLogical_global_functions_MArray_logical_operations::nfalse()</a>, <a class="el" href="MArrayLogical_8h_source.html#l00382">casacore::MArrayLogical_global_functions_MArray_logical_operations::ntrue()</a>, <a class="el" href="MArrayMath_8h_source.html#l00731">casacore::MArrayMath_global_functions_MArray_mathematical_operations::product()</a>, <a class="el" href="MArrayMath_8h_source.html#l00831">casacore::MArrayMath_global_functions_MArray_mathematical_operations::rms()</a>, <a class="el" href="MArrayMath_8h_source.html#l00705">casacore::MArrayMath_global_functions_MArray_mathematical_operations::sum()</a>, <a class="el" href="MArrayMath_8h_source.html#l00718">casacore::MArrayMath_global_functions_MArray_mathematical_operations::sumsqr()</a>, and <a class="el" href="MArrayMath_8h_source.html#l00779">casacore::MArrayMath_global_functions_MArray_mathematical_operations::variance()</a>.</p>

</div>
</div>
<a class="anchor" id="acacf4d9240b152727e11a5303aa871ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html#a2f9b042a8e96ffdea465babce2068de2">const_contiter</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00870">870</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a303e2200ab006fbdcb742ce8c3f1411d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html#a43502f18c6ff10f1702a8d1fbe2c5de8">contiter</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00872">872</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="ArrayMath_8h_source.html#l00192">casacore::ArrayMath_global_functions_Array_mathematical_operations::arrayContTransform()</a>, and <a class="el" href="ArrayMath_8h_source.html#l00307">casacore::ArrayMath_global_functions_Array_mathematical_operations::arrayTransformInPlace()</a>.</p>

</div>
</div>
<a class="anchor" id="aacdb0b458d5a85ac1e019c0ebc357689"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html#a2f9b042a8e96ffdea465babce2068de2">const_contiter</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00874">874</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a93760dbeebff999483b5f4a12d38d9f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::conform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are the shapes identical? </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00589">589</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8af3693fc95174edc9584fa6c926f3b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::conform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a903c81abde2a3fa8a6eb175d25d7fa13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1ArrayInitPolicy.html">ArrayInitPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="structcasacore_1_1ArrayInitPolicies.html#a054537161fe4b86d81f1a11aba453cc8">ArrayInitPolicies::NO_INIT</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This makes a copy of the array and returns it. </p>
<p>This can be useful for, e.g. making working copies of function arguments that you can write into. </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> someFunction(<span class="keyword">const</span> Array&lt;Int&gt; &amp;<a class="code" href="namespacecasacore.html#a494b4a782704d3ce544c6cbaeb786a57">arg</a>)</div>
<div class="line">{</div>
<div class="line">Array&lt;Int&gt; tmp(arg.copy());</div>
<div class="line"><span class="comment">//..\.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that since the copy constructor makes a reference, if we just created used to copy constructor, modifying "tmp" would also modify "arg". Clearly another alternative would simply be: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> someFunction(<span class="keyword">const</span> Array&lt;Int&gt; &amp;arg)</div>
<div class="line">{</div>
<div class="line">Array&lt;Int&gt; tmp;</div>
<div class="line">tmp = <a class="code" href="namespacecasacore.html#a494b4a782704d3ce544c6cbaeb786a57">arg</a>;</div>
<div class="line"><span class="comment">//..\.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> which likely would be simpler to understand. (Should <a class="el" href="classcasacore_1_1Array.html#a903c81abde2a3fa8a6eb175d25d7fa13" title="This makes a copy of the array and returns it. ">copy()</a> be deprecated and removed?) </p>

</div>
</div>
<a class="anchor" id="a17768bf9121c91bc1f8dd93c04c5da78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1ArrayInitPolicy.html">ArrayInitPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcasacore_1_1Allocator__private_1_1BulkAllocator.html">Allocator_private::BulkAllocator</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a copy using the allocator. </p>

</div>
</div>
<a class="anchor" id="ad3fb387d33b6a9fe6e33e5fde2dd5055"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::copyMatchingPart </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function copies the matching part of from array to this array. </p>
<p>The matching part is the part with the minimum size for each axis. E.g. if this array has shape [4,5,6] and from array has shape [7,3], the matching part has shape [4,3]. <br/>
Note it is used by the resize function if <code>copyValues==True</code>. </p>

</div>
</div>
<a class="anchor" id="a638e5676067af72eaf21ccda708263f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::copyToContiguousStorage </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1ArrayInitPolicy.html">ArrayInitPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a43f2b7438f5620df00610beeebc69b53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the beginning of the array. </p>
<p>Note that the array may not be contiguous. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00597">597</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="ArrayLogical_8h_source.html#l00264">casacore::ArrayLogical_global_functions_Array_logical_operations::allSame()</a>, <a class="el" href="MArrayMath_8h_source.html#l00256">casacore::MArrayMath_global_functions_MArray_mathematical_operations::boxedArrayMath()</a>, <a class="el" href="MArray_8h_source.html#l00184">casacore::MArray&lt; T &gt;::flatten()</a>, <a class="el" href="LSQaips_8h_source.html#l00189">casacore::LSQaips::getErrors()</a>, <a class="el" href="MArrayMath_8h_source.html#l00193">casacore::MArrayMath_global_functions_MArray_mathematical_operations::partialArrayMath()</a>, <a class="el" href="HDF5Record_8h_source.html#l00139">casacore::HDF5Record::readArr()</a>, <a class="el" href="LSQaips_8h_source.html#l00127">casacore::LSQaips::solve()</a>, and <a class="el" href="HDF5Record_8h_source.html#l00192">casacore::HDF5Record::writeArr()</a>.</p>

</div>
</div>
<a class="anchor" id="a750fb1194358e4d6a29d1fbf94589769"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00599">599</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8faaa738eef0bbe03e23cc09568f302a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcasacore_1_1ArrayInitPolicy.html">ArrayInitPolicy</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::defaultArrayInitPolicy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00890">890</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa1708589aff5ad3adf160fa4c37ab1a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::diagonals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a>&#160;</td>
          <td class="paramname"><em>firstAxis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#a79c2dfec4363785472512dbf384675a1">Int64</a>&#160;</td>
          <td class="paramname"><em>diag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the diagonal of each matrix part in the full array. </p>
<p>The matrices are taken using axes firstAxes and firstAxis+1. diag==0 is main diagonal; diag&gt;0 above the main diagonal; diag&lt;0 below. </p>

</div>
</div>
<a class="anchor" id="a91b2937c9796ac9340278c82c7324eed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::doNonDegenerate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>ignoreAxes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the degenerate axes from the <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> object. </p>
<p>This is the implementation of the nonDegenerate functions. It has a different name to be able to make it virtual without having the "hide virtual function" message when compiling derived classes. </p>

<p>Reimplemented in <a class="el" href="classcasacore_1_1Cube.html#a42fc8ed5308e45f7ed0d3ca52d615d1b">casacore::Cube&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#a42fc8ed5308e45f7ed0d3ca52d615d1b">casacore::Cube&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#abc331bbf3f5362cb61978e830a6c77bc">casacore::Matrix&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#abc331bbf3f5362cb61978e830a6c77bc">casacore::Matrix&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#abc331bbf3f5362cb61978e830a6c77bc">casacore::Matrix&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#abc331bbf3f5362cb61978e830a6c77bc">casacore::Matrix&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#abc331bbf3f5362cb61978e830a6c77bc">casacore::Matrix&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#abc331bbf3f5362cb61978e830a6c77bc">casacore::Matrix&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#abc331bbf3f5362cb61978e830a6c77bc">casacore::Matrix&lt; Complex &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a8f7273863e46597f631377d8e81f0cb7">casacore::Vector&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a8f7273863e46597f631377d8e81f0cb7">casacore::Vector&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a8f7273863e46597f631377d8e81f0cb7">casacore::Vector&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a8f7273863e46597f631377d8e81f0cb7">casacore::Vector&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a8f7273863e46597f631377d8e81f0cb7">casacore::Vector&lt; Int64 &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a8f7273863e46597f631377d8e81f0cb7">casacore::Vector&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a8f7273863e46597f631377d8e81f0cb7">casacore::Vector&lt; Bool &gt;</a>, and <a class="el" href="classcasacore_1_1Vector.html#a8f7273863e46597f631377d8e81f0cb7">casacore::Vector&lt; casacore::String &gt;</a>.</p>

<p>Referenced by <a class="el" href="Array_8h_source.html#l00469">casacore::Array&lt; casacore::String &gt;::nonDegenerate()</a>.</p>

</div>
</div>
<a class="anchor" id="ad40f8c12830ed55a35c7d2e7a5fc24e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html#a01b61adef85b4fd63f94ef41b89a486c">iterator</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00860">860</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="ArrayMath_8h_source.html#l00192">casacore::ArrayMath_global_functions_Array_mathematical_operations::arrayContTransform()</a>, <a class="el" href="ArrayMath_8h_source.html#l00307">casacore::ArrayMath_global_functions_Array_mathematical_operations::arrayTransformInPlace()</a>, <a class="el" href="PycBasicData_8h_source.html#l00323">casacore::python::to_list&lt; casacore::Array&lt; casacore::String &gt; &gt;::makeobject()</a>, and <a class="el" href="PycBasicData_8h_source.html#l00342">casacore::python::to_list&lt; casacore::Vector&lt; casacore::String &gt; &gt;::makeobject()</a>.</p>

</div>
</div>
<a class="anchor" id="a289997221953945e421eda3f43cd3d0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html#a3d3bc7f293b55248806467f721b12177">const_iterator</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00862">862</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5e125859a0f23cca72cc6baef8bdb8aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::freeStorage </td>
          <td>(</td>
          <td class="paramtype">const T *&amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td>
          <td class="paramname"><em>deleteIt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If deleteIt is set, delete "storage". </p>
<p>Normally freeStorage calls will follow calls to getStorage. The reason the pointer is "const" is because only const pointers are released from const arrays. The "storage" pointer is set to zero. </p>

</div>
</div>
<a class="anchor" id="afc3bc758294efb89bd9a01883738c93d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::freeVStorage </td>
          <td>(</td>
          <td class="paramtype">const void *&amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td>
          <td class="paramname"><em>deleteIt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#ad7039cd4dc1800240cb1fe15ee62d759">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="ab448c3e82ee0f8742ce1b4530b9d0aa6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcasacore_1_1CountedPtr.html">CountedPtr</a>&lt;<a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a>&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::getSection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Slicer.html">Slicer</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to a section of an array. </p>
<p>This is the same as operator(), but can be used in a type-agnostic way. </p>

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#a49fab0fffe5f2cd085b64c9f0a90cb41">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="ad8d20771ba5c91f64f73c6920796e15b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::getStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> &amp;&#160;</td>
          <td class="paramname"><em>deleteIt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generally use of this should be shunned, except to use a FORTRAN routine or something similar. </p>
<p>Because you can't know the state of the underlying data layout (in particular, if there are increments) sometimes the pointer returned will be to a copy, but often this won't be necessary. A boolean is returned which tells you if this is a copy (and hence the storage must be deleted). Note that if you don't do anything unusual, getStorage followed by freeStorage or putStorage will do the deletion for you (if required). e.g.: </p>
<div class="fragment"><div class="line">Array&lt;Int&gt; a(shape);..\.</div>
<div class="line">Bool deleteIt; <a class="code" href="namespacecasacore.html#abb6e2c1bac472ca1ebadadf96cc8426f">Int</a> *storage = a.getStorage(deleteIt);</div>
<div class="line">foo(storage, a.nelements()); a.puStorage(storage, deleteIt);</div>
<div class="line"><span class="comment">// or a.freeStorage(storage, deleteIt) if a is const.</span></div>
</div><!-- fragment --><p> NB: However, if you only use getStorage, you will have to delete the pointer yourself using <a class="el" href="classcasacore_1_1Array.html#a5e125859a0f23cca72cc6baef8bdb8aa" title="If deleteIt is set, delete &quot;storage&quot;. ">freeStorage()</a>.</p>
<p>It would probably be useful to have corresponding "copyin" "copyout" functions that used a user supplied buffer. Note that deleteIt is set in this function. </p>

<p>Referenced by <a class="el" href="Array_8h_source.html#l00625">casacore::Array&lt; casacore::String &gt;::getStorage()</a>.</p>

</div>
</div>
<a class="anchor" id="ae273f4cde002a53cddceabbc416bdccd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::getStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> &amp;&#160;</td>
          <td class="paramname"><em>deleteIt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The cast is OK because the return pointer will be cast to const </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00625">625</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="af8bd2a608f0993b591b3be50cbfc59d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::getVStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> &amp;&#160;</td>
          <td class="paramname"><em>deleteIt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The following functions behave the same as the corresponding getStorage functions in the derived templated <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> class. </p>
<p>They handle a pointer to a contiguous block of array data. If the array is not contiguous, a copy is used to make it contiguous. </p>

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#ae871541dfd87969ddcd1f98006602574">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="a57e7bacdcc17c178d821fda60c695c10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const void* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::getVStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> &amp;&#160;</td>
          <td class="paramname"><em>deleteIt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#ae692bf148f779d25c0a0f5c24263cdec">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="a113a6ddf2cffe1cd2c5c053fe6898b60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcasacore_1_1CountedPtr.html">CountedPtr</a>&lt;<a class="el" href="classcasacore_1_1ArrayBase.html">ArrayBase</a>&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::makeArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an empty array of the same template type. </p>

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#a5ac4d4b2f62b23c87665fc1728db3357">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="af2a61213c596587d4a6257f7e95f8a0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcasacore_1_1CountedPtr.html">CountedPtr</a>&lt;<a class="el" href="classcasacore_1_1ArrayPositionIterator.html">ArrayPositionIterator</a>&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::makeIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a>&#160;</td>
          <td class="paramname"><em>byDim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classcasacore_1_1ArrayIterator.html" title="Iterate an Array cursor through another Array. ">ArrayIterator</a> object of the correct type. </p>

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#af029d1108555b67d12c64f8bc2df29cf">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="a5b50299d3cb42b3c2060ad0cb8a52e6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::makeSteps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the steps and the end for a derived class. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00920">920</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2052b6c9055542b4658a7ee566fb7df3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::nonDegenerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a>&#160;</td>
          <td class="paramname"><em>startingAxis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td>
          <td class="paramname"><em>throwIfError</em> = <code><a class="el" href="namespacecasacore.html#ad5c850f9e177173e0f7d0ad57091501d">True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These member functions remove degenerate (ie. </p>
<p>length==1) axes from Arrays. Only axes greater than startingAxis are considered (normally one wants to remove trailing axes). The first two of these functions return an <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> reference with axes removed. The latter two functions let this <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> object reference the 'other' array with degenerated axes removed. <br/>
 Unless throwIfError is False, an exception will be thrown if startingAxis exceeds the array's dimensionality. <br/>
 The functions with argument <code>ignoreAxes</code> do not consider the axes given in that argument. In this way it can be achieved that degenerate axes are kept. <br/>
<b>Caution:</b><em> When the two functions returning <code>void</code> are invoked on a derived object (e;g; <a class="el" href="classcasacore_1_1Matrix.html" title="A 2-D Specialization of the Array class. ">Matrix</a>), an exception is thrown if removing the degenerate axes from other does not result in a correct number of axes; </em><br/>
 </p>

</div>
</div>
<a class="anchor" id="a40080fab3132561a599c7f1e0376a820"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::nonDegenerate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>ignoreAxes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a29f6e893c0ecbd8e62fc2f496a164146"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::nonDegenerate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a>&#160;</td>
          <td class="paramname"><em>startingAxis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td>
          <td class="paramname"><em>throwIfError</em> = <code><a class="el" href="namespacecasacore.html#ad5c850f9e177173e0f7d0ad57091501d">True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b27b4cc852373ab6f6fc2325815d67b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::nonDegenerate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>ignoreAxes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Array_8h_source.html#l00469">469</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1eb55fb754d831ca293c898bc5d5b505"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcasacore_1_1Allocator__private_1_1BulkAllocator.html">Allocator_private::BulkAllocator</a>&lt;T&gt;* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::nonNewDelAllocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the current allocator is NewDelAllocator&lt;T&gt;, BulkAllocator for DefaultAllocator&lt;T&gt; is returned, otherwise BulkAllocator for the current allocator is returned. </p>

</div>
</div>
<a class="anchor" id="aaf33c3457f1097ac0e0da72aaba46ead"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::nrefs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of references the underlying storage has assigned to it. </p>
<p>It is 1 unless there are outstanding references to the storage (e.g., through a slice). Normally you have no need to do this since the arrays handle all of the references for you. </p>

</div>
</div>
<a class="anchor" id="a47f26d4be19d73025b3c953763631793"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::ok </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check to see if the <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> is consistent. </p>
<p>This is about the same thing as checking for invariants. If AIPS_DEBUG is defined, this is invoked after construction and on entry to most member functions. </p>

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#ab34c9751077f238a4005f97b51ba852b">casacore::ArrayBase</a>.</p>

<p>Reimplemented in <a class="el" href="classcasacore_1_1Cube.html#aba36eff5d0af29ff797aecac1dedab27">casacore::Cube&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#aba36eff5d0af29ff797aecac1dedab27">casacore::Cube&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#aba36eff5d0af29ff797aecac1dedab27">casacore::Cube&lt; casacore::RigidVector&lt; Double, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a2baac6a60ccf8e5461cc4da55b9c6fae">casacore::Matrix&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a2baac6a60ccf8e5461cc4da55b9c6fae">casacore::Matrix&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a2baac6a60ccf8e5461cc4da55b9c6fae">casacore::Matrix&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a2baac6a60ccf8e5461cc4da55b9c6fae">casacore::Matrix&lt; casacore::GaussianBeam &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a2baac6a60ccf8e5461cc4da55b9c6fae">casacore::Matrix&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a2baac6a60ccf8e5461cc4da55b9c6fae">casacore::Matrix&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a2baac6a60ccf8e5461cc4da55b9c6fae">casacore::Matrix&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a2baac6a60ccf8e5461cc4da55b9c6fae">casacore::Matrix&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a2baac6a60ccf8e5461cc4da55b9c6fae">casacore::Matrix&lt; Complex &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; casacore::MPosition &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; casacore::AutoDiff&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; casacore::Quantum &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; casacore::Vector&lt; Range &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; AutoDiff&lt; T &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; casacore::Unit &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; Int64 &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; casacore::MDirection &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; casacore::MFrequency &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; casacore::RORecordFieldPtr&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; AutoDiffA&lt; T &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; Type &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; casacore::Slicer * &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; casacore::MeasComet * &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; casacore::Quantum&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; uInt &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; Domain &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; casacore::String &gt;</a>, and <a class="el" href="classcasacore_1_1Vector.html#abb7bfba7a0982695e834373d21aea66a">casacore::Vector&lt; ArgType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1dc6100c12c9ef15752d40d5b14663aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a single element of the array. </p>
<p>This is relatively expensive. Extensive indexing should be done through one of the <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> specializations (<a class="el" href="classcasacore_1_1Vector.html" title="A 1-D Specialization of the Array class. ">Vector</a>, <a class="el" href="classcasacore_1_1Matrix.html" title="A 2-D Specialization of the Array class. ">Matrix</a>, <a class="el" href="classcasacore_1_1Cube.html" title="A 3-D Specialization of the Array class. ">Cube</a>). If AIPS_DEBUG is defined, index checking will be performed. </p>

<p>Referenced by <a class="el" href="Cube_8h_source.html#l00170">casacore::Cube&lt; casacore::RigidVector&lt; Double, 2 &gt; &gt;::operator()()</a>, <a class="el" href="Matrix_8h_source.html#l00186">casacore::Matrix&lt; Complex &gt;::operator()()</a>, and <a class="el" href="Vector_8h_source.html#l00207">casacore::Vector&lt; ArgType &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a1d2187c435a64c63a7b9caa92889d1ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4b66a755ee54dacaa33f2eb1e3bf520"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to an array section extending from start to end (inclusive). </p>

</div>
</div>
<a class="anchor" id="a580418b8bb7187c932c3fa5343cda0aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2b1344333c735857a91213ca9f97a3b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>inc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Along the ith axis, every inc[i]'th element is chosen. </p>

</div>
</div>
<a class="anchor" id="a80e2b72d291af446829fe8c949d0af1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>inc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af825a7cefd9142d6ad86e0ea798494d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Slicer.html">Slicer</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to an array section using a <a class="el" href="classcasacore_1_1Slicer.html" title="Specify which elements to extract from an n-dimensional array. ">Slicer</a>. </p>

</div>
</div>
<a class="anchor" id="a0c3ea7c6f8061cf7ce10464b7780787a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Slicer.html">Slicer</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a4aaa73131f1bb2fe780ee4c6f69d3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const LogicalArray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The array is masked by the input LogicalArray. </p>
<p>This mask must conform to the array. </p>

</div>
</div>
<a class="anchor" id="a8bb23ee71849cebe7c526c5ae70322cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const LogicalArray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c71912a00ba77226806173bcbce0427"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const MaskedLogicalArray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The array is masked by the input MaskedLogicalArray. </p>
<p>The mask is effectively the AND of the internal LogicalArray and the internal mask of the MaskedLogicalArray. The MaskedLogicalArray must conform to the array. </p>

</div>
</div>
<a class="anchor" id="ac7c84f9ca0005362dc30039325bf2a46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const MaskedLogicalArray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aef46ed4a47d84d5207f112c0acfe2b42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt;&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the values in other to this. </p>
<p>If the array on the left hand side has no elements, then it is resized to be the same size as as the array on the right hand side. Otherwise, the arrays must conform (same shapes). </p>
<div class="fragment"><div class="line">IPosition <a class="code" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>(2,10,10);     <span class="comment">// some shape</span></div>
<div class="line">Array&lt;Double&gt; ad(shape);</div>
<div class="line"><span class="comment">//..\.</span></div>
<div class="line">Array&lt;Double&gt; ad2;            <span class="comment">// N.B. ad2.nelements() == 0</span></div>
<div class="line">ad2 = ad;                     <span class="comment">// ad2 resizes, then elements</span></div>
<div class="line"><span class="comment">//     are copied.</span></div>
<div class="line">shape = 20;</div>
<div class="line">Array&lt;Double&gt; ad3(shape);</div>
<div class="line">ad3 = ad;                     <span class="comment">// Error: arrays do not conform</span></div>
</div><!-- fragment --><p> Note that the assign function can be used to assign a non-conforming array. </p>

<p>Reimplemented in <a class="el" href="classcasacore_1_1Vector.html#a19e7731cdd1b90c4c40236951aea5dce">casacore::Vector&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a19e7731cdd1b90c4c40236951aea5dce">casacore::Vector&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a19e7731cdd1b90c4c40236951aea5dce">casacore::Vector&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a19e7731cdd1b90c4c40236951aea5dce">casacore::Vector&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a19e7731cdd1b90c4c40236951aea5dce">casacore::Vector&lt; Int64 &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a19e7731cdd1b90c4c40236951aea5dce">casacore::Vector&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a19e7731cdd1b90c4c40236951aea5dce">casacore::Vector&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a19e7731cdd1b90c4c40236951aea5dce">casacore::Vector&lt; casacore::String &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a93acb70ac9e163d3da3e56eecd445477">casacore::Matrix&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a93acb70ac9e163d3da3e56eecd445477">casacore::Matrix&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a93acb70ac9e163d3da3e56eecd445477">casacore::Matrix&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a93acb70ac9e163d3da3e56eecd445477">casacore::Matrix&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a93acb70ac9e163d3da3e56eecd445477">casacore::Matrix&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a93acb70ac9e163d3da3e56eecd445477">casacore::Matrix&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a93acb70ac9e163d3da3e56eecd445477">casacore::Matrix&lt; Complex &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#ade166fd7fb5f3d75acb18c0f24ea5c83">casacore::Cube&lt; T &gt;</a>, and <a class="el" href="classcasacore_1_1Cube.html#ade166fd7fb5f3d75acb18c0f24ea5c83">casacore::Cube&lt; Double &gt;</a>.</p>

<p>Referenced by <a class="el" href="Cube_8h_source.html#l00158">casacore::Cube&lt; casacore::RigidVector&lt; Double, 2 &gt; &gt;::operator=()</a>, <a class="el" href="Matrix_8h_source.html#l00174">casacore::Matrix&lt; Complex &gt;::operator=()</a>, and <a class="el" href="Vector_8h_source.html#l00187">casacore::Vector&lt; ArgType &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="afa79567b18d4d7635bbbd700cf57ebbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt;&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set every element of this array to "value". </p>
<p>In other words, a scalar behaves as if it were a constant conformant array. </p>

</div>
</div>
<a class="anchor" id="a833f0646ac4bfdb1f992c2c582bf5b92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt;&amp; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1MaskedArray.html">MaskedArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>marray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy to this those values in marray whose corresponding elements in marray's mask are True. </p>
<h3>Thrown Exceptions</h3>
<ul>
<li>
<a class="el" href="classcasacore_1_1ArrayConformanceError.html" title="An error thrown when two arrays do not conform. ">ArrayConformanceError</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ab6053a0385ae1e91ab5db7f590441673"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the subset given by the i-th value of the last axis. </p>
<p>So for a cube it returns the i-th xy plane. For a <a class="el" href="classcasacore_1_1Matrix.html" title="A 2-D Specialization of the Array class. ">Matrix</a> it returns the i-th row. The returned array references the original array data; its dimensionality is one less. For a 1-dim array it still returns a 1-dim array. <br/>
<b>Note:</b><em> This function should not be used in tight loops as it is (much) slower than iterating using <a class="el" href="classcasacore_1_1Array.html#a29c4632d120dfa99fd2c3549593feb67" title="Get the begin iterator object for any array. ">begin()</a> and <a class="el" href="classcasacore_1_1Array.html#ad40f8c12830ed55a35c7d2e7a5fc24e5">end()</a>, ArrayIter, or <a class="el" href="classcasacore_1_1ArrayAccessor.html">ArrayAccessor</a>;</em><br/>
 </p>

</div>
</div>
<a class="anchor" id="a510687a00bfad5e5d5919ea8f16db17b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::postTakeStorage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classcasacore_1_1Cube.html#a0a86efd5bdc9d42684ac4219c31e1237">casacore::Cube&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#a0a86efd5bdc9d42684ac4219c31e1237">casacore::Cube&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#a0a86efd5bdc9d42684ac4219c31e1237">casacore::Cube&lt; casacore::RigidVector&lt; Double, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf9d9200cae8f2f557269cd94a8c3af2">casacore::Matrix&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf9d9200cae8f2f557269cd94a8c3af2">casacore::Matrix&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf9d9200cae8f2f557269cd94a8c3af2">casacore::Matrix&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf9d9200cae8f2f557269cd94a8c3af2">casacore::Matrix&lt; casacore::GaussianBeam &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf9d9200cae8f2f557269cd94a8c3af2">casacore::Matrix&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf9d9200cae8f2f557269cd94a8c3af2">casacore::Matrix&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf9d9200cae8f2f557269cd94a8c3af2">casacore::Matrix&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#acf9d9200cae8f2f557269cd94a8c3af2">casacore::Matrix&lt; Bool &gt;</a>, and <a class="el" href="classcasacore_1_1Matrix.html#acf9d9200cae8f2f557269cd94a8c3af2">casacore::Matrix&lt; Complex &gt;</a>.</p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00895">895</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0b039d8c5e666e8e27506c676a22b129"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::preTakeStorage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pre/post processing hook of <a class="el" href="classcasacore_1_1Array.html#aced59eeb9ed3325380d264f9324254bc" title="Replace the data values with those in the pointer storage. ">takeStorage()</a> for subclasses. </p>

<p>Reimplemented in <a class="el" href="classcasacore_1_1Cube.html#a5c01b789ca58efaa4ae7bbf1b5a6a5f1">casacore::Cube&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#a5c01b789ca58efaa4ae7bbf1b5a6a5f1">casacore::Cube&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#a5c01b789ca58efaa4ae7bbf1b5a6a5f1">casacore::Cube&lt; casacore::RigidVector&lt; Double, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a571a7872c7f3f6fd35cb28fb21fc5651">casacore::Matrix&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a571a7872c7f3f6fd35cb28fb21fc5651">casacore::Matrix&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a571a7872c7f3f6fd35cb28fb21fc5651">casacore::Matrix&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a571a7872c7f3f6fd35cb28fb21fc5651">casacore::Matrix&lt; casacore::GaussianBeam &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a571a7872c7f3f6fd35cb28fb21fc5651">casacore::Matrix&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a571a7872c7f3f6fd35cb28fb21fc5651">casacore::Matrix&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a571a7872c7f3f6fd35cb28fb21fc5651">casacore::Matrix&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a571a7872c7f3f6fd35cb28fb21fc5651">casacore::Matrix&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a571a7872c7f3f6fd35cb28fb21fc5651">casacore::Matrix&lt; Complex &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; casacore::MPosition &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; casacore::AutoDiff&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; casacore::Quantum &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; casacore::Vector&lt; Range &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; AutoDiff&lt; T &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; casacore::Unit &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; Int64 &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; casacore::MDirection &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; casacore::MFrequency &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; casacore::RORecordFieldPtr&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; AutoDiffA&lt; T &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; Type &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; casacore::Slicer * &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; casacore::MeasComet * &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; casacore::Quantum&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; uInt &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; Domain &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; casacore::String &gt;</a>, and <a class="el" href="classcasacore_1_1Vector.html#a9c8c67438bff38bce57f47d4b6a90fd5">casacore::Vector&lt; ArgType &gt;</a>.</p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00894">894</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a27561819689f0bd4085b5146954e0ebf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::putStorage </td>
          <td>(</td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td>
          <td class="paramname"><em>deleteAndCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classcasacore_1_1Array.html#a27561819689f0bd4085b5146954e0ebf" title="putStorage() is normally called after a call to getStorage() (cf). ">putStorage()</a> is normally called after a call to <a class="el" href="classcasacore_1_1Array.html#ad8d20771ba5c91f64f73c6920796e15b" title="Generally use of this should be shunned, except to use a FORTRAN routine or something similar...">getStorage()</a> (cf). </p>
<p>The "storage" pointer is set to zero. </p>

</div>
</div>
<a class="anchor" id="a24cbf081480a6fa6df42911989fff631"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::putVStorage </td>
          <td>(</td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td>
          <td class="paramname"><em>deleteAndCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#a8afff35fd1fc186470374eaefc8cb12c">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="adcfb6bd1f6e0a70dc1c2909739e09d07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::reference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>After invocation, this array and other reference the same storage. </p>
<p>That is, modifying an element through one will show up in the other. The arrays appear to be identical; they have the same shape. <br/>
Please note that this function makes it possible to reference a const <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a>, thus effectively it makes a const <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> non-const. Although this may seem undesirable at first sight, it is necessary to be able to make references to temporary <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> objects, in particular to <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> slices. Otherwise one first needs to use the copy constructor. </p>

<p>Reimplemented in <a class="el" href="classcasacore_1_1Vector.html#a761fdae7f57d1392cf0501785c58c050">casacore::Vector&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a761fdae7f57d1392cf0501785c58c050">casacore::Vector&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a761fdae7f57d1392cf0501785c58c050">casacore::Vector&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a761fdae7f57d1392cf0501785c58c050">casacore::Vector&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a761fdae7f57d1392cf0501785c58c050">casacore::Vector&lt; Int64 &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a761fdae7f57d1392cf0501785c58c050">casacore::Vector&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a761fdae7f57d1392cf0501785c58c050">casacore::Vector&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#a761fdae7f57d1392cf0501785c58c050">casacore::Vector&lt; casacore::String &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#ac718778346fa2655be63625d6a7404b2">casacore::Matrix&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#ac718778346fa2655be63625d6a7404b2">casacore::Matrix&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#ac718778346fa2655be63625d6a7404b2">casacore::Matrix&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#ac718778346fa2655be63625d6a7404b2">casacore::Matrix&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#ac718778346fa2655be63625d6a7404b2">casacore::Matrix&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#ac718778346fa2655be63625d6a7404b2">casacore::Matrix&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#ac718778346fa2655be63625d6a7404b2">casacore::Matrix&lt; Complex &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#aeea2df33623b491d572d3ff89f87f637">casacore::Cube&lt; T &gt;</a>, and <a class="el" href="classcasacore_1_1Cube.html#aeea2df33623b491d572d3ff89f87f637">casacore::Cube&lt; Double &gt;</a>.</p>

<p>Referenced by <a class="el" href="ValueHolder_8h_source.html#l00176">casacore::ValueHolder::getValue()</a>, and <a class="el" href="RecordInterface_8h_source.html#l00429">casacore::RecordInterface::toArray()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb0dc902bbca281026448bffe4393d54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1Array.html">Array</a>&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::reform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is occasionally useful to have an array which access the same storage appear to have a different shape. </p>
<p>For example, turning an N-dimensional array into a <a class="el" href="classcasacore_1_1Vector.html" title="A 1-D Specialization of the Array class. ">Vector</a>. <br/>
When the array data are contiguous, the array can be reshaped to any form as long as the number of elements stays the same. When not contiguous, it is only possible to remove or add axes with length 1. </p>
<div class="fragment"><div class="line">IPosition squareShape(2,5,5);</div>
<div class="line">Array&lt;Float&gt; <a class="code" href="namespacecasacore.html#a81061defb229f93e7422132122ea28c7">square</a>(squareShape);</div>
<div class="line">IPosition lineShape(1,25);</div>
<div class="line">Vector&lt;Float&gt; line(<a class="code" href="namespacecasacore.html#a81061defb229f93e7422132122ea28c7">square</a>.reform(lineShape));</div>
<div class="line"><span class="comment">// &quot;square&quot;&#39;s storage may now be accessed through Vector &quot;line&quot;</span></div>
</div><!-- fragment --> 
<p>Referenced by <a class="el" href="ExprNodeSet_8h_source.html#l00508">casacore::TableExprNodeSet::toArray()</a>.</p>

</div>
</div>
<a class="anchor" id="a8a7191ff9dce3e7592c5302420e68db7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::reformOrResize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>newShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a>&#160;</td>
          <td class="paramname"><em>resizePercentage</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td>
          <td class="paramname"><em>resizeIfNeeded</em> = <code><a class="el" href="namespacecasacore.html#ad5c850f9e177173e0f7d0ad57091501d">True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Having an array that can be reused without requiring reallocation can be useful for large arrays. </p>
<p>The method reformOrResize permits this usage.</p>
<p>The reformOrResize method first attempts to reform the matrix so that it reuses the existing storage for an array with a new shape. If the existing storage will not hold the new shape, then the method will resize the array when resizeIfNeeded is true; if a resize is needed and resizeIfNeeded is false, then an <a class="el" href="classcasacore_1_1ArrayConformanceError.html" title="An error thrown when two arrays do not conform. ">ArrayConformanceError</a> is thrown. The copyDataIfNeeded parameter is passed to resize if resizing is performed. resizePercentage is the percent of additional storage to be addeed when a resize is performed; this allows the allocations to be amortized when the caller expects to be calling this method again in the future. The parameter is used to define an allocation shape which is larger than the newShape by increasing the last dimension by resizePercentage percent (i.e., lastDim = (lastDim * (100 + resizePercentage)) / 100). If resizePercentage &lt;= 0 then resizing uses newShape as-is. Returns true if resizing (allocation) was performed.</p>
<p>To truncate the array so that it no longer holds additional storage, use the resize method.</p>
<p><a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> may not be shared with another <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> object during this call. Exception thrown if it is shared. </p>

</div>
</div>
<a class="anchor" id="a6f043e07c0784ab1119f1eda6dc69bd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::removeDegenerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a>&#160;</td>
          <td class="paramname"><em>startingAxis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td>
          <td class="paramname"><em>throwIfError</em> = <code><a class="el" href="namespacecasacore.html#ad5c850f9e177173e0f7d0ad57091501d">True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove degenerate axes from this <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> object. </p>
<p>Note it does not make sense to use these functions on a derived object like <a class="el" href="classcasacore_1_1Matrix.html" title="A 2-D Specialization of the Array class. ">Matrix</a>, because it is not possible to remove axes from them. </p>

</div>
</div>
<a class="anchor" id="a95ccae2df54a57485d5bdb8505be8d3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::removeDegenerate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>ignoreAxes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2553c2d285cd9ad504bb9fefd5398136"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make this array a different shape. </p>
<p>If <code>copyValues==True</code> the old values are copied over to the new array. Copying is done on a per axis basis, thus a subsection with the minimum of the old and new shape is copied. <br/>
Resize without argument is equal to resize(IPosition()). <br/>
It is important to note that if multiple <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> objects reference the same data storage, this <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> object still references the same data storage as the other <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> objects if the shape does not change. Otherwise this <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> object references newly allocated storage, while the other <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> objects still reference the existing data storage. <br/>
If you want to be sure that the data storage of this <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> object is not referenced by other <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> objects, the function unique should be called first. </p>

<p>Reimplemented in <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; casacore::MPosition &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; casacore::AutoDiff&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; casacore::Quantum &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; casacore::Vector&lt; Range &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; AutoDiff&lt; T &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; casacore::Unit &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; Int64 &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; casacore::MDirection &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; casacore::MFrequency &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; casacore::RORecordFieldPtr&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; AutoDiffA&lt; T &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; Type &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; casacore::Slicer * &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; casacore::MeasComet * &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; casacore::Quantum&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; uInt &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; Domain &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; casacore::String &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#ab41c019edf6c38170591f564c92bc8e3">casacore::Vector&lt; ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a1028463ff4095147f12dd58a6edc3e82">casacore::Matrix&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a1028463ff4095147f12dd58a6edc3e82">casacore::Matrix&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a1028463ff4095147f12dd58a6edc3e82">casacore::Matrix&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a1028463ff4095147f12dd58a6edc3e82">casacore::Matrix&lt; casacore::GaussianBeam &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a1028463ff4095147f12dd58a6edc3e82">casacore::Matrix&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a1028463ff4095147f12dd58a6edc3e82">casacore::Matrix&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a1028463ff4095147f12dd58a6edc3e82">casacore::Matrix&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a1028463ff4095147f12dd58a6edc3e82">casacore::Matrix&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a1028463ff4095147f12dd58a6edc3e82">casacore::Matrix&lt; Complex &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#a1d7b339d435440a2b6d7740f199f4358">casacore::Cube&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#a1d7b339d435440a2b6d7740f199f4358">casacore::Cube&lt; Double &gt;</a>, and <a class="el" href="classcasacore_1_1Cube.html#a1d7b339d435440a2b6d7740f199f4358">casacore::Cube&lt; casacore::RigidVector&lt; Double, 2 &gt; &gt;</a>.</p>

<p>Referenced by <a class="el" href="ExprGroup_8h_source.html#l00393">casacore::TableExprGroupAggr::getArray()</a>, and <a class="el" href="MArrayBase_8h_source.html#l00115">casacore::MArrayBase::removeMask()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f9c2a6de6dee1f2915b46777d77fb23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>newShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td>
          <td class="paramname"><em>copyValues</em> = <code><a class="el" href="namespacecasacore.html#a11ef6530f2dc946f54d220fe416bfd41">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the array and optionally copy the values. </p>
<p><br/>
The default implementation in <a class="el" href="classcasacore_1_1ArrayBase.html" title="Non-templated base class for templated Array class. ">ArrayBase</a> throws an exception. </p>

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#a85eedd8bed39b989b8c5fedb4daa452f">casacore::ArrayBase</a>.</p>

</div>
</div>
<a class="anchor" id="a47b6337a49142f6118661c515cbaedee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>newShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a>&#160;</td>
          <td class="paramname"><em>copyValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1ArrayInitPolicy.html">ArrayInitPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the array and optionally copy the values. </p>
<p><br/>
The default implementation in <a class="el" href="classcasacore_1_1ArrayBase.html" title="Non-templated base class for templated Array class. ">ArrayBase</a> throws an exception. </p>

<p>Reimplemented from <a class="el" href="classcasacore_1_1ArrayBase.html#a5d46c1c6873c7d59816c8b24a29a6e26">casacore::ArrayBase</a>.</p>

<p>Reimplemented in <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; casacore::MPosition &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; casacore::AutoDiff&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::DiffType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; casacore::Quantum &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; casacore::Vector&lt; Range &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; AutoDiff&lt; T &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; casacore::Unit &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; Int64 &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; casacore::MDirection &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; casacore::MFrequency &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; casacore::RORecordFieldPtr&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; AutoDiffA&lt; T &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; Type &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; typename casacore::FunctionTraits&lt; DComplex &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; typename casacore::FunctionTraits&lt; T &gt;::ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; typename casacore::FunctionTraits&lt; Double &gt;::BaseType &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; casacore::Slicer * &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; casacore::MeasComet * &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; casacore::Vector&lt; typename casacore::LSQTraits&lt; typename casacore::FunctionTraits&lt; T &gt;::BaseType &gt;::base &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; casacore::Quantum&lt; Double &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; uInt &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; Domain &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; casacore::String &gt;</a>, <a class="el" href="classcasacore_1_1Vector.html#add693506ea3720bc28dc1f776c641504">casacore::Vector&lt; ArgType &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a7cb6a4b446fb631d223df09fcf7d58e6">casacore::Matrix&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a7cb6a4b446fb631d223df09fcf7d58e6">casacore::Matrix&lt; casacore::SquareMatrix&lt; Complex, 2 &gt; &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a7cb6a4b446fb631d223df09fcf7d58e6">casacore::Matrix&lt; Float &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a7cb6a4b446fb631d223df09fcf7d58e6">casacore::Matrix&lt; casacore::GaussianBeam &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a7cb6a4b446fb631d223df09fcf7d58e6">casacore::Matrix&lt; Double &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a7cb6a4b446fb631d223df09fcf7d58e6">casacore::Matrix&lt; Int &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a7cb6a4b446fb631d223df09fcf7d58e6">casacore::Matrix&lt; FType &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a7cb6a4b446fb631d223df09fcf7d58e6">casacore::Matrix&lt; Bool &gt;</a>, <a class="el" href="classcasacore_1_1Matrix.html#a7cb6a4b446fb631d223df09fcf7d58e6">casacore::Matrix&lt; Complex &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#a6a7ddd022ada632930a989abbe2b9a2d">casacore::Cube&lt; T &gt;</a>, <a class="el" href="classcasacore_1_1Cube.html#a6a7ddd022ada632930a989abbe2b9a2d">casacore::Cube&lt; Double &gt;</a>, and <a class="el" href="classcasacore_1_1Cube.html#a6a7ddd022ada632930a989abbe2b9a2d">casacore::Cube&lt; casacore::RigidVector&lt; Double, 2 &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad9c9856db5a41305e6a0e13cd8a9e5b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set every element of the array to "value." Also could use the assignment operator which assigns an array from a scalar. </p>

</div>
</div>
<a class="anchor" id="a9a0c8703894f0b429e5f878225986b9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::setEndIter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the end iterator. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00924">924</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="Array_8h_source.html#l00920">casacore::Array&lt; casacore::String &gt;::makeSteps()</a>.</p>

</div>
</div>
<a class="anchor" id="aced59eeb9ed3325380d264f9324254bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::takeStorage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Arrays__module.html#ga44401e80192e152e570fc445a95f534b">StorageInitPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="group__Arrays__module.html#gga44401e80192e152e570fc445a95f534ba46b2e4579af5e1f449bb55cfd9f1c9bc">COPY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the data values with those in the pointer <code>storage</code>. </p>
<p>The results are undefined if storage does not point at <a class="el" href="classcasacore_1_1ArrayBase.html#a9c59e870964872ddfeb2de91e05d8b55" title="How many elements does this array have? Product of all axis lengths. ">nelements()</a> or more data elements. After <a class="el" href="classcasacore_1_1Array.html#aced59eeb9ed3325380d264f9324254bc" title="Replace the data values with those in the pointer storage. ">takeStorage()</a> is called, <code><a class="el" href="classcasacore_1_1Array.html#aaf33c3457f1097ac0e0da72aaba46ead" title="The number of references the underlying storage has assigned to it. ">nrefs()</a></code> is 1.</p>
<p>If <code>policy</code> is <code>COPY</code>, storage of a new copy is allocated by <code><a class="el" href="classcasacore_1_1DefaultAllocator.html" title="An aligned allocator with the default alignment. ">DefaultAllocator</a>&lt;T&gt;</code>. If <code>policy</code> is <code>TAKE_OVER</code>, <code>storage</code> will be destructed and released by <code><a class="el" href="classcasacore_1_1NewDelAllocator.html" title="An allocator behaves like operator new[]/delete[]. ">NewDelAllocator</a>&lt;T&gt;</code>. It is strongly recommended to supply an appropriate <code>allocator</code> argument explicitly whenever <code>policy</code> == <code>TAKE_OVER</code> to let <code><a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a></code> to know how to release the <code>storage</code>. </p>

</div>
</div>
<a class="anchor" id="a468ea2bb5b23458f62978883a6939115"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::takeStorage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Arrays__module.html#ga44401e80192e152e570fc445a95f534b">StorageInitPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1AbstractAllocator.html">AbstractAllocator</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If <code>policy</code> is <code>COPY</code>, storage of a new copy is allocated by <code>allocator</code>. </p>
<p>If <code>policy</code> is <code>TAKE_OVER</code>, <code>storage</code> will be destructed and released by <code>allocator</code>. Otherwise, <code>storage</code> is ignored. </p>

</div>
</div>
<a class="anchor" id="a1d7d7d74d1b8ee910e3bd44a7f901612"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::takeStorage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Since the pointer is const, a copy is always taken. </p>
<p>Storage of a new copy is allocated by <code><a class="el" href="classcasacore_1_1DefaultAllocator.html" title="An aligned allocator with the default alignment. ">DefaultAllocator</a>&lt;T&gt;</code>. </p>

</div>
</div>
<a class="anchor" id="a14f336b87fb81e2ed66c6d2da114a3fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::takeStorage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcasacore_1_1IPosition.html">IPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcasacore_1_1AbstractAllocator.html">AbstractAllocator</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Since the pointer is const, a copy is always taken. </p>
<p>Storage of a new copy is allocated by the specified allocator. </p>

</div>
</div>
<a class="anchor" id="a27f4def83148d8921e637020c8f98f46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::tovector </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an STL vector from an <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a>. </p>
<p>The created vector is a linear representation of the <a class="el" href="classcasacore_1_1Array.html" title="template &lt;class T, class U&gt; class vector; ">Array</a> memory. See <a class="el" href="classcasacore_1_1Vector.html">Vector</a> for details of the operation and its reverse (i.e. creating a <code><a class="el" href="classcasacore_1_1Vector.html" title="A 1-D Specialization of the Array class. ">Vector</a></code> from a <code>vector</code>), and for details of definition and instantiation. </p>

</div>
</div>
<a class="anchor" id="afb5577d38a7e03a3c7cee76153c04b32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;T&gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::tovector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a31e7341087c1aa29f72fb847ddca2884"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This ensures that this array does not reference any other storage. </p>
<p><br/>
<b>Tip:</b><em> When a section is taken of an array with non-unity strides, storage can be wasted if the array, which originally contained all the data, goes away; <a class="el" href="classcasacore_1_1Array.html#a31e7341087c1aa29f72fb847ddca2884" title="This ensures that this array does not reference any other storage. ">unique()</a> also reclaims storage; This is an optimization users don't normally need to understand;</em></p>
<p><em></p>
<div class="fragment"><div class="line">IPosition <a class="code" href="classcasacore_1_1ArrayBase.html#aaddb725358b52d576969897b1e0ef83d">shape</a>(;;;), blc(;;;), trc(;;;), inc(;;;);</div>
<div class="line">Array&lt;Float&gt; af(shape);</div>
<div class="line">inc = 2; <span class="comment">// or anything &gt; 1</span></div>
<div class="line">Array&lt;Float&gt; aSection;<a class="code" href="classcasacore_1_1Array.html#adcfb6bd1f6e0a70dc1c2909739e09d07">reference</a>(af(blc, trc, inc));</div>
<div class="line">af;<a class="code" href="classcasacore_1_1Array.html#adcfb6bd1f6e0a70dc1c2909739e09d07">reference</a>(anotherArray);</div>
<div class="line"><span class="comment">// aSection now references storage that has a stride</span></div>
<div class="line"><span class="comment">// in it, but nothing else is; Storage is wasted;</span></div>
<div class="line">aSection;<a class="code" href="classcasacore_1_1Array.html#a31e7341087c1aa29f72fb847ddca2884">unique</a>();</div>
</div><!-- fragment --><p> </em><br/>
 </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a24c1725f909aae3465c388e4587975d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcasacore_1_1ArrayIterator.html">ArrayIterator</a>&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to iterate through Arrays. </p>
<p>Derived classes <a class="el" href="classcasacore_1_1VectorIterator.html" title="Iterate an Vector cursor through another Array. ">VectorIterator</a> and <a class="el" href="classcasacore_1_1MatrixIterator.html" title="Iterate a Matrix cursor through another Array. ">MatrixIterator</a> are probably more useful. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00678">678</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a17fc06682c9f9c46f1e0e38b7af25b80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcasacore_1_1Matrix.html">Matrix</a>&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Needed to be a friend for <a class="el" href="classcasacore_1_1Matrix.html#ac718778346fa2655be63625d6a7404b2" title="Make this matrix a reference to other. ">Matrix&lt;T&gt;::reference()</a> </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00684">684</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a27c874b43e689bf220263aff190b926d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::begin_p</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This pointer is adjusted to point to the first element of the array. </p>
<p>It is not necessarily the same thing as data-&gt;storage() since this array might be a section, e.g. have a blc which shifts us forward into the block. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00913">913</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="Cube_8h_source.html#l00193">casacore::Cube&lt; casacore::RigidVector&lt; Double, 2 &gt; &gt;::at()</a>, <a class="el" href="Array_8h_source.html#l00868">casacore::Array&lt; casacore::String &gt;::cbegin()</a>, <a class="el" href="Array_8h_source.html#l00597">casacore::Array&lt; casacore::String &gt;::data()</a>, <a class="el" href="Cube_8h_source.html#l00175">casacore::Cube&lt; casacore::RigidVector&lt; Double, 2 &gt; &gt;::operator()()</a>, <a class="el" href="Matrix_8h_source.html#l00190">casacore::Matrix&lt; Complex &gt;::operator()()</a>, <a class="el" href="Vector_8h_source.html#l00211">casacore::Vector&lt; ArgType &gt;::operator()()</a>, <a class="el" href="Vector_8h_source.html#l00203">casacore::Vector&lt; ArgType &gt;::operator[]()</a>, and <a class="el" href="Array_8h_source.html#l00924">casacore::Array&lt; casacore::String &gt;::setEndIter()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b49ac6e6d75049f2fc0e63c121b0205"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcasacore_1_1CountedPtr.html">CountedPtr</a>&lt;<a class="el" href="classcasacore_1_1Block.html">Block</a>&lt;T&gt; &gt; <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::data_p</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference counted block that contains the storage. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00907">907</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="aed7332aed275a0097b203587c4cbe484"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcasacore_1_1Array.html">casacore::Array</a>&lt; T &gt;::end_p</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The end for an STL-style iteration. </p>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00916">916</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

<p>Referenced by <a class="el" href="Array_8h_source.html#l00872">casacore::Array&lt; casacore::String &gt;::cend()</a>, <a class="el" href="Array_8h_source.html#l00860">casacore::Array&lt; casacore::String &gt;::end()</a>, and <a class="el" href="Array_8h_source.html#l00924">casacore::Array&lt; casacore::String &gt;::setEndIter()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>casa/Arrays/<a class="el" href="Array_8h_source.html">Array.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
