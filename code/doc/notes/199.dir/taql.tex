
\externallabels{../../user/Refman}{../../user/Refman/labels.pl}

\section{Introduction}
The Table Query Language (TaQL, rhymes with bagel) makes
it possible to select
rows from an arbitrary table based on the contents of its
columns and keywords. It supports arbitrary complex
expressions including regular expressions and many functions.
TaQL also makes sorting and column selection possible.
Furthermore TaQL has commands to modify data in a subset of a table.

TaQL is modeled after SQL and contains most of SQL's functionality.
The main features lacking are joins and GROUPBY/HAVING. On the other
hand does TaQL have full support for arrays and an advanced way of
specifying intervals.

The first sections of this document explain the syntax and show the options.
The last sections show the interface to TaQL using Glish or C++.
The Glish interface makes it possible to embed Glish
variables and expressions in a TaQL command.

The result of a TaQL selection is a so-called reference table.
It is a table that can be used as any other table, but it does not
contain data. Instead it contains references to the rows and columns
in the original table. Thus modifying data in a reference table means
that effectively the data in the original table is modified.

\section{Syntax}
TaQL contains four commands.
In the commands shown below the square brackets are not part of the
syntax, but indicate the optional parts of the commands.

\begin{itemize}
\item selection
\begin{verbatim}
  SELECT [[DISTINCT] column_list] [INTO table]
    FROM table_list [WHERE expression]
    [ORDERBY [DISTINCT] sort_list]
    [LIMIT expression] [OFFSET expression] [GIVING table|set]
\end{verbatim}
It can be used to get an optionally sorted subset from a table.

\item updating
\begin{verbatim}
  UPDATE table_list SET update_list [FROM table_list]
    [WHERE ...] [ORDERBY ...] [LIMIT ...] [OFFSET ...]
\end{verbatim}
It can be used to update data in (a subset of) the first table in the
table list. 

\item addition
\begin{verbatim}
  INSERT INTO table_list [(column_list)] VALUES (expr_list)
or
  INSERT INTO table_list [(column_list)] SELECT_command
\end{verbatim}
It can be used to add and fill new rows in the first table in the
table list.

\item deletion
\begin{verbatim}
  DELETE FROM table_list
    [WHERE ...] [ORDERBY ...] [LIMIT ...] [OFFSET ...]
\end{verbatim}
It can be used to delete some or all rows from the first table
in the table list.
\end{itemize}
The commands and verbs in the commands are
case-insensitive, but case is important in string values and
in names of columns and keywords. Whitespace (blanks and tabs) can
be used at will.
\\\htmlref{A later section (Modifying a table)}{TAQL:MODIFYING} explains the
UPDATE, INSERT, and DELETE command in more detail. Hereafter the
various parts of the SELECT command are explained.

\begin{description}
  \item[ column\_list]
       is a comma-separated list with names of columns that have to be selected
       from the primary table in the table\_list (see below).
       If * or no column\_list is given, all columns will be selected.
       \\In the future it may be possible to use expressions to create
       a new column based on the contents of other columns.
       Note that for subqueries the GIVING clause offers an
       alternative way of specifying the result making it
       possible to use expressions.
       \\If a column\_list is given and if all columns are scalars, the
       column\_list can be preceeded by the word DISTINCT.
       It means that the result is made unique by removing the rows
       with duplicate values in the columns of the column\_list.
       Instead of DISTINCT the synonym NODUPLICATES or UNIQUE can also
       be used.
       To find duplicate values, some temporary sorting is done,
       but the original order of the remaining rows is not changed.
       \\Note that support of this keyword is mainly done for SQL
       compliance. The same (and more) can be achieved with the
       DISTINCT keyword in the \htmlref{ORDERBY}{TAQL:ORDERBY} clause
       with the difference that ORDERBY DISTINCT will change the order.
       \\For full SQL compliance it is also possible to give the word
       ALL which is the opposite of DISTINCT, thus all values are
       returned. This is the default.
  \item[ \label{TAQL:INTO}INTO table ]
       indicates that the ultimate result of the SELECT command should be
       written to a table (with the given name). This table is a
       so-called reference table.
       \\The standard TaQL way to define the output table is the
       \htmlref{GIVING}{TAQL::GIVING} clause. INTO is available
       for SQL compliance.
  \item[ \label{TAQL:TABLE_LIST}FROM table\_list ]
       is a comma-separated list of table names which can contain
       path specification and environment variables or the UNIX
       \verb+~+ notation.
       It indicates which tables are used in
       the SELECT command. The first table in the list is the primary
       table and is used for all columns in the other clauses.
       Usually only one table is used in which case the list consists
       of only one table name. E.g.
       \begin{verbatim}
       SELECT col1,col2 FROM mytable
           WHERE col1>col2
           ORDERBY col1
       \end{verbatim}
       In this example columns \texttt{col1} and \texttt{col2}
       are taken from \texttt{mytable}.
       \\However, it is possible to specify more tables in the table\_list.
       In the WHERE clause these secondary tables can be used to take
       keywords from. E.g.
       \begin{verbatim}
       SELECT FROM mytable,othertable
           WHERE col1>othertable.key
       \end{verbatim}
       As shown in the example above a qualifying name (\verb+othertable.+)
       can be used in the WHERE
       clause to specify from which table a keyword has to be taken.
       If no qualifying name is given, the keyword (or column) is taken
       from the primary table (i.e., the first table in the table\_list).
       This means that qualifying names are only needed in special cases.
       The qualifying name can not contain special characters like a slash.
       Therefore a table\_name needs an explicit shorthand alias
       if it contains special characters.
       \\The full table\_list syntax is:
       \\
       \texttt{table\_name1 [shorthand1], table\_name2 [shorthand2], etc.}
       \\The shorthand defaults to the table\_name.
       In the following example shorthand \texttt{my} is not really needed.
       Shorthand \texttt{other} is needed though.
       \begin{verbatim}
       SELECT FROM mytable my, ~user/othertable other
           WHERE my.col1>other.key
       \end{verbatim}
       Similar to SQL and OQL the shorthand can also be given using
       \texttt{AS} or \texttt{IN}. E.g.
       \begin{verbatim}
       SELECT FROM mytable AS my, other IN ~user/othertable
       \end{verbatim}
       Note that if using \texttt{IN}, the shorthand has to preceed
       the table name. It can be seen as an iterator variable.

       There are three special ways to specify a table:
       \begin{enumerate}
       
       \item
       A table name can also be taken from a keyword in a previously
       specified table. This can be useful in a
       \htmlref{subquery}{TAQL:SUBQUERIES}. The syntax for this is
       the same as that for specifying \htmlref{keywords}{TAQL:KEYWORDS}
       in an expression. E.g.
       \begin{verbatim}
       SELECT FROM mytable tab
           WHERE col1 IN [SELECT subcol FROM tab.col2::key]
       \end{verbatim}
       In this example \texttt{key} is a table keyword of column
       \texttt{col2} in table \texttt{mytable} (note that \texttt{tab}
       is the shorthand for \texttt{mytable} and could be left out).
       \\It can also be used for another table in the main query. E.g.
       \begin{verbatim}
       SELECT FROM mytable, ::key subtab
           WHERE col1 > subtab.key1
       \end{verbatim}
       In this example the keyword \texttt{key1} is taken from the
       subtable given by the table keyword \texttt{key} in the main
       table.
       \\If a keyword is used as the table name, the keyword is
       searched
       in one of the tables previously given. The search starts at
       the current query level and proceeds outwards (i.e., up to the
       main query level). If a shorthand is given, only tables with
       that shorthand are taken into account. If no shorthand is
       given, only primary tables are taken into account.

       \item
       Like in OQL it is possible to use a
       \htmlref{nested query}{TAQL:SUBQUERIES}
       command in the FROM clause. This is a normal query command
       enclosed in square brackets or parentheses.
       It results in a temporary table
       which can thereafter be used as a table in the rest of the
       query command. A shorthand has to be defined for it in order
       to be able to refer to that table.
       \\Use of a query in the FROM command can be useful to avoid
       multiple equal subqueries. E.g.
       \begin{verbatim}
  select from MS,
   [select from MS where sumsqr(UVW[1:2]) < 625]
    as TIMESEL
   where TIME in [select distinct TIME from TIMESEL]
    &&  any([ANTENNA1,ANTENNA2] in
             [select from TIMESEL giving
              [iif(UVW[3] < 0, ANTENNA1, ANTENNA2)]])
       \end{verbatim}
       is a command to find shadowed antennas for the VLA.
       Without the query in the FROM command the subqueries in the
       remainder of the command would have been more complex.
       Furthermore, it would have been necessary to execute that
       select twice.
       \\The command is quite complex and cannot be fully understood
       before reading the rest of this note.
       Note, however, that the command uses the shorthand \texttt{TIMESEL}
       to be able to use the temporary table in the subqueries.

       \item
       Normally only persistent tables (i.e. tables on disk) can
       be used. However, it is also possible to use transient tables
       in a TaQL command given in \htmlref{Glish or C++}{TAQL:GLISHC}.
       This is done by passing one or more table objects to the
       function executing the TaQL command. In the TaQL command a
       \$-sign followed by a sequence number has to be given to
       indicate the correct object containing the transient table.
       E.g. if two
       table objects are passed \$1 indicates the first table, while \$2
       indicates the second one.
     \end{enumerate}

  \item[WHERE expression]
       defines the selection expression which must have a boolean
       scalar result. A row in the primary table
       is selected if the expression is true for the values in that row.
       The syntax of the expression is explained
       in a \htmlref{later section}{TAQL:EXPRESSIONS}.
  \item[ \label{TAQL:ORDERBY}ORDERBY sort\_list]
       defines the order in which the result of the WHERE clause
       has to be sorted. The sort\_list is a comma separated list of
       expressions.
       \\The sort\_list can be preceeded by the word \texttt{ASC} or
       \texttt{DESC} indicating if the given expressions are by
       default sorted in ascending or descending order (default is ASC).
       Each expression in the sort\_list can optionally be
       followed by \texttt{ASC} or \texttt{DESC} to override the
       default order for that particular column
       \\To be compliant with SQL whitespace can be used between the
       words ORDER and BY.
       \\The word ORDERBY can optionally be followed by DISTINCT
       which means that only the first row of multiple rows with
       equal sort keys is kept in the result. To be compliant with
       SQL dialects the word UNIQUE or NODUPLICATES can be used
       instead of DISTINCT.
       \\An expression can be a scalar column or a single element from
       an array column. In these cases some optimization is performed
       by reading the entire column directly.
       \\It can also be an arbitrarily complex expression
       with exactly the same syntax rules as the expressions in the
       \htmlref{WHERE}{TAQL:EXPRESSIONS} clause.
       The resulting data type of the expression must
       be a standard scalar one, thus it cannot be a Regex or
       DateTime (see \htmlref{below}{TAQL:DATATYPES} for a discussion
       of the available data types).
       E.g.
       \begin{verbatim}
       ORDERBY col1, col2, col3
       ORDERBY DESC col1, col2 ASC, col3
       ORDERBY NODUPLICATES uvw[1] DESC
       ORDERBY square(uvw[1]) + square(uvw[2])
       ORDERBY datetime(col)             incorrect data type
       ORDERBY mjd(datetime(col))        is correct
       \end{verbatim}
  \item[ LIMIT expression]
       indicates that up to N rows have to be selected, where N is
       the result of the expression. 
       \\\texttt{LIMIT} is applied after \texttt{ORDERBY}, so it is
       particularly useful in combination with
       \texttt{ORDERBY} to select, for example, the highest 10 values.
  \item[ OFFSET expression]
       indicates that the first N rows of the selection have to be 
       skipped. As \texttt{LIMIT} it is particularly useful in
       combination with \texttt{ORDERBY}.
  \item[ \label{TAQL:GIVING}GIVING table$|$set ]
       indicates that the ultimate result of the SELECT command should be
       written to a table (with the given name). This table is a
       so-called reference table.
       It does not contain data of its own, but only references the
       proper rows in the original table. It can be used
       as any other table, thus it can also be used as an input table in
       another SELECT command. A reference table resulting from
       a selection (or sort) on another reference table references the
       original table again. Thus no (expensive) cascade of reference
       tables is created.
       \\Another (more SQL compliant) way to define the output table
       is the \htmlref{INTO}{TAQL:INTO} clause.

       It is also possible to specify a set in the GIVING clause
       instead of a table name. This can be useful if the result of a
       \htmlref{subquery}{TAQL:SUBQUERIES} is used in the main query.
       Such a \htmlref{set}{TAQL:SETS} can contain only one element
       (which can be a range or interval).
       The parts of the element have to be expressions resulting in a scalar.

       In the main query and in a query in the FROM command the
       GIVING clause can only result in a table and not in a set.
       \\To be compliant with SQL dialects, the word SAVETO can be
       used instead of GIVING. Whitespace can be given between SAVE and TO.
 
\end{description}
Although the clauses column\_list, WHERE, ORDERBY, LIMIT, and OFFSET
are optional,
at least one of them has to be used. Otherwise no operation is
performed on the primary table (which makes no sense).
Also the GIVING clause with a value set is seen as an operation.


\section{\label{TAQL:EXPRESSIONS}Expressions}
An arbitrary expression can be used in the WHERE clause, as a sort
key in the ORDERBY clause, in the set in the GIVING clause, or in
values in the INSERT or UPDATE command.
Note that the expression result must be
a boolean scalar if used in the WHERE clause. If used in ORDERBY
the result can also be a numeric or string scalar. If used in 
GIVING it can also be a DateTime scalar. If used as a new value in
the UPDATE or INSERT command it can also be an array.
\\The expression in the clause can be as complex as one likes
using the standard
\htmlref{arithmetic, comparison, and logical operators}{TAQL:OPERATORS}.
Parentheses can be used to group subexpressions.
\\The operands in an expression can be
\htmlref{table columns}{TAQL:COLUMNS},
\htmlref{table keywords}{TAQL:KEYWORDS},
\htmlref{constants}{TAQL:CONSTANTS},
\htmlref{functions}{TAQL:FUNCTIONS},
\htmlref{sets and intervals}{TAQL:SETS}, and
\htmlref{subqueries}{TAQL:SUBQUERIES}.
\\The \htmlref{index operator}{TAQL:INDEXING} can be used to take a
single element or a subsection from an array expression.
\\E.g.
\begin{verbatim}
  column1 > 10
  column1 + arraycolumn[index] >= min (column2, column3)
  column1 IN [expr1 =:< expr2]
\end{verbatim}
The last example shows a \htmlref{set}{TAQL:SETS} with a continuous interval.

\label{TAQL:DATATYPES}
TaQL knows the following data types:
\begin{description}
  \item[ Bool]
  \item[ Double] which includes integers and times/positions
  \item[ Complex ] which includes single and double precision complex
  \item[ String ] Operator + can be used (concatenation).
  \item[ Regex ] which is formed by the functions \texttt{regex},
    \texttt{pattern}, and \texttt{sqlpattern} or by a special constant
    (see discussion \htmlref{below}{TAQL:CONSTANTS}).
  \item[ DateTime ] which represents a date/time. There are several functions
       acting on a date/time. Also operator + and - can be used.
\end{description}
Scalars and arbitrarily shaped arrays of these data types can be used.
However, arrays of Regex are not possible.
\\If an operand or function argument with a non-matching data type
is used, TaQL can do the following automatic conversions:
\\- from Double to Complex
\\- from String to DateTime


\subsection{\label{TAQL:CONSTANTS}Constants}
Scalar constants of the various data types can be formed as follows
(which is very similar to Glish):
\begin{itemize}
  \item A Bool constant is the value \texttt{T} or \texttt{F}.
  \item A Double constant can be any integer or floating-point number.
       \\Another way to define a Double constant is by means of
       a Time or Position. Such a constant is always converted to radians.
       It can be given in several ways:
       \begin{itemize}
         \item An integer or floating-point number immediately
              followed by a unit
              (thus without whitespace). E.g. \texttt{12deg}
              \\Some valid units are deg, arcmin, arcsec (or as), rad.
              The units can be scaled by preceeding them with a letter
              (e.g. mrad is millirad).
         \item A time/position in hours in HMS format.
              E.g. \texttt{12h34m34.5} or \texttt{8h}
         \item A position in degrees in DMS format.
              E.g. \texttt{12d34m34.5} or \texttt{8d}
         \item A position in degrees in dot format. Note that the dots
              for degrees and minutes must always be present.
              E.g. \texttt{12.34.34.5} or \texttt{8..34.5}
       \end{itemize}
  \item The imaginary part of a Complex constant is formed by a Double
       constant immediately followed by a lowercase \textbf{i}. A full Complex
       constant is formed by adding another Double constant as the
       real part. E.g.
       \begin{verbatim}
       1.5 + 2i
       2i+1.5            is identical
       \end{verbatim}
       Note that a full Complex constant has to be enclosed
       in parentheses if, say, a multiplication is performed on it. E.g.
       \begin{verbatim}
       2 * (1.5+2i)
       \end{verbatim}
  \item A String constant has to be enclosed in " or ' and can be
       concatenated (as in C++). E.g.
       \begin{verbatim}
         "this is a string constant"
         'this is a string constant containing a "'
         "ab'cd"'ef"gh'
             which results in constant  ab'cdef"gh
       \end{verbatim}
  \item A Regex constant can be given in three flavours:
	\begin{itemize}
	\item as a UNIX shell (file name) style pattern.
	      \\\texttt{p/pattern/} can be used after operator \verb+~+
	      and \verb+!~+.
              Instead of a slash, the characters \% and \# can also be used as
              delimiter, as long as the same delimiter is used on both sides.
              The delimiter can not be part of the pattern itself.
              \\Function \texttt{pattern} can be used after operator = and !=.
	      \\A pattern uses the special character ? for a single
              arbitrary character
              and * for zero or more arbitrary characters. Furthermore
              square brackets can be used for a choice from a set of single
              characters and braces can be used for a choice from a
              set of pattern parts. 
	      \begin{verbatim}
		name~p/3c*/
		col=pattern('[_A-Za-z]*')
		name !~ p#/usr/*.{h,cc}#
	      \end{verbatim}
	\item as an SQL style pattern.
              \\A string constant giving the pattern can be used after
              operator \texttt{LIKE}.
              \\Function \texttt{sqlpattern} can be used after operator
              = and !=.
	      \\An SQL style pattern uses the special character \_ for
              a single arbitrary character
              and \% for zero or more arbitrary characters.
	      \begin{verbatim}
		name LIKE '3c%'
	      \end{verbatim}
	\item as an extended regular expression.
	      \\\texttt{m/pattern/} can be used after operator \verb+~+
	      and \verb+!~+. A slash, \% and \# can be used as delimiter.
              \\Function \texttt{pattern} can be used after operator = and !=.
	      It uses many special characters. See class
              \htmladdnormallink{Regex}
              {../../aips/implement/Utilities/Regex.html}
	      for a full description.
              \begin{verbatim}
		name ~ m/[a-zA-Z][a-zA-Z0-9]*/
		name = regex('[a-zA-Z][a-zA-Z0-9]')
              \end{verbatim}
	\end{itemize}
	Note that the functions and operator LIKE work on any string,
        thus they can be used with any string expression.
  \item A DateTime constant can be formed in 2 ways:
       \begin{enumerate}
         \item From a String constant using the \texttt{datetime} function.
              In this way all possible formats as explained in class
              \texttt{MVTime} are supported. E.g.
              \begin{verbatim}
              datetime ("11-Dec-1972")
              \end{verbatim}
         \item A more convenient way is to specify it directly. Since this
              makes use of the delimiters - or /, it conflicts with the
              expression grammar as such. However, such conflicts can be
              solved by using whitespace in a expression and it is believed
              that in practice the convenience surpasses the possible
              conflicts.
              \\A large subset of the MVTime formats is supported.
              A DateTime has to be specified as \texttt{date/time}
              or \texttt{date-time}, where the time part (including
              the / or - delimiter) is optional.
              The possible date formats are:
              \\- YYYY/MM/DD or DD-MM-YYYY
              \\- DD-MMMMMMMM-YY where the - is optional and MMMMMMM is the
              case-insensitive name of the month (at least 3 letters).
              \\- YYYY//DDD or DDD--YYYY where DDD is the day number in
              the year.
              \\In the DMY format, 2000 is added if year$<$50 and
              1900 is added if 50$<=$year$<$100.
              \\If MM$>$12, YYYY will be incremented accordingly.
              \\The general time format in a DateTime constant is:
              \\- hh:mm:ss.s
              \\where the delimiter \textbf{h} or \textbf{H} can be used
              for the first colon and \textbf{m} or \textbf{M} for the second.
              Trailing parts can be omitted. E.g.
              \begin{verbatim}
              10-2-97
              10-02-1997
              10-February-97
              10feb97
              1997/2/10          are all identical

              1May96/3:          : (or h) is mandatory
              1May96/3:0
              1May96/3:0:0
              1May96/3h          h (or :) is mandatory
              1May96/3H0
              1May96/3h0M
              1May96/3hm0.0
              \end{verbatim}
              A DateTime constant with the current date/time can be made
              by using the function \texttt{datetime} without arguments.
       \end{enumerate}
\end{itemize}
Constant N-dimensional arrays cannot be formed directly.
It is possible though to form a constant bounded discrete
\htmlref{set}{TAQL:SETS}. If needed such a set is automatically
transformed to a 1-dimensional array. E.g.
\begin{verbatim}
     [1:10]
\end{verbatim}
is equal to a 1D array of 10 elements with values 1..10.

Furthermore it is possible to use the \texttt{array} function to
transform an array to another shape. This function is very similar to
the same function in glish. E.g.
\begin{verbatim}
     array([1:10],10,4)
\end{verbatim}
creates an array with shape [10,4]. Each row contains the values
1..10.
\\Please note that in TaQL arrays are stored in Fortran order, thus
the first index varies most rapidly (which is opposite to C).

Similar to glish the value array is wrapped if the created
array has more elements. Unlike glish the shape does not need to be
defined by scalars, but it can also be defined by another set. Thus:
\begin{verbatim}
     array(F,shape(DATA))
\end{verbatim}
is a boolean array filled with F with the same shape as the DATA array.


\subsection{\label{TAQL:OPERATORS}Operators}
The following operators can be used (with their normal meaning and
precedence) for scalars:
\begin{itemize}
  \item Unary \textbf{+} and \textbf{-}
       \\Can only be used with double and complex operands.
       They do not have a higher precedence than the binary operators.
       E.g. \texttt{-3}\verb+^+\texttt{2} results in \texttt{-9}.
  \item Unary \textbf{!} (or \textbf{NOT})
       \\Logical NOT operator.
       Can only be used with Bool operands.
  \item Binary \verb+^+, *, /, \%, +, and \textbf{-}
       \\\% is the modulo operator.
       E.g. \texttt{3\%1.4} results in \texttt{0.2} and
       \texttt{-10\%3} results in \texttt{-1}.
       \\\verb+^+ is the power operator.
       Note that because of the precedence rules
       \texttt{-3}\verb+^+\texttt{2} results in \texttt{-9}.
       \\All operators are left-associative, except \verb+^+ which is
       right-associative; thus \texttt{2}\verb+^+\texttt{1}\verb+^+\texttt{2} results in \texttt{2}.
       \\Operator \% can only be used for double operands, while the others
       can be used for double and complex operands.
       Operator + can also be used for:
       \\- Addition (i.e., concatenation) of 2 strings.
       \\- Addition of a double (unit days) and a DateTime
       (resulting in a DateTime).
       \\Operator - can also be used for:
       \\- Subtraction of a double (unit days) from a DateTime
       (resulting in a DateTime).
       \\- Subtraction of 2 DateTimes (resulting in a double with unit days).
  \item \textbf{==, $!=$, $>$, $>=$, $<$}, and \textbf{$<=$}
       \\Can be used with any operand as long as their data types conform.
       Operator $>$, $>=$, $<$, and $<=$ cannot be used for Regex.
       They use the norm for Complex values.
       \\To be compliant with SQL $=$ can be used for
       $==$ and $<>$ can be used for $!=$.
  \item \verb+~+, \verb+!~+, and \textbf{LIKE} and
	  \textbf{NOT LIKE}.
       \\\verb+~+ and \verb+!~+ have to be used with regular expression
       \htmlref{constants}{TAQL:CONSTANTS}.
       \\LIKE exists for SQL compliancy. It operates on a string
       giving a pattern with special characters \% (0 or more
       characters) and \verb+_+ (any single character). 
  \item \textbf{EXISTS} and \textbf{NOT EXISTS}
       \\Can be used to test if a subquery finds at least N matching rows.
       The value for N is taken from the LIMIT clause; if LIMIT is
       not given it defaults to 1. The subquery loop stops as soon as
       N matching rows are found.
       E.g.
       \begin{verbatim}
    EXISTS(select from ::ANTENNA where NAME=''somename'' LIMIT 2)
       \end{verbatim}
       results in T if at least 2 matching rows in the ANTENNA table
       were found.
  \item \textbf{IN} and \textbf{NOT IN}
       \\Can be used to test if a value is an element in a set of
       values, ranges, and/or intervals.
       (See the discussion of \htmlref{sets}{TAQL:SETS}).
  \item \textbf{BETWEEN} and \textbf{NOT BETWEEN}
       \\Is a special form of IN with a single closed interval.
       It exists for SQL compliance.
       It can be used to test if a value is between two other values.
       E.g.
       \\\texttt{   col BETWEEN 1 AND 3}  and  \texttt{col in [1=:=3]}
       are the same.
  \item \textbf{\&\&} and \textbf{$\mid\mid$}
       \\Logical AND and OR operator. 
       \\To be compliant with SQL the
       words \texttt{AND} and \texttt{OR} can be used instead of the
       symbols. These words are case insensitive.
       \\Also \textbf{\&} and \textbf{$\mid$} can be used.
       \\These operators can only be used with Bool operands.
\end{itemize}
\begin{description}
  \item The precedence order is:
       \\\verb+^+
       \\unary \texttt{+, -, !}
       \\\texttt{*, /, \%}
       \\\texttt{+, -}
       \\\texttt{==, !=, >, >=, <, <=, IN, BETWEEN, EXISTS},
              \verb+~+, \verb+!~+
       \\\texttt{\&\&}
       \\\verb+||+
\end{description}
All these operators can be used in the same way for arrays
(also a mix of scalar and array).

\subsection{\label{TAQL:FUNCTIONS}Functions}
Some functions have 2 names. One name is the AIPS++/Glish name, while the
other is the name as used in SQL.
In the following tables the function names are shown in uppercase,
while the result and argument types are shown in lowercase.
Note, however, that function names are case-insensitive.

\htmlref{Sets}{TAQL:SETS}, and in particular
\htmlref{subqueries}{TAQL:SUBQUERIES}, can result in a 1-dim array.
This means that the functions accepting an array argument can also
be used on a set or the result of a subquery. E.g.
\begin{verbatim}
  WHERE datecol IN date([11-Nov-97,16-Dec-97,14-Jan-98])
\end{verbatim}
\subsubsection{String functions}
These functions can be used on a scalar or an array argument.
\begin{description}
  \item[ \texttt{double STRLENGTH(string),  double LEN(string)}]
       Returns the number of characters in a string
       (trailing whitespace is significant).
  \item[ \texttt{string UPCASE(string), string UPPER(string) }]
        Convert to uppercase.
  \item[ \texttt{string DOWNCASE(string),  string LOWER(string)}]
        Convert to lowercase.
  \item[ \texttt{string TRIM(string)}]
       Removes trailing whitespace.
\end{description}

\subsubsection{Regex functions}
The syntax for forming a regex and pattern are explained in class
\htmladdnormallink{Regex}{../../aips/implement/Utilities/Regex.html}.
These functions can only be used on a scalar argument.

\begin{description}
  \item[ \texttt{regex REGEX(string)}]
       Handle the given string as a regular expression.
  \item[ \texttt{regex PATTERN(string)}]
       Handle the given string as a UNIX filename-like pattern and
       convert it to a regular expression.
  \item[ \texttt{regex SQLPATTERN(string)}]
       Handle the given string as an SQL-style pattern and
       convert it to a regular expression.
       An SQL-style pattern has two special character:
       \\ \% for zero or more arbitrary characters
       \\ \verb+_+ for one arbitrary character
\end{description}
A regex formed this way can only be used in a comparison == or !=. E.g.
\\\texttt{upcase(object) == pattern('3C*')}
\\to find all 3C objects in a catalogue.
See also the discussion on \htmlref{constants}{TAQL:CONSTANTS} for
other ways of forming and testing regular expressions.

\subsubsection{Date/time functions}
These functions can be used on a scalar or an array argument.
\begin{description}
  \item[ \texttt{DateTime DATETIME(string),  DateTime CTOD(string)} ]
       Parse the string and convert it to a date/time. The syntax of
       date/time is explained in class
       \htmladdnormallink{MVTime}{../../aips/implement/Quanta/MVTime.html}.
  \item[ \texttt{DateTime MJDTODATE(double)} ]
       The double value, which has to be a MJD (ModifiedJulianDate), is
       converted to a DateTime.
  \item[ \texttt{DateTime DATE(DateTime)}]
        Get the date (i.e., remove the time part). This function is needed in
       \\\texttt{date(column) == 12Feb1997}
       \\if the column contains date/times with times$>$0.
  \item[ \texttt{double MJD(DateTime)}]
        Get the DateTime as a MJD (ModifiedJulianDate).
  \item[ \texttt{double YEAR(DateTime)}]
        Get the year (which includes the century).
  \item[ \texttt{double MONTH(DateTime)}]
        Get the month number (1-12).
  \item[ \texttt{double DAY(DateTime)}]
        Get the day number (1-31).
  \item[ \texttt{double WEEKDAY(DateTime),  double DOW(DateTime)}]
        Get the weekday number (1=Monday, ..., 7=Sunday).
  \item[ \texttt{string CMONTH(DateTime)}]
        Get the name of the month (Jan ... Dec).
  \item[ \texttt{string CWEEKDAY(DateTime),  string CDOW(DateTime)}]
        Get the name of the weekday (Mon .. Sun).
  \item[ \texttt{double WEEK(DateTime)}]
        Get the week number in the year (1 ... 53).
        \\Note that week 1 is the week containing Jan 4th.
  \item[ \texttt{double TIME(DateTime)}]
       Get the time part of the day. It is converted to radians to
       be compatible with the internal representation of times/positions.
       In that way the function can easily be used as in:
       \\\texttt{TIME(date) $>$ 12h}
\end{description}
All functions can be used without an argument in which case the current
date/time is used. E.g. \texttt{DATE()} results in the current date.
\\It is possible to give a string argument instead of a date. In this
case the string is parsed and converted to a date (i.e., in fact the
function DATETIME is used implicitly).

\subsubsection{Comparison functions}
Two functions make it possible to compare 2 double or complex
values within a tolerance.
They can be used on scalar and array arguments (and a mix of them).
The tolerance must be a scalar though.
\begin{description}
  \item[ \texttt{bool NEAR(numeric val1, numeric val2, double tol)}]
    Tests in a relative way if a value is near another. Relative
    means that the
    magnitude of the numbers is taken into account.
    \\It returns
    \texttt{abs(val2 - val1)/max(abs(val1),abs(val2)) < tol}.
    \\If \texttt{tol<=0}, it returns \texttt{val1==val2}.
    If either val is 0.0, it takes
    care of area around the minimum number that can be represented.
    The default tolerance is 1.0e-13.
  \item[ \texttt{bool NEARABS(numeric val1, numeric val2, double tol)}]
    Tests in an absolute way if a value is near another. Absolute
    means that the
    magnitude of the numbers is not taken into account.
    \\It returns \texttt{abs(val2 - val1) < tol}.
    The default tolerance is 1.0e-13.
  \item[ \texttt{bool ISNAN(numeric val)}]
    Tests if a numeric value is a NaN (not-a-number).
\end{description}

\subsubsection{Mathematical functions}
Several functions can operate on double or complex arguments.
The data types of such functions is given as 'numeric'.
They can be used on scalar and array arguments (and a mix of them).
\begin{description}
  \item[ \texttt{double PI()}] Returns the value of \textbf{pi}.
  \item[ \texttt{double E()}] Returns the value of \textbf{e} (is equal to \texttt{EXP(1)}).
  \item[ \texttt{numeric SIN(numeric)}]
  \item[ \texttt{numeric SINH(numeric)}]
  \item[ \texttt{double ASIN(double)}]
  \item[ \texttt{numeric COS(numeric)}]
  \item[ \texttt{numeric COSH(numeric)}]
  \item[ \texttt{double ACOS(double)}]
  \item[ \texttt{double TAN(double)}]
  \item[ \texttt{double TANH(double)}]
  \item[ \texttt{double ATAN(double)}]
  \item[ \texttt{double ATAN2(double y, double x)}]
       Returns \texttt{ATAN(y/x)} in correct quadrant.
  \item[ \texttt{numeric EXP(numeric)}]
  \item[ \texttt{numeric LOG(numeric)}] Natural logarithm.
  \item[ \texttt{numeric LOG10(numeric)}]
  \item[ \texttt{numeric POW(numeric, numeric)}] The same as operator \verb+^+.
  \item[ \texttt{numeric SQUARE(numeric),  numeric SQR(numeric)}]
       The same as \verb+^+2, but much faster.
  \item[ \texttt{numeric SQRT(numeric)}]
  \item[ \texttt{complex COMPLEX(double, double)}]
  \item[ \texttt{numeric CONJ(numeric)}]
  \item[ \texttt{double REAL(numeric)}] Real part of a complex number.
  \item[ \texttt{double IMAG(numeric)}] Imaginary part of a complex number.
  \item[ \texttt{double NORM(numeric)}]
  \item[ \texttt{double ABS(numeric),  double AMPLITUDE(numeric)}]
  \item[ \texttt{double ARG(numeric),  double PHASE(numeric)}]
  \item[ \texttt{numeric MIN(numeric, numeric)}]
  \item[ \texttt{numeric MAX(numeric, numeric)}]
  \item[ \texttt{double SIGN(double)}]
       Returns -1 for a negative value, 0 for zero, 1 for a positive value.
  \item[ \texttt{double ROUND(double)}]
       Rounds the absolute value of the number.
       E.g. \texttt{ROUND(-1.6) = -2}.
  \item[ \texttt{double FLOOR(double)}]
       Works towards negative infinity.
       E.g. \texttt{FLOOR(-1.2) = -2}
  \item[ \texttt{double CEIL(double)}] Works towards positive infinity.
  \item[ \texttt{double FMOD(double, double)}] The same as operator \%.
\end{description}
Note that the trigonometric functions need their arguments in radians.

\subsubsection{Array to scalar reduction functions}
The following functions reduce an array to a scalar.
They are meant for an array. but can also be used for a scalar.
\begin{description}
  \item[ \texttt{bool ANY(bool)}] Is any element true?
  \item[ \texttt{bool ALL(bool)}] Are all elements true?
  \item[ \texttt{double NTRUE(bool)}] Number of true elements.
  \item[ \texttt{double NFALSE(bool)}] Number of false elements.
  \item[ \texttt{numeric SUM(numeric)}] Return sum of all elements.
  \item[ \texttt{numeric SUMSQUARE(numeric), numeric SUMSQR(numeric)}]
       Return sum of all squared elements.
  \item[ \texttt{numeric PRODUCT(numeric)}] Return product
    of all array elements.
  \item[ \texttt{double MIN(double)}] Return minimum
    of all array elements.
  \item[ \texttt{double MAX(double)}] Return maximum
    of all array elements.
  \item[ \texttt{double MEAN(double), double AVG(double)}]
    Return mean of all array elements.
  \item[ \texttt{double VARIANCE(double)}] Return variance
    (the sum of
    \\\texttt{(a(i) - mean(a))**2/(nelements(a) - 1)}.
  \item[ \texttt{double STDDEV(double)}] Return standard
    deviation (the square root of the variance).
  \item[ \texttt{double AVDEV(double)}] Return average deviation.
    (the sum of
    \\\texttt{abs(a(i) - mean(a))/nelements(a)}.
  \item[ \texttt{double MEDIAN(double)}] Return median (the
    middle element).
    If the array has an even number of elements, the mean of
    the two middle elements is returned.
  \item[ \texttt{double FRACTILE(double, doublescalar fraction)}]
       Return the value of the element at the given fraction.
       Fraction 0.5 is the same as the median.
\end{description}

\subsubsection{Array to array reduction functions}
These functions reduce an array to a smaller array by collapsing
the given axes using the given function. The axes are the last argument(s).
They can be given in two ways:
\\- As a single set argument; for example, \texttt{maxs(ARRAY,[1:2])}
\\- As individual scalar arguments; for example, \texttt{maxs(ARRAY,1,2)}
\\For example, using
\texttt{MINS(array,1,2)} for a 3-dim array results in a 1-dim array
where each value is the minimum of each plane in the cube.
\\Axes numbers are 1-relative, thus 1 is the first axis.
\\Axes numbers exceeding the dimensionality of the array are ignored.
Thus, for example, \texttt{maxs(ARRAY,[2:10])} works for arrays
of any dimensionality and results in a 1-dim array.
\\The function names are the 'plural' forms of the
functions in the previous table.
They can only be used for arrays, thus not for scalars.
\begin{description}
  \item[ \texttt{bool ANYS(bool)}] Is any element true?
  \item[ \texttt{bool ALLS(bool)}] Are all elements true?
  \item[ \texttt{double NTRUES(bool)}] Number of true elements.
  \item[ \texttt{double NFALSES(bool)}] Number of false elements.
  \item[ \texttt{numeric SUMS(numeric)}] Return sum of elements.
  \item[ \texttt{numeric SUMSQUARES(numeric), numeric SUMSQRS(numeric)}]
       Return sum of squared elements.
  \item[ \texttt{numeric PRODUCTS(numeric)}] Return product of elements.
  \item[ \texttt{double MINS(double)}] Return minimum of elements.
  \item[ \texttt{double MAXS(double)}] Return maximum of elements.
  \item[ \texttt{double MEANS(double), double AVG(double)}]
    Return mean of elements.
  \item[ \texttt{double VARIANCES(double)}] Return variance
    (the sum of
    \\\texttt{(a(i) - mean(a))**2/(nelements(a) - 1)}.
  \item[ \texttt{double STDDEVS(double)}] Return standard
    deviation (the square root of the variance).
  \item[ \texttt{double AVDEVS(double)}] Return average deviation.
    (the sum of 
    \\\texttt{abs(a(i) - mean(a))/nelements(a)}.
  \item[ \texttt{double MEDIANS(double)}] Return median (the
    middle element).
    If the array has an even number of elements, the mean of
    the two middle elements is returned.
  \item[ \texttt{double FRACTILES(double, doublescalar fraction)}]
       Return the value of the element at the given fraction.
       Fraction 0.5 is the same as the median.
\end{description}

\subsubsection{Miscellaneous functions}
\begin{description}
  \item[ \texttt{bool ISDEFINED(anytype)}]
    Return false if the value in the current row is undefined. Is
    useful to test if a cell in a column with variable shaped arrays
    contains an array. It can also be used to test if a field in a
    record is defined.
  \item[ \texttt{double NELEMENTS(anytype), double COUNT(anytype)}]
    Return number of elements in an array (1 for a scalar).
  \item[ \texttt{double NDIM(anytype)}]
    Return dimensionality of an array (0 for a scalar).
  \item[ \texttt{doublearray SHAPE(anytype)}]
    Return shape of an array (returns an empty array for a scalar).
  \item[ \texttt{double ROWNUMBER()}]
       Return the row number being tested (first row is row number 1).
       \\In combination with function RAND it can, for instance,
       be used to select arbitrary rows from a table.
  \item[ \texttt{double ROWID()}]
       Return the row number in the original table. This is especially
       useful for returning the result of a selection of a subtable
       of an AIPS++ measurement set
       (see also sections \htmlref{Subqueries}{TAQL:SUBQUERIES}
       and \htmlref{Examples}{TAQL:EXAMPLES}).
  \item[ \texttt{double RAND()}]
       Return (per table row) a uniformly distributed random number
       between 0 and 1 using a Multiplicative Linear Congruential Generator.
       The seeds for the generator are deduced from the current date and
       time, so the results are different from run to run.
       \\The function can, for instance, be used to select a random
       subset from a table.
  \item[ \texttt{anytype IIF(cond,arg1,arg2)}]
       This is a special funtion which operates like the ternary \texttt{?:}
       operator in C++. 
       If all arguments are scalars, the result is a scalar, otherwise
       an array. In the latter case possible scalar arguments are
       virtually expanded to arrays.
       IIF evaluates the condition for each element. If True, it takes
       the corresponding element of \texttt{arg1}, otherwise of \texttt{arg2}.
  \item[ \texttt{anytypearray ARRAY(anytype,shape)}]
       This function creates an array of the given type and shape.
       The shape is given in the last argument(s).
       It can be given in two ways:
       \\- As a single set argument; for example, \texttt{array(0,[3,4])}
       \\- As individual scalar arguments; for example, \texttt{array(0,3,4)}
       \\The first argument gives the values the array is filled with.
       It can be a scalar or an array of any shape. To initialize the
       created array, the value array is flattened to a 1D array.
       Its successive values are stored in the created array. If the
       new array has more values than the value array, the value array is
       reset to its beginning and the process continues.
\end{description}

\subsection{\label{TAQL:COLUMNS}Table Columns}
A column can contain a scalar or an array value.
Note that only columns in the primary table can be handled directly.
A column in another table can be used via a subquery. E.g.
\begin{verbatim}
  SELECT FROM tab WHERE col >
        mean([SELECT othercol FROM othertab])
\end{verbatim}
An expression has to contain at least one column, since columns
are the only variable part in it. That is, a row can only be selected
or sorted by means of the column values in each row.

The name of a column can contain alphanumeric characters and underscores.
It should start with an alphabetic character or underscore.
A column name is case-sensitive.
\\It is possible to use other characters in the name by
escaping them with a backslash. E.g. \texttt{DATE}\verb+\+\texttt{-OBS}.
\\In the same way a numeric character can be used as the first
character of the column name. E.g. \verb+\+\texttt{1stDay}.
\\
Because several words are used in the language, they cannot
be used directly as column names. The reserved words are:
\begin{verbatim}
 ALL AND AS ASC BETWEEN DELETE DESC DISTINCT EXISTS EXCEPT
 FROM GIVING GROUPBY HAVING IN INSERT INTERSECT INTO
 LIKE LIMIT MINUS NODUPLICATES NOT OFFSET OR ORDERBY
 SAVETO SELECT SET UNION UNIQUE UPDATE VALUES WHERE
\end{verbatim}
They can, however, be used as a column name by escaping
them with a backslash. E.g. \verb+\+\texttt{IN}.
\\Note that in C++ and Glish a backslash itself has to be escaped
by another backslash. E.g. in Glish:
\texttt{tab.query('DATE}\verb+\\+\texttt{-OBS$>$10MAR1996')}.

If a column contains a record, one has to specify a field in it
using the dot operator; e.g. \texttt{col.fld} means use field
\texttt{fld} in the column. It is fully recursive, so
\texttt{col.fld.subfld} can be used if field \texttt{fld} is a record
in itself.
\\Alas records in columns are not really supported yet. One can specify
fields, but thereafter an error message will be given.

\subsection{\label{TAQL:KEYWORDS}Table Keywords}
It is possible to use table or column keywords, which can have
a scalar or an array value. A table keyword has to be specified
as \texttt{::key}. In an expression the \texttt{::} part can be omitted
if there is no column with such a name.
A column keyword has to be specified as \texttt{column::key}.
\\Note that the \texttt{::} syntax is chosen, because it is similar
to the scope operator in C++.
\\
As explained in the \htmlref{FROM clause}{TAQL:TABLE_LIST} of the syntax
section, keywords from the primary table and from secondary tables
can be used. If used from a secondary table, it has to be qualified
with the (shorthand) name of the table. E.g.
\\\texttt{sh.key} or \texttt{sh.::key}
\\takes table keyword \texttt{key} from the table with the shorthand name
\texttt{sh}.

If a keyword value is a record, it is possible to use
a field in it using the dot operator. E.g. \texttt{::key.fld}
to use field \texttt{fld}. It is fully recursive, so if the
field is a record in itself, a subfield can be used like
\texttt{col::key.fld.subfld}

A keyword can be used in any expression. It is evaluated immediately
and transformed to a constant value.

\subsection{\label{TAQL:INDEXING}Array Index Operator}
It is possible to take a subsection or a
single element from an array column, keyword or expression
using the index operator
\texttt{[index1,index2,...]}. The rules for this
are similar to those used in Glish.
Taking a single element can be done as:
\begin{verbatim}
  array[1]
  array[1, some_expression]
\end{verbatim}
Taking a subsection can be done as:
\begin{verbatim}
  array[start1:end1:incr1, start2:end2:incr2, ...]
\end{verbatim}
If a start value is left out it defaults to the beginning of
that axis. An end value defaults to the end of the axis and
an increment defaults to one. If an entire axis is left out,
it defaults to the entire axis.
\\E.g. an array with shape [10,15,20] can be subsectioned as:
\begin{verbatim}
  [,,3]              resulting in an array of shape [10,15,1]
  [2:4, ::3, 2:15:2  resulting in an array of shape[3,5,7]
\end{verbatim}
The examples show that an index can be a simple constant (as it will
usually be). It can also be an expression which can be as complex
as one likes. The expression has to result in a positive double value
which will be truncated to an integer length.
\textbf{Note} that as in Glish, array indices start at 1.
\\For fixed shaped arrays checking if array bounds are exceeded
is done at parse time.
For variable shaped arrays
it can only be done per row. If array bounds are exceeded,
an exception is thrown. In the future a special undefined value
will be assigned if bounds of variable shaped arrays are exceeded
to prevent the selection process from aborting due to the exception.

Note that the index operator will be applied directly
to a column. This results in reading only the required part of the
array from the table column on disk.
It is, however, also possible to apply it to a
subexpression (enclosed in parentheses) resulting in an array.
E.g.
\begin{verbatim}
  arraycolumn[2,3,4] + 1
  (arraycolumn + 1)[2,3,4]
\end{verbatim}
can both be used and have the same result. However, the first
form is much faster, because only a single element is read
(resulting in a scalar) and 1 is added to it.
The second form results in reading the entire array.
1 is added to all elements and only then the requested element is taken.
\\From this example it should be clear that indexing an array
expression has to be done with care.

\subsection{\label{TAQL:SETS}Sets and intervals}
As in SQL the operator \texttt{IN} can be used to do a selection
based on an array or a set. E.g.
\begin{verbatim}
  SELECT FROM table WHERE column IN expr1
\end{verbatim}
In this example \texttt{expr1} is the array result of an expression. The result
of operator \texttt{IN} is true if the column value matches one of the
values in the array. It is also possible to use a scalar as the
righthand of operator \texttt{IN}.
So if \texttt{expr1} is a scalar, operator \texttt{IN}
gives the same result as operator \texttt{==}.
\\It is also possible to define a set explicitly. E.g.
\begin{verbatim}
  SELECT FROM table WHERE column IN [expr1, expr2, expr3]
\end{verbatim}
This example shows that (in its simplest form) a set
consists of one or more values (which
can be arbitrary expressions) separated by commas and enclosed in
square brackets. The elements in a set have to be scalars and their
data types have to be the same. The square brackets can be left out if
the set consists of only one element. For SQL compliance
parentheses can be used instead of square brackets.
\\An element in a set can, however, be more complicated and can
define multiple values or an interval. The possible forms of
a set element are:
\begin{enumerate}
\item A single value as shown in the example above.
\item \texttt{start:end:incr}. This is similar to the
way an array index is specified. Incr defaults to 1.
End defaults to an open end (i.e., no upper bound) and results
in an unbounded set. Start and end can be a double or a datetime.
Incr has to be a double. Some examples:
\begin{verbatim}
  1:10     means 1,2,...,10
  1:10:2   means 1,3,5,7,9
  1::2     means all odd numbers
  1:       means all positive integer numbers
  date('18Aug97')::2   means every other day from 18Aug97 on
\end{verbatim}
These examples show constants only, but \texttt{start}, \texttt{end},
and \texttt{incr} can be any expression.
\\Note that :: used here can conflict with the :: in the
\htmlref{keywords}{TAQL:KEYWORDS}. E.g. \texttt{a::b} is scanned as
a keyword specification. If the intention is \texttt{start::incr}
it should be specified as \texttt{a: :b}. In practice this conflict
will hardly ever occur.
\item Continuous intervals can be specified for double, string, and datetime.
The specification of an interval resembles the mathematical notation
\texttt{1<x<5}, where x is replaced by :. An open interval side
is indicated by \texttt{<}, while a closed interval side is indicated
by \texttt{=}.
\\Another way to specify intervals is using curly and/or angle brackets.
A curly bracket is a closed side, the angle bracket is an open side.
The following examples show how bounded and half-bounded,
(half-)open and closed intervals can be specified.
\begin{verbatim}
  1=:=5   {1,5}     means 1<=x<=5   bounded closed
  1<:<5   <1,5>     means 1<x<5     bounded open
  1=:<5   {1,5>     means 1<=x<5    bounded right-open
  1<:=5   <1,5}     means 1<x<=5    bounded left-open
  1=:  {1,}  {1,>   means 1<=x      left-bounded closed
  1<:  <1,}  <1,>   means 1<x       left-bounded open
  :=5  {,5}  <,5}   means x<=5      right-bounded closed
  :<5  {,5>  <,5>   means x<5       right-bounded open
\end{verbatim}
\end{enumerate}
It is very important to note that the 2nd form results in
discrete values, while the 3rd form results in a continuous interval.

Each element in a set can have its own form, i.e., one element can
be a single value while another can be an interval.
If a set consists of single or bounded discrete
\texttt{start:end:incr} values only, the set will be expanded to an
array.
This makes it possible for array operators and functions
(like \texttt{mean}) to be applied to such sets. E.g.
\begin{verbatim}
  WHERE column > mean([10,30:100:5])
\end{verbatim}

Another form of constructing a set is using a
\htmlref{subquery}{TAQL:SUBQUERIES} as shown below.

\subsection{\label{TAQL:SUBQUERIES}Subqueries}
As in SQL it is possible to create a set from a subquery. A
subquery has the same syntax as a main query, but has to be
enclosed in square brackets or parentheses. Basically it looks like:
\begin{verbatim}
  SELECT FROM maintable WHERE time IN
      [SELECT time FROM othertable WHERE windspeed < 5]
\end{verbatim}
The subquery on \texttt{othertable} results in a constant set
containing the times
for which the windspeed matches. Subsequently the main query
is executed and selects all rows from the main table with times in
that set.
Note that like other bounded sets this set is transformed to a
constant array, so it is possible to apply functions to it (e.g. min, mean).
\begin{verbatim}
  SELECT FROM maintable WHERE time IN
      [SELECT time FROM othertable WHERE windspeed <
           mean([SELECT windspeed FROM othertable])]
\end{verbatim}
This contains another subquery to get all windspeeds and
to take the mean of them. So the first subquery selects all times
where the windspeed is less than the average windspeed.
\\A subquery result should contain only one column, otherwise
an exception is thrown.

It may happen that a subquery has to be executed twice because
2 columns from the other table are needed. E.g.
\begin{verbatim}
  SELECT FROM maintable WHERE any(time >=
      [SELECT starttime FROM othertable WHERE windspeed < 5]
                               && time <=
      [SELECT endtime FROM othertable WHERE windspeed < 5])
\end{verbatim}
In this case the other table contains the time range for each windspeed.
For big tables it is expensive to execute the subquery twice.
A better solution
is to store the result of the subquery in a temporary table and reuse it.
\begin{verbatim}
  SELECT FROM othertable WHERE windspeed < 5 GIVING tmptab
  SELECT FROM maintable WHERE any(time >=
      [SELECT starttime FROM tmptab]
                               && time <=
      [SELECT endtime FROM tmptab])
\end{verbatim}
However, this has the disadvantage that the table \texttt{tmptab}
still exists after the query and has to be deleted explictly by the
user. Below a better solution for this problem is shown.

TaQL has a few extensions to support tables better,
in particular the AIPS++ measurement sets.
\begin{enumerate}
\item
The temporary problem above can be circumvented by using the
ability to use a \texttt{SELECT} expression in the \texttt{FROM}
clause. E.g.
\begin{verbatim}
  SELECT FROM maintable,
      [SELECT FROM othertable WHERE windspeed < 5] tmptab
      WHERE any(time >= [SELECT starttime FROM tmptab]
             && time <= [SELECT endtime FROM tmptab])
\end{verbatim}
However, below a even nicer solution is given. 

\item
The time range problem above can be solved elegantly by using
a set as the result of the subquery. Instead of a table name,
it is possible to give an expression in the GIVING clause (as mentioned
in the \htmlref{syntax section}{TAQL:GIVING}). E.g.
\begin{verbatim}
  select from MY.MS where TIME in
      [select FROM OTHERTABLE where WINDSPEED < 5
           giving [TIME-INTERVAL/2 =:= TIME+INTERVAL/2]]
\end{verbatim}
The set expression in the GIVING clause is filled with the
results from the subquery and used in the main query. So if
the subquery results in 5 rows, the resulting set contains 5
intervals. Thereafter the resulting intervals are sorted and combined
where possible. In this way the minimum number of intervals have to be
examined by the main query.

\item
In AIPS++ the other table will often be the name of a subtable,
which is stored in a table or column keyword of the main table.
The standard \htmlref{keyword syntax}{TAQL:KEYWORDS} can be used
to indicate that the other table is the table in the given keyword.
Note that for a table keyword the \texttt{::} part has to be given,
otherwise the name is treated as an ordinary table name. E.g.
\begin{verbatim}
  select from MY.MS where TIME in
      [select TIME from ::WEATHER where WINDSPEED < 5]
\end{verbatim}
In this example the other table is a subtable of table \texttt{my.ms}.
Its name is stored in keyword \texttt{WEATHER} of \texttt{my.ms}.

\item
Often the result of a query on a subtable of a measurement set is
used to select columns from the main table. However, several
subtables do not have an explicit key, but use the row number as
an implicit key. The function \texttt{ROWID()} can be used to
return the row number as the subtable query result. E.g.
\begin{verbatim}
  select from MY.MS where DATA_DESC_ID in
      [select from ::DATA_DESCRIPTION where
         SPECTRAL_WINDOW_ID in [0,2,4] giving [ROWID()]] 
\end{verbatim}
Note that the function \texttt{ROWNUMBER} cannot be used here,
because it will give the row number in the selection and not
(as \texttt{ROWID} does) the row number in the original table.
Furthermore, \texttt{ROWID} gives a 0-relative row number which is
needed to be able to use it as a selection criterium on the 0-relative
values in the measurement set.
\end{enumerate}


\section{Some further remarks}
\subsection{Time/position considerations}
A position constant (e.g. \texttt{3h4m}) is converted to
radians, so it can be used easily in functions like \texttt{SIN}.
Since a time constant has exactly the same format, it is
also converted to radians, while the user may expect it to be
expressed in seconds. The user has to take this into account
if times are used in a comparison. For example, \texttt{timecol $>$ 3h4m}
is only correct if \texttt{timecol} has unit radians.
\\To make life easier the function \texttt{TIME} results in a value
in radians, so it can be used directly in a comparison. For example,
\texttt{TIME(datecolumn) $>$ 3h4m}.
\\In the future this may change if units are handled in their full glory.

\subsection{Optimization}
A lot of development work can be done to improve the query optimization.
At this stage a few optimizations are done.
\begin{itemize}
\item Constant subexpressions are calculated only once. E.g.
\\in \texttt{COL*sin(180/pi)} the part \texttt{sin(180/pi)} is
evaluated once.
\item If a subquery generates intervals of doubles or dates, overlapping
intervals are combined and eliminated. E.g.
\begin{verbatim}
select from GER.MS where TIME in [select from ::POINTING where
sumsqr(DIRECTION[1])>0 giving [TIME-INTERVAL/2=:=TIME+INTERVAL/2]]
\end{verbatim}
can generate many identical or overlapping intervals. They are
sorted and combined where possible to make the set as small as possible.
\end{itemize}

However, the user can optimize a query by specifying the expression
carefully. Especially when using operator $\mid\mid$ or \&\&,
attention should be
paid to the contents of the left and right branches. Both operators
evaluate the right branch only if needed, so the left branch
should be the shortest one, i.e., the fastest to evaluate.

The user should also use functions, operators, and subqueries in a careful way.
\begin{itemize}

\item
\texttt{SQUARE(COL)} is (much) faster than \texttt{COL}\verb+^+\texttt{2}
or \texttt{POW(COL,2)}, because SQUARE is faster.
It is also faster than \texttt{COL*COL}, because it accesses column
\texttt{COL} only once.
\\Similarly \texttt{SQRT(COL)} is faster than \texttt{COL}\verb+^+\texttt{0.5}
or \texttt{POW(COL,0.5)}

\item
\texttt{SQUARE(U) + SQUARE(V) $<$ 1000}\verb+^+\texttt{2} is considerably faster
than
\\\texttt{SQRT(SQUARE(U) + SQUARE(V)) $<$ 1000}, because the
\texttt{SQRT} function does not need to be evaluated for each row.

\item
\texttt{TIME IN [$0<:<4$]} is faster than
\texttt{TIME$>$0 \&\& TIME$<$4}, because in the first way the column is
accessed only once.

\item
Returning a column from a subquery can be done directly or as a
set. E.g.
\begin{verbatim}
  SELECT FROM maintable WHERE time IN
      [SELECT time FROM othertable WHERE windspeed < 5]
\end{verbatim}
could also be expressed as
\begin{verbatim}
  SELECT FROM maintable WHERE time IN
      [SELECT FROM othertable WHERE windspeed < 5 GIVING [time]]
\end{verbatim}
The latter (as a set) is slower. So, if possible, the column should
be returned directly. This is also easier to write.
\\An even more important optimization for this query is writing it as:
\begin{verbatim}
  SELECT FROM maintable WHERE time IN
      [SELECT DISTINCT time FROM othertable WHERE windspeed < 5]
\end{verbatim}
Using the DISTINCT qualifier has the effect that duplicates are
removed which often results in a much smaller set.

\item
Testing if a subquery contains at least N elements can be done in two
ways:
\begin{verbatim}
  count([select column from table where expression]) >= N
and
  exists (select from table where expression limit N)
\end{verbatim}
The second form is by far the best, because in that case the subquery
will stop the matching process as soon as N matching rows are found.
The second form will do the subquery for the entire table.
\\Furthermore in the first form a column has to be selected, which is
not needed in the second form.

\item
Sometimes operator \texttt{IN} and function \texttt{ANY} can be used to test
if an element in an array matches a value. E.g.
\begin{verbatim}
  WHERE any(arraycolumn == value)
and
  WHERE value IN arraycolumn
\end{verbatim}
give the same result.
Operator \texttt{IN} is faster because it stops when it finds a
match. If using \texttt{ANY} all elements are compared first and thereafter
\texttt{ANY} tests the resulting bool array.

\item
It was already shown in the \htmlref{indexing section}{TAQL:INDEXING}
that indexing arrays should be done with care.
\end{itemize}


\section{\label{TAQL:MODIFYING}Modifying a table}
Usually TaQL will be used to get a subset from a table. However, as
described in the first sections, it can also be used to change the
contents of a table using the UPDATE, INSERT, or DELETE command.
Note that a table has to be writable, otherwise those commands
exit with an error message.

\subsection{UPDATE}
\begin{verbatim}
  UPDATE table_list SET update_list [WHERE ...] [ORDERBY ...]
                                    [LIMIT ...] [OFFSET ...]
\end{verbatim}
updates selected rows in a table.
\\\texttt{update\_list}
is a comma-separated list of \texttt{column=expression} parts.
Each part tells to update the given column using the
expression. Both scalar and array columns are supported.
E.g.
\begin{verbatim}
  UPDATE vla.ms SET ANTENNA1=ANTENNA1-1, ANTENNA2=ANTENNA2-1
\end{verbatim}
to make the antenna numbers zero-based if accidently they were
written one-based.
\\If an array gets an array value, the shape of the array can be
changed (provided it is allowed for that table column).
Arrays can also be updated with a scalar value causing all elements
in the array to be set to that scalar value.

It is also possible to update part of an array using
\htmlref{array indexing}{TAQL:INDEXING}. E.g.
\begin{verbatim}
  UPDATE vla.ms SET FLAG[1,1]=T
  UPDATE vla.ms SET FLAG[1,]=T
\end{verbatim}
The first example sets only the first array element, while the second
one sets an entire row in the array. The second example also
shows that it is possible to set an array to a scalar value.

Type promotion and demotion will be done as much as possible.
For example, an integer column can get the value of a double
expression (which will be truncated).

Note that if multiple \texttt{column=expression} parts are given,
the columns are changed in the order as specified in the update-list.
It means that if an updated column is used in an expression for
a later column, the new value is used when evaluating the
expression. E.g. in
\begin{verbatim}
  UPDATE vla.ms SET DATA=DATA+1, SUMD=sum(DATA)
\end{verbatim}
the \texttt{SUMD} update uses the new \texttt{DATA} values.
    

\subsection{INSERT}
The \texttt{INSERT} command adds rows to the table. It can take two forms:
\begin{verbatim}
  INSERT INTO table_list [(column_list)] VALUES (expr_list)
  INSERT INTO table_list [(column_list)] SELECT_command
\end{verbatim}
The first form adds one row to the table and puts the values given in
the expression list into the columns given in the column list.
If the column list is not given, it defaults to all stored columns in
the table in the order as they appear in the table description.
Each expression in the expression list can be as complex as needed;
for example, a subquery can also be given. Note that a subquery is
evaluated before the new row is added, so the new row is not taken
into account if the subquery is done on the table being modified.
\\It should be clear that the number of columns has to match the
number of expressions.
\\Note that row cells not mentioned in the column list,
are not written, thus may contain rubbish.
\\The data types of expressions and columns have to match in the same way
as for the UPDATE command; values have to be promotable or demotable
to the column data type.
\\For example:
\begin{verbatim}
  INSERT INTO my.ms (ANTENNA1,ANTENNA2) VALUES (0,1)
\end{verbatim}
adds one row, puts 0 in ANTENNA1 and 1 in ANTENNA2.

The second form evaluates the SELECT command and copies the rows
found in the selection to the table being modified (which is given
in the INTO part).
The columns used in the modified table are defined in the column list.
As above, they default to all stored columns. The columns used in the
selection have to be defined in the SELECT part of the SELECT command.
They also default to all stored columns.
\\For example:
\begin{verbatim}
  INSERT INTO my.ms select FROM my.ms
\end{verbatim}
appends all rows and columns of \texttt{my.ms} to itself.
Please note that only the original number of rows is copied.
\begin{verbatim}
  INSERT INTO my.ms (ANTENNA1,ANTENNA2) select ANTENNA2,ANTENNA1
   FROM other.ms WHERE ANTENNA1>0
\end{verbatim}
copies rows from \texttt{other.ms} where ANTENNA1$>$0. It swaps the
values of ANTENNA1 and ANTENNA2. All other columns are not written,
thus may contain rubbish.

\subsection{DELETE}
\begin{verbatim}
  DELETE FROM table_list
    [WHERE ...] [ORDERBY ...] [LIMIT ...] [OFFSET ...]
\end{verbatim}
deletes some or all rows from a table.
\begin{verbatim}
  DELETE FROM my.ms WHERE ANTENNA1>13 OR ANTENNA2>13
\end{verbatim}
deletes the rows matching the WHERE expression.
\\If no selection is done, all rows will be deleted.
\\It is possible to specify more than one table in the FROM clause to
be able to use, for example, keywords from other tables.
Rows will be deleted from the first table mentioned in the FROM part.


\section{Examples}
\begin{description}
  \item[] \texttt{ SELECT FROM mytable WHERE column1 $>$ 0 }
    \\selects the rows in which the value of column1 $>$ 0

  \item[] \texttt{ SELECT column0,column1 FROM mytable }
    \\selects 2 columns from the table.

  \item[] \texttt{ SELECT column0,column1 FROM mytable WHERE column1$>$0 }
    \\is a combination of the previous selections.

  \item[] \texttt{ SELECT FROM [SELECT FROM mytable ORDERBY column0 DESC] }
    \\\texttt{ WHERE rownumber()$<=$10 }
    \\selects the 10 highest values of \texttt{column0}.

  \item[] \texttt{ SELECT FROM mytable ORDERBY column0 DESC LIMIT 10 }
    \\is a more elegant solution using the newer LIMIT clause.

  \item[] \texttt{ SELECT FROM mytable ORDERBY column0 DESC GIVING outtable }
    \\\texttt{ SELECT FROM outtable WHERE rownumber()$<=$10 }
    \\is the SQL-like solution for the previous problem.
    It is less elegant, because it requires two steps.

  \item[] \texttt{ SELECT FROM mytable WHERE column0 IN }
    \\\texttt{ [SELECT column0 FROM mytable ORDERBY column0 DESC][1:10] }
    \\is similar to above, but can select more values if there happen
    to be several equal values.

  \item[] \texttt{ SELECT FROM some.MS WHERE }
    \\\texttt{ near(TIME/(24*3600),MJD(1999/03/30/17:27:15)) }
    \\selects the rows with the given time from a MeasurementSet.
    \\Note that the TIME is stored in seconds; the division converts
        it to days.

   \item[] \texttt{ SELECT FROM some.MS where TIME/(24*3600) in }
     \\\texttt{ [\{MJD(1999/03/30/17:27:15),MJD(1999/03/30/17:29:15)\}] }
     \\selects the rows in the given closed time interval.

   \item[] \texttt{ SELECT FROM some.MS where TIME/(24*3600) in }
     \\\texttt{ [MJD(1999/03/30/17:27:15),MJD(1999/03/30/17:29:15)] }
     \\selects the rows having one of the given times.
     \\Note the difference with the previous example where an interval
     was given. Here a set of two individual time values is given.

  \item[] \texttt{ SELECT FROM resource.table WHERE}
     \\\texttt{any(PValues == pattern('synth*'))}
     \\selects the rows in which an element in array
     \texttt{PValues} matches the given regular expression.

  \item[] \texttt{ SELECT FROM table WHERE ntrue(flags) >= 3}
     \\selects rows where at least 3 elements of array \texttt{flags}
     are set.

  \item[] \texttt{ SELECT FROM book.table WHERE nelements(author) > 1}
     \\selects books with more than 1 author.

  \item[] \texttt{ SELECT FROM my.ms WHERE
         any(ANTENNA1==[0,0,1] \&\& ANTENNA2==[1,3,2])}
     \\selects the antenna pairs (baselines) 0-1, 0-3, and 1-2.
     \\Note that the two comparisons result in a boolean vector. If
       a bool in the and-ed vectors is true, that baseline matches.

  \item[] \texttt{ SELECT FROM mytable WHERE}
     \\\texttt{ cos(0d1m) $<$
         sin(52deg) * sin(DEC) + cos(52deg) * cos(DEC) *
         cos(3h30m - RA) }
     \\selects observations with an equatorial position (in say J2000)
     inside a circle with a radius of 1 arcmin around (3h30m, 52deg).
     To find them the condition DISTANCE$<=$RADIUS must be fulfilled,
     which is equivalent to COS(RADIUS)$<=$COS(DISTANCE).
     \\Note that in the future this useful astronomical test could
     be implemented as a function of its own (with better optimization
     possibilities).

  \item[] \texttt{ SELECT FROM mytable WHERE object == pattern("3C*") \&\&}
     \\\texttt{cos(0d1m) $<$ sin(52deg) * sin(DEC) + cos(52deg) *
        cos(DEC) * cos(3h30m - RA) }
     \\finds all 3C objects inside that circle.

  \item[] \texttt{ select from MY.MS where DATA\_DESC\_ID in}
      \\\texttt{[select from ::DATA\_DESCRIPTION where}
      \\\texttt{SPECTRAL\_WINDOW\_ID in [0,2,4] giving [ROWID()]]}
      \\finds all rows in a measurement set matching the given
      spectral windows.

  \item[] \texttt{ select from MY.MS where TIME in}
      \\\texttt{[select from ::SOURCE where REST\_FREQUENCY $<$ 180000000.}
      \\\texttt{giving [TIME-INTERVAL/2 =:= TIME+INTERVAL/2]]}
      \\finds all rows in a measurement set observing sources with a
      rest frequency less than 180 Mhz.

  \item[] \texttt{ select from MS,}
      \\\texttt{[select from MS where sumsqr(UVW[1:2]) < 625] as TIMESEL}
      \\\texttt{ where TIME in [select distinct TIME from TIMESEL]}
      \\\texttt{   \&\& any([ANTENNA1,ANTENNA2] in [select from TIMESEL giving}
      \\\texttt{                      [iif(UVW[3] < 0, ANTENNA1, ANTENNA2)]])}
      \\finds all antennas which are shadowed at a given time.
      \\The query in the FROM command finds all rows where an antenna
      is shadowed (i.e. its UV-distance less than 25 meters) and
      creates a temporary table. This selection is done in the FROM
      command, otherwise two 2 equal selections are needed in the main
      WHERE command.
      
  \item[] \texttt{ select from MS}
      \\\texttt{where DATA\_DESC\_ID in [select from ::DATA\_DESCRIPTION}
      \\\texttt{where SPECTRAL\_WINDOW\_ID in [select from ::SPECTRAL\_WINDOW}
      \\\texttt{where NET\_SIDEBAND==1 giving [ROWID()]] giving [ROWID()]]}
      \\finds all rows in the MeasurementSet with the given
      NET\_SIDEBAND.
      \\The MeasurementSet uses a table to map spectral-window-id to
      data-desc-id. Hence two nested subqueries are needed.
\end{description}

\subsection{Modification examples}
\begin{description}
  \item[] \texttt{ update MY.MS set VIDEO\_POINT=MEANS(DATA,2)
                   where isdefined(DATA) }
      \\sets the VIDEO\_POINT of each correlation to the mean of the
      DATA for that correlation. Note that the 2 indicates averaging over
      the second axis, thus the frequency axis.

  \item[] \texttt{ update MY.MS set FLAG\_ROW=T where isdefined(FLAG) \&\& all(FLAG)}
      \\sets FLAG\_ROW in the rows where the entire FLAG array is set.

  \item[] \texttt{ delete from MY.MS where FLAG\_ROW}
      \\deletes all flagged rows.

  \item[] \texttt{ insert into MY.MS select from OTHER.MS where !FLAG\_ROW}
      \\copies all unflagged rows from OTHER.MS to MY.MS.

  \item[] \texttt{ insert into MY.MS/DATA\_DESCRIPTION}
          \\\texttt{(SPECTRAL\_WINDOW\_ID,POLARIZATION\_ID,FLAG\_ROW)}
          \\\texttt{values (1,0,F)}
      \\adds a row to the DATA\_DESCRIPTION subtable and initializes it.
                   
\end{description}


\section{\label{TAQL:GLISHC}Interface to TaQL}
There exists a user and a programmer interface to TaQL.
Glish functions form the user interface, while C++ functions
and classes form the programmer interface.
\begin{itemize}
\item
  The main TaQL interface in Glish is formed by the
  \htmlref{\texttt{query}}{table:query} function in module
  \htmlref{\texttt{table}}{table} (in script \texttt{table.g}).
  The function can be used
  to compose and execute a TaQL command using the various (optional)
  arguments given to the \texttt{query} function. E.g.
  \begin{verbatim}
    tab := table('mytable')
    seltab1 := tab.query ('column1 > 0')
    seltab2 := seltab1.query (query='column2>5',
                              sortlist='time',
                              columns='column1,column2',
                              name='result.tab')
  \end{verbatim}
  The first command opens the table \texttt{mytable}.
  The second command does a simple query resulting in a temporary
  table. That temporary table is used in the next command resulting in
  a persistent table. The latter function call is transformed to
  the TaQL command:
  \\\texttt{SELECT column1,column2 FROM \$1 WHERE column2>5}
  \\\texttt{ORDERBY time GIVING result.tab}
  \\During execution \$1 is replaced by table \texttt{seltab1}.
  \\Note that the \texttt{name} argument
  generates the \texttt{GIVING} part to make the result persistent.

  It is possible to embed glish variables and expressions in a TaQL
  command using the syntax \texttt{\$variable} and
  \texttt{\$(expression)}. A variable can be a standard numeric or
  string scalar or vector. It can also be a table tool.
  An expression has to result in a numeric or string scalar or vector.
  E.g
  \begin{verbatim}
    tab := table('mytable')
    coldata := tab.getcol ('col');
    colmean := sum(coldata) / len(coldata);
    seltab1 := tab.query ('col > $colmean')
    seltab2 := tab.query ('col > $(sum(coldata)/len(coldata))')
    seltab3 := tab.query ('col > mean([SELECT col from $tab])')
  \end{verbatim}
  These three queries give the same result.
  \\The substitution mechanism is described in more detail in the
  \htmlref{\texttt{substitute}}{misc:substitute}
  functions of module
  \htmlref{\texttt{utility}}{misc} of the
  \htmladdnormallink{User Reference
  Manual}{../../user/Refman/Refman.html}.
  \\The substitution mechanism uses the eval function in glish.
  As of 28-Feb-2001 eval only looks at global variables. This means
  that in a function one needs to create a global variable (with
  a unique name) if the variable is to be used in a TaQL command.
  The global variable should be deleted at the end of the function.
  The name can be made unique by using the function name as a suffix.
  E.g.:
  \begin{verbatim}
    myfunc := function() {
      tab := table('mytable')
      global coldata_in_myfunc;
      coldata_in_myfunc := tab.getcol ('col');
      seltab := tab.query ('col > $(sum(coldata)/len(coldata))')
      symbol_delete ('coldata_in_myfunc');
    }
  \end{verbatim}

  The other function that can be used is \texttt{tablecommand}. The
  full TaQL command has to be given to that command. The result is
  a table tool. E.g.
  \begin{verbatim}
    t := tablecommand('select from GER.MS where ANTENNA1==1');
  \end{verbatim}  

\item
  The C++ interface consists of 2 parts.
  \begin{enumerate}
  \item
    The function \texttt{tableCommand} in
    \htmladdnormallink{TableParse.h}
    {../../aips/implement/Tables/TableParse.html}
    can be used to execute a TaQL command. The result is a
    \htmladdnormallink{Table}{../../aips/implement/Tables/Table.html}
    object. E.g.
\begin{verbatim}
  Table seltab1 = tableCommand
         ("select from mytable where column1>0");
  Table seltab2 = tableCommand
         ("select column1,column2 from $1 where column2>5"
          " orderby time giving result.tab", seltab1);
\end{verbatim}
    These examples do the same as the Glish ones shown above.
    \\Note that in the second function call the table name
    \texttt{\$1} is replaced by the object \texttt{seltab1}
    passed to the function.

  \item
    The other interface is a true C++ interface having the
    advantage that C++ variables can be used. Class
    \htmladdnormallink{Table}{../../aips/implement/Tables/Table.html}
    contains functions to sort a table or to select columns or rows.
    When selecting rows class \htmladdnormallink{TableExprNode}
    {../../aips/implement/Tables/ExprNode.html} (in ExprNode.h)
    has to be used to
    build a WHERE expression which can be executed by the overloaded
    function operator in class \texttt{Table}. E.g.
\begin{verbatim}
  Int limit = 0;
  Table tab ("mytable");
  Table seltab = tab(tab.col("column1") > limit);
\end{verbatim}
    does the same as the first example shown above.
    See classes \htmladdnormallink{Table}
    {../../aips/implement/Tables/Table.html},
    \htmladdnormallink{TableExprNode}
    {../../aips/implement/Tables/ExprNode.html}, and
    \htmladdnormallink{TableExprNodeSet}
    {../../aips/implement/Tables/ExprNodeSet.html} for more
    information on how to construct a WHERE expression.
  \end{enumerate}
  
\end{itemize}

\section{Possible future developments}
In the near or far future TaQL will be enhanced by adding new
features and by doing optimizations.
\begin{itemize}
  \item If a branch in an \texttt{OR} or \texttt{AND} node is a
    constant scalar, it might be possible to reduce the node to
    one of its branches.
  \item Optimize by removing an \texttt{IN} node if the righthand
    operand is empty. This cannot be done if the lefthand operand
    is variable shaped.
  \item Handle invalid subexpressions (e.g. exceeding array bounds)
    as undefined values
    which can be tested with the function ISDEFINED.
  \item Interpret column units defined in a column keyword UNIT.
  \item Add a function (say POSITIONINCIRCLE or PINC) to search in a circle
       around a position.
  \item Maybe functions to convert positions from one equinox or system
       to another (using the Measures system).
  \item Optimize using a B+ tree index.
  \item Expressions in the selected column-list to calculate new columns. E.g.
       \\\texttt{SELECT SQUARE(UVW[1])+SQUARE(UVW[2]) UVWNORM FROM ...}
       \\where \texttt{UVWNORM} is the name for that new column.
\end{itemize}
