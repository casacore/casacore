<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>casacore: Tables_module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">casacore
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Tables_module<div class="ingroups"><a class="el" href="group__tables.html">tables package (libcasa_tables)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>CTDS (Casacore <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> Data System) is the data storage mechanism for Casacore.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__Tables__module__internal__classes"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tables__module__internal__classes.html">Tables_module_internal_classes</a></td></tr>
<tr class="memdesc:group__Tables__module__internal__classes"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal Tables_module classes and functions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayColumn.html">casacore::ArrayColumn&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and write access to an array table column with arbitrary data type.  <a href="classcasacore_1_1ArrayColumn.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayColumnBase.html">casacore::ArrayColumnBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and write access to an array table column with arbitrary data type.  <a href="classcasacore_1_1ArrayColumnBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1BaseSlicesFunctor.html">casacore::BaseSlicesFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract baseclass for slices functors.  <a href="classcasacore_1_1BaseSlicesFunctor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1GetCellSlices.html">casacore::GetCellSlices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to get irregular array slices from a cell.  <a href="classcasacore_1_1GetCellSlices.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1GetColumnSlices.html">casacore::GetColumnSlices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to get irregular array slices from a column.  <a href="classcasacore_1_1GetColumnSlices.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1PutCellSlices.html">casacore::PutCellSlices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to put irregular array slices into a cell.  <a href="classcasacore_1_1PutCellSlices.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1PutColumnSlices.html">casacore::PutColumnSlices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to get irregular array slices from a column.  <a href="classcasacore_1_1PutColumnSlices.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ArrayColumnDesc.html">casacore::ArrayColumnDesc&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated class for description of table array columns.  <a href="classcasacore_1_1ArrayColumnDesc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ColumnDesc.html">casacore::ColumnDesc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Envelope class for the description of a table column.  <a href="classcasacore_1_1ColumnDesc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ColumnsIndex.html">casacore::ColumnsIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index to one or more columns in a table.  <a href="classcasacore_1_1ColumnsIndex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ColumnsIndexArray.html">casacore::ColumnsIndexArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index to an array column in a table.  <a href="classcasacore_1_1ColumnsIndexArray.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcasacore_1_1ReadAsciiTable__global__functions__readAsciiTable.html">casacore::ReadAsciiTable_global_functions_readAsciiTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filling a table from an Ascii file.  <a href="structcasacore_1_1ReadAsciiTable__global__functions__readAsciiTable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1RowCopier.html">casacore::RowCopier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1RowCopier.html" title="RowCopier copies all or part of a row from one table to another. ">RowCopier</a> copies all or part of a row from one table to another.  <a href="classcasacore_1_1RowCopier.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ScalarColumnDesc.html">casacore::ScalarColumnDesc&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated class to define columns of scalars in tables.  <a href="classcasacore_1_1ScalarColumnDesc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ScalarColumn.html">casacore::ScalarColumn&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to a scalar table column with arbitrary data type.  <a href="classcasacore_1_1ScalarColumn.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ScalarRecordColumnDesc.html">casacore::ScalarRecordColumnDesc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to define columns of scalar records in tables.  <a href="classcasacore_1_1ScalarRecordColumnDesc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1SetupNewTable.html">casacore::SetupNewTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new table - define shapes, data managers, etc.  <a href="classcasacore_1_1SetupNewTable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1StorageOption.html">casacore::StorageOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options defining how table files are organized.  <a href="classcasacore_1_1StorageOption.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1SubTableDesc.html">casacore::SubTableDesc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of columns containing tables.  <a href="classcasacore_1_1SubTableDesc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1Table.html">casacore::Table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main interface class to a read/write table.  <a href="classcasacore_1_1Table.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableColumn.html">casacore::TableColumn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/write access to a table column.  <a href="classcasacore_1_1TableColumn.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableCopy.html">casacore::TableCopy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class with static functions for copying a table.  <a href="classcasacore_1_1TableCopy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableDesc.html">casacore::TableDesc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the structure of a Casacore table.  <a href="classcasacore_1_1TableDesc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableError.html">casacore::TableError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base error class for storage manager.  <a href="classcasacore_1_1TableError.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableInternalError.html">casacore::TableInternalError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal table error.  <a href="classcasacore_1_1TableInternalError.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableDuplFile.html">casacore::TableDuplFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; table (description) already exists.  <a href="classcasacore_1_1TableDuplFile.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableNoFile.html">casacore::TableNoFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; table (description) not found.  <a href="classcasacore_1_1TableNoFile.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableDescNoName.html">casacore::TableDescNoName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; no name given to table description.  <a href="classcasacore_1_1TableDescNoName.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableInvOpt.html">casacore::TableInvOpt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; invalid table (description) option.  <a href="classcasacore_1_1TableInvOpt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableNoDatFile.html">casacore::TableNoDatFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; table.dat file not found.  <a href="classcasacore_1_1TableNoDatFile.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableInvType.html">casacore::TableInvType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; table type mismatch.  <a href="classcasacore_1_1TableInvType.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableInvColumnDesc.html">casacore::TableInvColumnDesc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; invalid column description.  <a href="classcasacore_1_1TableInvColumnDesc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableInvHyperDesc.html">casacore::TableInvHyperDesc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; invalid hypercolumn description.  <a href="classcasacore_1_1TableInvHyperDesc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableUnknownDesc.html">casacore::TableUnknownDesc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; unknown column description.  <a href="classcasacore_1_1TableUnknownDesc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableInvDT.html">casacore::TableInvDT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; invalid data type.  <a href="classcasacore_1_1TableInvDT.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableInvOper.html">casacore::TableInvOper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; invalid operation.  <a href="classcasacore_1_1TableInvOper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableArrayConformanceError.html">casacore::TableArrayConformanceError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; non-conformant array.  <a href="classcasacore_1_1TableArrayConformanceError.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableConformanceError.html">casacore::TableConformanceError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; table length conformance error.  <a href="classcasacore_1_1TableConformanceError.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableInvSort.html">casacore::TableInvSort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; invalid sort.  <a href="classcasacore_1_1TableInvSort.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableInvLogic.html">casacore::TableInvLogic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; invalid logical operation.  <a href="classcasacore_1_1TableInvLogic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableInvExpr.html">casacore::TableInvExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; invalid select expression.  <a href="classcasacore_1_1TableInvExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableVectorNonConform.html">casacore::TableVectorNonConform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; non-conformant table vectors.  <a href="classcasacore_1_1TableVectorNonConform.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableParseError.html">casacore::TableParseError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> error; invalid table command.  <a href="classcasacore_1_1TableParseError.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableGramError.html">casacore::TableGramError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> grammar error; invalid table command.  <a href="classcasacore_1_1TableGramError.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableIndexProxy.html">casacore::TableIndexProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for table index access.  <a href="classcasacore_1_1TableIndexProxy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableIterator.html">casacore::TableIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through a <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a>.  <a href="classcasacore_1_1TableIterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableIterProxy.html">casacore::TableIterProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for table iterator access.  <a href="classcasacore_1_1TableIterProxy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableLocker.html">casacore::TableLocker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to hold a (user) lock on a table.  <a href="classcasacore_1_1TableLocker.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableProxy.html">casacore::TableProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level interface to tables.  <a href="classcasacore_1_1TableProxy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableRecord.html">casacore::TableRecord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hierarchical collection of named fields of various types.  <a href="classcasacore_1_1TableRecord.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1ROTableRow.html">casacore::ROTableRow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Readonly access to a table row.  <a href="classcasacore_1_1ROTableRow.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableRow.html">casacore::TableRow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/write access to a table row.  <a href="classcasacore_1_1TableRow.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableRowProxy.html">casacore::TableRowProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for table row access.  <a href="classcasacore_1_1TableRowProxy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcasacore_1_1TableVector.html">casacore::TableVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated readonly table column vectors.  <a href="classcasacore_1_1TableVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcasacore_1_1TabVecMath__global__functions__basicMath.html">casacore::TabVecMath_global_functions_basicMath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic math for table vectors.  <a href="structcasacore_1_1TabVecMath__global__functions__basicMath.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcasacore_1_1TabVecMath__global__functions__basicTransMath.html">casacore::TabVecMath_global_functions_basicTransMath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transcendental math for table vectors.  <a href="structcasacore_1_1TabVecMath__global__functions__basicTransMath.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcasacore_1_1TabVecMath__global__functions__advTransMath.html">casacore::TabVecMath_global_functions_advTransMath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Further transcendental math for table vectors.  <a href="structcasacore_1_1TabVecMath__global__functions__advTransMath.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcasacore_1_1TabVecMath__global__functions__miscellaneous.html">casacore::TabVecMath_global_functions_miscellaneous</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Miscellaneous table vector operations.  <a href="structcasacore_1_1TabVecMath__global__functions__miscellaneous.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcasacore_1_1TabVecMath__global__functions__vectorMath.html">casacore::TabVecMath_global_functions_vectorMath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcasacore_1_1Vector.html" title="A 1-D Specialization of the Array class. ">Vector</a> operations on a table vector.  <a href="structcasacore_1_1TabVecMath__global__functions__vectorMath.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>CTDS (Casacore <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> Data System) is the data storage mechanism for Casacore. </p>
<p><a class="anchor" id="Tables_module_anchor"></a> </p>
<p>See <a href="#Tables_module_Class_List">below</a> for an overview of the classes in this module. </p>
<h3>Intended use:</h3>
<p>Public interface</p>
<h3>Review Status</h3>
<dl>
<dt>Reviewed By:</dt>
<dd>jhorstko</dd>
<dt>Date Reviewed:</dt>
<dd>1994/08/30</dd>
</dl>
<h3>Prerequisite</h3>
<ul>
<li>
<a class="el" href="classcasacore_1_1Record.html">Record</a> class </li>
</ul>
<h3>Etymology</h3>
<p>"Table" is a formal term from relational database theory: <em> "The organizing principle in a relational database is the TABLE,
 a rectangular, row/column arrangement of data values."</em> Casacore tables are extensions to traditional tables, but are similar enough that we use the same name. There is also a strong resemblance between the uses of Casacore tables, and <a class="el" href="classcasacore_1_1FITS.html" title="static functions and enumerations ">FITS</a> binary tables, which provides another reason to use "Tables" to describe the Casacore data storage mechanism.</p>
<h3>Synopsis</h3>
<p>Tables are the fundamental storage mechanism for Casacore. This document explains <a href="#Tables:motivation">why</a> they had to be made, <a href="#Tables:properties">what</a> their properties are, and <a href="#Tables:open">how</a> to use them. The last subject is discussed and illustrated in a sequence of sections: </p>
<ul>
<li>
<a href="#Tables:open">opening</a> an existing table, </li>
<li>
<a href="#Tables:read">reading</a> from a table, </li>
<li>
<a href="#Tables:creation">creating</a> a new table, </li>
<li>
<a href="#Tables:write">writing</a> into a table, </li>
<li>
<a href="#Tables:row-access">accessing rows</a> in a table, </li>
<li>
<a href="#Tables:select and sort">selection and sorting</a> (see also <a href="../notes/199.html">Table Query Language</a>), </li>
<li>
<a href="#Tables:concatenation">concatenating similar tables</a> </li>
<li>
<a href="#Tables:iterate">iterating</a> through a table, </li>
<li>
<a href="#Tables:LockSync">locking/synchronization</a> for concurrent access, </li>
<li>
<a href="#Tables:KeyLookup">indexing</a> a table for faster lookup, </li>
<li>
<a href="#Tables:vectors">vector operations</a> on a column. </li>
<li>
<a href="#Tables:performance">performance and robustness</a> considerations with some information on <a href="#Tables:iotracing">IO tracing</a>. </li>
</ul>
<p>A few <a href="Tables:applications">applications</a> exist to inspect and manipulate a table.</p>
<p>Several UML diagrams describe the class structure of the Tables module. </p>
<ul>
<li>
<a href="TableOverview.drawio.svg.html">Global overview of Table access</a>. </li>
<li>
<a href="TableDesc.drawio.svg.html">Table and column descriptions</a>. </li>
<li>
<a href="TableRecord.drawio.svg.html">Table keywords</a>. </li>
<li>
<a href="Table.drawio.svg.html">Table class structure</a>. </li>
<li>
<a href="PlainTable.drawio.svg.html">Detailed PlainTable class structure</a>. </li>
<li>
<a href="DataManager.drawio.svg.html">DataManagers for storage</a>. </li>
</ul>
<p><a class="anchor" id="Tables_motivation"></a><a class="anchor" id="Tables:motivation"></a> </p>
<h3>Motivation</h3>
<p>The Casacore tables are mainly based upon the ideas of Allen Farris, as laid out in the <a href="http://aips2.cv.nrao.edu/aips++/docs/reference/Database.ps.gz">AIPS++ Database document</a>, from where the following paragraph is taken:</p>
<p>Traditional relational database tables have two features that decisively limit their applicability to scientific data. First, an item of data in a column of a table must be atomic &ndash; it must have no internal structure. A consequence of this restriction is that relational databases are unable to deal with arrays of data items. Second, an item of data in a column of a table must not have any direct or implied linkages to other items of data or data aggregates. This restriction makes it difficult to model complex relationships between collections of data. While these restrictions may make it easy to define a mathematically complete set of data manipulation operations, they are simply intolerable in a scientific data-handling context. Multi-dimensional arrays are frequently the most natural modes in which to discuss and think about scientific data. In addition, scientific data often requires complex calibration operations that must draw on large bodies of data about equipment and its performance in various states. The restrictions imposed by the relational model make it very difficult to deal with complex problems of this nature. </p>
<p>In response to these limitations, and other needs, the Casacore tables were designed.</p>
<p><a class="anchor" id="Tables_properties"></a><a class="anchor" id="Tables:properties"></a> </p>
<h3><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> Properties</h3>
<p>Casacore tables have the following properties: </p>
<ul>
<li>
A table consists of a number of rows and columns. <a href="#Tables:keywords">Keyword/value pairs</a> may be defined for the table as a whole and for individual columns. A keyword/value pair for a column could, for instance, define its unit. </li>
<li>
Each table has a <a href="#Tables:Table Description">description</a> which specifies the number and type of columns, and maybe initial keyword sets and default values for the columns. </li>
<li>
A cell in a column may contain <ul>
<li>
a scalar; </li>
<li>
a "direct" array &ndash; which must have the same shape in all cells of a column, is usually small, and is stored in the table itself; </li>
<li>
an "indirect" array &ndash; which may have different shapes in different cells of the same column, is arbitrarily large, and is stored in a separate file; </li>
</ul>
</li>
<li>
A column may be <ul>
<li>
"filled" &ndash; containing actual data, or </li>
<li>
"virtual" &ndash; containing a recipe telling how the data will be generated dynamically </li>
</ul>
</li>
<li>
Only the standard Casacore data types can be used in filled columns, be they scalars or arrays: Bool, uChar, Short, uShort, Int, uInt, Int64, float, double, Complex, DComplex and <a class="el" href="classcasacore_1_1String.html" title="String: the storage and methods of handling collections of characters. ">String</a>. Furthermore scalars containing <a class="el" href="classcasacore_1_1TableRecord.html">record</a> values are possible </li>
<li>
A column can have a default value, which will automatically be stored in a cell of the column, when a row is added to the table. </li>
<li>
<a href="#Tables:Data Managers">Data managers</a> handle the reading, writing and generation of data. Each column in a table can be assigned its own data manager, which allows for optimization of the data storage per column. The choice of data manager determines whether a column is filled or virtual. </li>
<li>
<a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> data are stored in a canonical format, so they can be read on any machine. To avoid needless swapping of bytes, the data can be stored in big endian (as used on e.g. SUN) or little endian (as used on Intel PC-s) canonical format. By default it uses the format specified in the aipsrc variable <code>table.endianformat</code> which defaults to <code><a class="el" href="classcasacore_1_1Table.html#a65e02b6f560c596cb5dde2d07dcb0cb3abd0262b41bb6c9e9c33ac859fd7bfc85" title="store data in the endian format of the machine used ">Table::LocalEndian</a></code> (the endian format of the machine being used when creating the table). </li>
<li>
The SQL-like <a href="../notes/199.html">Table Query Language</a> (TaQL) can be used to do operations on tables like select, sort, update, insert, delete, and create. </li>
</ul>
<p>Tables can be in one of four forms: </p>
<ul>
<li>
A plain table is a table stored on disk. It can be shared by multiple processes. </li>
<li>
A memory table is a table held in memory. It is a process specific table, thus not sharable. The <a class="el" href="classcasacore_1_1Table.html">Table::copy</a> function can be used to turn a memory table into a plain table. </li>
<li>
A reference table is a table referencing a plain or memory table. It is the result of a selection or sort on another table. A reference table references the data in the other table, thus changing data in a reference table means that the data in the original table are changed. The <a class="el" href="classcasacore_1_1Table.html">Table::deepCopy</a> function can be used to turn a reference table into a plain table. </li>
<li>
<a href="#Tables:concatenation">a concatenated table</a> is a union of tables (of any form) with the same description. They are concatenated in a virtual way, thus no copy is made. </li>
</ul>
<p>Concurrent access from different processes to the same plain table is fully supported by means of a <a href="#Tables:LockSync">locking/synchronization</a> mechanism. Concurrent access over NFS is also supported. </p>
<p>A (somewhat primitive) mechanism is available to do a <a href="#Tables:KeyLookup">table lookup</a> based on the contents of a key.</p>
<p><a class="anchor" id="Tables_open"></a><a class="anchor" id="Tables:open"></a> </p>
<h3>Opening an Existing <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a></h3>
<p>To open an existing table you just create a <a class="el" href="classcasacore_1_1Table.html">Table</a> object giving the name of the table, like:</p>
<div class="fragment"><div class="line">Table readonly_table (<span class="stringliteral">&quot;tableName&quot;</span>);</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line">Table read_and_write_table (<span class="stringliteral">&quot;tableName&quot;</span>, <a class="code" href="classcasacore_1_1Table.html#a6c62d60a9691364e3aaaf137ea73cde0a8637ba6591ac13499d937d318cdfa4f6">Table::Update</a>);</div>
</div><!-- fragment --><p>The constructor option determines whether the table will be opened as readonly or as read/write. A readonly table file must be opened as readonly, otherwise an exception is thrown. The functions <a class="el" href="classcasacore_1_1Table.html">Table::isWritable(...)</a> can be used to determine if a table is writable.</p>
<p>When the table is opened, the data managers are reinstantiated according to their definition at table creation. </p>
<p><a class="anchor" id="Tables_openTable"></a><a class="anchor" id="Tables:openTable"></a> The static function <code><a class="el" href="namespacecasacore_1_1TableUtil.html#a0e1ee59142b9ed85df3efc719b64bddc" title="Try to open a table. ">TableUtil::openTable</a></code> can be used to open a table, in particular a subtable, in a simple way by means of the :: notation like <code>maintable::subtable</code>. The :: notation is much better than specifying an explicit path (such as <code>maintable/subtable</code>, because it also works fine if the main table is a reference table (e.g. the result of a selection).</p>
<p><a class="anchor" id="Tables_read"></a><a class="anchor" id="Tables:read"></a> </p>
<h3>Reading from a <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a></h3>
<p>You can read data from a table column with the "get" functions in the classes <a class="el" href="classcasacore_1_1ScalarColumn.html">ScalarColumn&lt;T&gt;</a> and <a class="el" href="classcasacore_1_1ArrayColumn.html">ArrayColumn&lt;T&gt;</a>. For scalars of a standard data type (i.e. Bool, uChar, Int, Short, uShort, uInt, float, double, Complex, DComplex and <a class="el" href="classcasacore_1_1String.html" title="String: the storage and methods of handling collections of characters. ">String</a>) you could instead use <a class="el" href="classcasacore_1_1TableColumn.html">TableColumn::getScalar(...)</a> or <a class="el" href="classcasacore_1_1TableColumn.html">TableColumn::asXXX(...)</a>. These functions offer an extra: they do automatic data type promotion; so that you can, for example, get a double value from a float column.</p>
<p>These "get" functions are used in the same way as the simple "put" functions described in the previous section. </p>
<p><a class="el" href="classcasacore_1_1ScalarColumn.html">ScalarColumn&lt;T&gt;</a> can be constructed for a non-writable column. However, an exception is thrown if the put function is used for it. The same is true for <a class="el" href="classcasacore_1_1ArrayColumn.html">ArrayColumn&lt;T&gt;</a> and <a class="el" href="classcasacore_1_1TableColumn.html">TableColumn</a>. </p>
<p>A typical program could look like: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Table_8h.html">casacore/tables/Tables/Table.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ScalarColumn_8h.html">casacore/tables/Tables/ScalarColumn.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ArrayColumn_8h.html">casacore/tables/Tables/ArrayColumn.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Vector_8h.html">casacore/casa/Arrays/Vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Slicer_8h.html">casacore/casa/Arrays/Slicer.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ArrayMath_8h.html">casacore/casa/Arrays/ArrayMath.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line"><span class="comment">// Open the table (readonly).</span></div>
<div class="line">Table tab (<span class="stringliteral">&quot;some.name&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Construct the various column objects.</span></div>
<div class="line"><span class="comment">// Their data type has to match the data type in the table description.</span></div>
<div class="line">ScalarColumn&lt;Int&gt; acCol (tab, <span class="stringliteral">&quot;ac&quot;</span>);</div>
<div class="line">ArrayColumn&lt;Float&gt; arr2Col (tab, <span class="stringliteral">&quot;arr2&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Loop through all rows in the table.</span></div>
<div class="line"><a class="code" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> nrrow = tab.nrow();</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> i=0; i&lt;nrow; i++) {</div>
<div class="line"><span class="comment">// Read the row for both columns.</span></div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Column ac in row i = &quot;</span> &lt;&lt; acCol(i) &lt;&lt; endl;</div>
<div class="line">Array&lt;Float&gt; <a class="code" href="namespacecasacore.html#a72e8481a74e808b5facfb20a2352d075">array</a> = arr2Col.<a class="code" href="classcasacore_1_1TableExprNode.html#af9920e0b8ad9261c0cf8868542170c37">get</a> (i);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Show the entire column ac,</span></div>
<div class="line"><span class="comment">// and show the 10th element of arr2 in each row.\.</span></div>
<div class="line">cout &lt;&lt; ac.getColumn();</div>
<div class="line">cout &lt;&lt; arr2.getColumn (Slicer(Slice(10)));</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Tables_creation"></a><a class="anchor" id="Tables:creation"></a> </p>
<h3>Creating a <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a></h3>
<p>The creation of a table is a multi-step process: </p>
<ol>
<li>
Create a <a href="#Tables:Table Description">table description</a>. </li>
<li>
Create a <a class="el" href="classcasacore_1_1SetupNewTable.html">SetupNewTable</a> object with the name of the new table. </li>
<li>
Create the necessary <a href="#Tables:Data Managers">data managers</a>. </li>
<li>
Bind each column to the appropriate data manager. The system will bind unbound columns to data managers which are created internally using the default data manager name defined in the column description. </li>
<li>
Define the shape of direct columns (if that was not already done in the column description). </li>
<li>
Create the <a class="el" href="classcasacore_1_1Table.html">Table</a> object from the <a class="el" href="classcasacore_1_1SetupNewTable.html" title="Create a new table - define shapes, data managers, etc. ">SetupNewTable</a> object. Here, a final check is performed and the necessary files are created. </li>
</ol>
<p>The recipe above is meant for the creation a plain table, but the creation of a memory table is exactly the same. The only difference is that in call to construct the <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> object the <a class="el" href="classcasacore_1_1Table.html#ac8328c6b0f8cfbe9f75ffdd76c618203a139c2ff29ff642a1372838781a7d82f9" title="table held in memory ">Table::Memory</a> type has to be given. Note that in the <a class="el" href="classcasacore_1_1SetupNewTable.html" title="Create a new table - define shapes, data managers, etc. ">SetupNewTable</a> object the columns can be bound to any data manager. <code><a class="el" href="classcasacore_1_1MemoryTable.html" title="Class for a table held in memory. ">MemoryTable</a></code> will rebind stored columns to the <a class="el" href="classcasacore_1_1MemoryStMan.html">MemoryStMan</a> storage manager, but virtual columns bindings are not changed.</p>
<p>The following example shows how you can create a table. An example specifically illustrating the creation of the <a href="#Tables:Table Description">table description</a> is given in that section. Other sections discuss the access to the table.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="TableDesc_8h.html">casacore/tables/Tables/TableDesc.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="SetupNewTab_8h.html">casacore/tables/Tables/SetupNewTab.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Table_8h.html">casacore/tables/Tables/Table.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ScaColDesc_8h.html">casacore/tables/Tables/ScaColDesc.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ScaRecordColDesc_8h.html">casacore/tables/Tables/ScaRecordColDesc.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ArrColDesc_8h.html">casacore/tables/Tables/ArrColDesc.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;casacore/tables/Tables/StandardStMan.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;casacore/tables/Tables/IncrementalStMan.h&gt;</span></div>
<div class="line"></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line"><span class="comment">// Step1 -- Build the table description.</span></div>
<div class="line">TableDesc td(<span class="stringliteral">&quot;tTableDesc&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <a class="code" href="classcasacore_1_1TableDesc.html#a70d5536aba94ee3dbf7d86ce4114c001afc8cc51a7425b0a20d551ea45907c21c">TableDesc::Scratch</a>);</div>
<div class="line">td.comment() = <span class="stringliteral">&quot;A test of class SetupNewTable&quot;</span>;</div>
<div class="line">td.addColumn (ScalarColumnDesc&lt;Int&gt; (<span class="stringliteral">&quot;ab&quot;</span>,<span class="stringliteral">&quot;Comment for column ab&quot;</span>));</div>
<div class="line">td.addColumn (ScalarColumnDesc&lt;Int&gt; (<span class="stringliteral">&quot;ac&quot;</span>));</div>
<div class="line">td.addColumn (ScalarColumnDesc&lt;uInt&gt; (<span class="stringliteral">&quot;ad&quot;</span>,<span class="stringliteral">&quot;comment for ad&quot;</span>));</div>
<div class="line">td.addColumn (ScalarColumnDesc&lt;Float&gt; (<span class="stringliteral">&quot;ae&quot;</span>));</div>
<div class="line">td.addColumn (ScalarRecordColumnDesc (<span class="stringliteral">&quot;arec&quot;</span>));</div>
<div class="line">td.addColumn (ArrayColumnDesc&lt;Float&gt; (<span class="stringliteral">&quot;arr1&quot;</span>,3,<a class="code" href="classcasacore_1_1ColumnDesc.html#a8345327ae9b644267a43d970370ef129a4f9ea1574b345a35326f151d80dafc0f">ColumnDesc::Direct</a>));</div>
<div class="line">td.addColumn (ArrayColumnDesc&lt;Float&gt; (<span class="stringliteral">&quot;arr2&quot;</span>,0));</div>
<div class="line">td.addColumn (ArrayColumnDesc&lt;Float&gt; (<span class="stringliteral">&quot;arr3&quot;</span>,0,<a class="code" href="classcasacore_1_1ColumnDesc.html#a8345327ae9b644267a43d970370ef129a4f9ea1574b345a35326f151d80dafc0f">ColumnDesc::Direct</a>));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Step 2 -- Setup a new table from the description.</span></div>
<div class="line">SetupNewTable newtab(<span class="stringliteral">&quot;newtab.data&quot;</span>, td, <a class="code" href="classcasacore_1_1Table.html#a6c62d60a9691364e3aaaf137ea73cde0a72527bb2e368badd05319f61ab3dee6f">Table::New</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Step 3 -- Create storage managers for it.</span></div>
<div class="line">StandardStMan stmanStand_1;</div>
<div class="line">StandardStMan stmanStand_2;</div>
<div class="line">IncrementalStMan stmanIncr;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Step 4 -- First, bind all columns to the first storage</span></div>
<div class="line"><span class="comment">// manager. Then, bind a few columns to another storage manager</span></div>
<div class="line"><span class="comment">// (which will overwrite the previous bindings).</span></div>
<div class="line">newtab.bindAll (stmanStand_1);</div>
<div class="line">newtab.bindColumn (<span class="stringliteral">&quot;ab&quot;</span>, stmanStand_2);</div>
<div class="line">newtab.bindColumn (<span class="stringliteral">&quot;ae&quot;</span>, stmanIncr);</div>
<div class="line">newtab.bindColumn (<span class="stringliteral">&quot;arr3&quot;</span>, stmanIncr);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Step 5 -- Define the shape of the direct columns.</span></div>
<div class="line"><span class="comment">// (this could have been done in the column description).</span></div>
<div class="line">newtab.setShapeColumn(<span class="stringliteral">&quot;arr1&quot;</span>, IPosition(3,2,3,4));</div>
<div class="line">newtab.setShapeColumn(<span class="stringliteral">&quot;arr3&quot;</span>, IPosition(3,3,4,5));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Step 6 -- Finally, create the table consisting of 10 rows.</span></div>
<div class="line">Table tab(newtab, 10);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Now we can fill the table, which is shown in a next section.</span></div>
<div class="line"><span class="comment">// The Table destructor will flush the table to the files.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> To create a table in memory, only step 6 has to be modified slightly to: </p>
<div class="fragment"><div class="line">Table tab(newtab, <a class="code" href="classcasacore_1_1Table.html#ac8328c6b0f8cfbe9f75ffdd76c618203a139c2ff29ff642a1372838781a7d82f9">Table::Memory</a>, 10);</div>
</div><!-- fragment --><p>Note that the function <code><a class="el" href="namespacecasacore_1_1TableUtil.html#a4438de1a5d55d9242741a3802e8a42d1" title="Create a table with the given name and description. ">TableUtil::createTable</a></code> can be used to create a table in a simpler way. It can also be used to create a subtable using the :: notation similar to the <a href="#Tables:openTable"><code>Tableutil::openTable</code></a> function described above.</p>
<p><a class="anchor" id="Tables_write"></a><a class="anchor" id="Tables:write"></a> </p>
<h3>Writing into a <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a></h3>
<p>Once a table has been created or has been opened for read/write, you want to write data into it. Before doing that you may have to add one or more rows to the table. <br/>
<b>Tip:</b><em> If a table was created with a given number of rows, you do not need to add rows; you may not even be able to do so; </em><br/>
</p>
<p>When adding new rows to the table, either via the <a class="el" href="classcasacore_1_1Table.html">Table(...) constructor</a> or via the <a class="el" href="classcasacore_1_1Table.html">Table::addRow(...)</a> function, you can choose to have those rows initialized with the default values given in the description.</p>
<p>To actually write the data into the table you need the classes <a class="el" href="classcasacore_1_1ScalarColumn.html">ScalarColumn&lt;T&gt;</a> and <a class="el" href="classcasacore_1_1ArrayColumn.html">ArrayColumn&lt;T&gt;</a>. For each column you can construct one or more of these objects. Their put(...) functions let you write a value at a time or the entire column in one go. For arrays you can "put" subsections of the arrays.</p>
<p>As an alternative for scalars of a standard data type (i.e. Bool, uChar, Int, Short, uShort, uInt, float, double, Complex, DComplex and <a class="el" href="classcasacore_1_1String.html" title="String: the storage and methods of handling collections of characters. ">String</a>) you could use the functions <a class="el" href="classcasacore_1_1TableColumn.html">TableColumn::putScalar(...)</a>. These functions offer an extra: automatic data type promotion; so that you can, for example, put a float value in a double column.</p>
<p>A typical program could look like: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="TableDesc_8h.html">casacore/tables/Tables/TableDesc.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="SetupNewTab_8h.html">casacore/tables/Tables/SetupNewTab.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Table_8h.html">casacore/tables/Tables/Table.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ScaColDesc_8h.html">casacore/tables/Tables/ScaColDesc.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ArrColDesc_8h.html">casacore/tables/Tables/ArrColDesc.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ScalarColumn_8h.html">casacore/tables/Tables/ScalarColumn.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ArrayColumn_8h.html">casacore/tables/Tables/ArrayColumn.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Vector_8h.html">casacore/casa/Arrays/Vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Slicer_8h.html">casacore/casa/Arrays/Slicer.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ArrayMath_8h.html">casacore/casa/Arrays/ArrayMath.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line"><span class="comment">// First build the table description.</span></div>
<div class="line">TableDesc td(<span class="stringliteral">&quot;tTableDesc&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <a class="code" href="classcasacore_1_1TableDesc.html#a70d5536aba94ee3dbf7d86ce4114c001afc8cc51a7425b0a20d551ea45907c21c">TableDesc::Scratch</a>);</div>
<div class="line">td.comment() = <span class="stringliteral">&quot;A test of class SetupNewTable&quot;</span>;</div>
<div class="line">td.addColumn (ScalarColumnDesc&lt;Int&gt; (<span class="stringliteral">&quot;ac&quot;</span>));</div>
<div class="line">td.addColumn (ArrayColumnDesc&lt;Float&gt; (<span class="stringliteral">&quot;arr2&quot;</span>,0));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setup a new table from the description,</span></div>
<div class="line"><span class="comment">// and create the (still empty) table.</span></div>
<div class="line"><span class="comment">// Note that since we do not explicitly bind columns to</span></div>
<div class="line"><span class="comment">// data managers, all columns will be bound to the default</span></div>
<div class="line"><span class="comment">// standard storage manager StandardStMan.</span></div>
<div class="line">SetupNewTable newtab(<span class="stringliteral">&quot;newtab.data&quot;</span>, td, <a class="code" href="classcasacore_1_1Table.html#a6c62d60a9691364e3aaaf137ea73cde0a72527bb2e368badd05319f61ab3dee6f">Table::New</a>);</div>
<div class="line">Table tab(newtab);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Construct the various column objects.</span></div>
<div class="line"><span class="comment">// Their data type has to match the data type in the description.</span></div>
<div class="line">ScalarColumn&lt;Int&gt; ac (tab, <span class="stringliteral">&quot;ac&quot;</span>);</div>
<div class="line">ArrayColumn&lt;Float&gt; arr2 (tab, <span class="stringliteral">&quot;arr2&quot;</span>);</div>
<div class="line">Vector&lt;Float&gt; vec2(100);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Write the data into the columns.</span></div>
<div class="line"><span class="comment">// In each cell arr2 will be a vector of length 100.</span></div>
<div class="line"><span class="comment">// Since its shape is not set explicitly, it is done implicitly.</span></div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> i=0; i&lt;10; i++) {</div>
<div class="line">tab.addRow();               <span class="comment">// First add a row.</span></div>
<div class="line">ac.put (i, i+10);           <span class="comment">// value is i+10 in row i</span></div>
<div class="line"><a class="code" href="namespacecasacore.html#a3cd469ce2294c9f726fe06d19f1fa0c7">indgen</a> (vec2, <span class="keywordtype">float</span>(i+20)); <span class="comment">// vec2 gets i+20, i+21,..., i+119</span></div>
<div class="line">arr2.put (i, vec2); </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Finally, show the entire column ac,</span></div>
<div class="line"><span class="comment">// and show the 10th element of arr2.</span></div>
<div class="line">cout &lt;&lt; ac.getColumn();</div>
<div class="line">cout &lt;&lt; arr2.getColumn (Slicer(Slice(10)));</div>
<div class="line"></div>
<div class="line"><span class="comment">// The Table destructor writes the table.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In this example we added rows in the for loop, but we could also have created 10 rows straightaway by constructing the <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> object as: </p>
<div class="fragment"><div class="line">Table tab(newtab, 10);</div>
</div><!-- fragment --><p> in which case we would not include </p>
<div class="fragment"><div class="line">tab.addRow()</div>
</div><!-- fragment --><p>The classes <a class="el" href="classcasacore_1_1TableColumn.html">TableColumn</a>, <a class="el" href="classcasacore_1_1ScalarColumn.html">ScalarColumn&lt;T&gt;</a>, and <a class="el" href="classcasacore_1_1ArrayColumn.html">ArrayColumn&lt;T&gt;</a> contain several functions to put values into a single cell or into the whole column. This may look confusing, but is actually quite simple. The functions can be divided in two groups: </p>
<ol>
<li>
<p class="startli">Put the given value into the column cell(s). </p>
<ul>
<li>
The simplest put functions, <a class="el" href="classcasacore_1_1ScalarColumn.html">ScalarColumn::put(...)</a> and <a class="el" href="classcasacore_1_1ArrayColumn.html">ArrayColumn::put(...)</a>, put a value into the given column cell. For convenience, there is an <a class="el" href="classcasacore_1_1ArrayColumn.html">ArrayColumn::putSlice(...)</a> to put only a part of the array. </li>
<li>
<a class="el" href="classcasacore_1_1ScalarColumn.html">ScalarColumn::fillColumn(...)</a> and <a class="el" href="classcasacore_1_1ArrayColumn.html">ArrayColumn::fillColumn(...)</a> fill an entire column by putting the given value into all the cells of the column. </li>
<li>
The simplest putColumn functions, <a class="el" href="classcasacore_1_1ScalarColumn.html">ScalarColumn::putColumn(...)</a> and <a class="el" href="classcasacore_1_1ArrayColumn.html">ArrayColumn::putColumn(...)</a>, put an array of values into the column. There is a special <a class="el" href="classcasacore_1_1ArrayColumn.html">ArrayColumn::putColumn(...)</a> version which puts only a part of the arrays. </li>
</ul>
<p class="endli"></p>
</li>
<li>
Copy values from another column to this column.<br/>
 These functions have the advantage that the data type of the input and/or output column can be unknown. The generic <a class="el" href="classcasacore_1_1TableColumn.html" title="Read/write access to a table column. ">TableColumn</a> objects can be used for this purpose. The put(Column) function checks the data types and, if possible, converts them. If the conversion is not possible, it throws an exception. <ul>
<li>
The put functions copy the value in a cell of the input column to a cell in the output column. The row numbers of the cells in the columns can be different. </li>
<li>
The putColumn functions copy the entire contents of the input column to the output column. The lengths of the columns must be equal. </li>
</ul>
Each class has its own set of these functions. <ul>
<li>
<a class="el" href="classcasacore_1_1TableColumn.html">TableColumn::put(...)</a> and <a class="el" href="classcasacore_1_1TableColumn.html">TableColumn::putColumn(...)</a> and are the most generic. They can be used if the data types of both input and output column are unknown. Note that these functions are virtual. </li>
<li>
<a class="el" href="classcasacore_1_1ScalarColumn.html">ScalarColumn::put(...)</a>, <a class="el" href="classcasacore_1_1ArrayColumn.html">ArrayColumn::put(...)</a>, <a class="el" href="classcasacore_1_1ScalarColumn.html">ScalarColumn::putColumn(...)</a>, and <a class="el" href="classcasacore_1_1ArrayColumn.html">ArrayColumn::putColumn(...)</a> are less generic and therefore potentially more efficient. The most efficient variants are the ones taking a Scalar/ArrayColumn&lt;T&gt;, because they require no data type conversion. </li>
</ul>
</li>
</ol>
<p><a class="anchor" id="Tables_row-access"></a><a class="anchor" id="Tables:row-access"></a> </p>
<h3>Accessing rows in a <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a></h3>
<p>Apart from accessing a table column-wise as described in the previous two sections, it is also possible to access a table row-wise. The <a class="el" href="classcasacore_1_1TableRow.html">TableRow</a> class makes it possible to access multiple fields in a table row as a whole. Note that like the XXColumn classes described above, there is also an <a class="el" href="classcasacore_1_1ROTableRow.html" title="Readonly access to a table row. ">ROTableRow</a> class for access to readonly tables. </p>
<p>On construction of a <a class="el" href="classcasacore_1_1TableRow.html" title="Read/write access to a table row. ">TableRow</a> object it has to be specified which fields (i.e. columns) are part of the row. For these fields a fixed structured <a class="el" href="classcasacore_1_1TableRecord.html">TableRecord</a> object is constructed as part of the <a class="el" href="classcasacore_1_1TableRow.html" title="Read/write access to a table row. ">TableRow</a> object. The <a class="el" href="classcasacore_1_1ROTableRow.html#a78f864cbc9c3c32faee87af3fbcd928f" title="Get the values of all columns used from the given row. ">TableRow::get</a> function will fill this record with the table data for the given row. The user has access to the record and can use <a class="el" href="classcasacore_1_1RecordFieldPtr.html">RecordFieldPtr</a> objects for speedier access to the record. </p>
<p>The class could be used as shown in the following example. </p>
<div class="fragment"><div class="line"><span class="comment">// Open the table as readonly and define a row object to contain</span></div>
<div class="line"><span class="comment">// the given columns.</span></div>
<div class="line"><span class="comment">// Note that the function stringToVector is a very convenient</span></div>
<div class="line"><span class="comment">// way to construct a Vector&lt;String&gt;.</span></div>
<div class="line"><span class="comment">// Show the description of the fields in the row.</span></div>
<div class="line">Table table(<span class="stringliteral">&quot;Some.table&quot;</span>);</div>
<div class="line">ROTableRow row (table, <a class="code" href="ArrayIO_8h.html#a8fc155a8dfaabbc7e2ef6f67775a70aa">stringToVector</a>(<span class="stringliteral">&quot;col1,col2,col3&quot;</span>));</div>
<div class="line">cout &lt;&lt; row.record().description();</div>
<div class="line"><span class="comment">// Since the structure of the record is known, the RecordFieldPtr</span></div>
<div class="line"><span class="comment">// objects could be used to allow for easy and fast access to</span></div>
<div class="line"><span class="comment">// the record which is refilled for each get.</span></div>
<div class="line">RORecordFieldPtr&lt;String&gt; col1(row.record(), <span class="stringliteral">&quot;col1&quot;</span>);</div>
<div class="line">RORecordFieldPtr&lt;Double&gt; col2(row.record(), <span class="stringliteral">&quot;col2&quot;</span>);</div>
<div class="line">RORecordFieldPtr&lt;Array&lt;Int&gt; &gt; col3(row.record(), <span class="stringliteral">&quot;col3&quot;</span>);</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> i=0; i&lt;table.nrow(); i++) {</div>
<div class="line">row.get (i);</div>
<div class="line">someString = *col1;</div>
<div class="line">somedouble = *col2;</div>
<div class="line">someArrayInt = *col3;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The description of <a class="el" href="classcasacore_1_1TableRow.html" title="Read/write access to a table row. ">TableRow</a> contains some more extensive examples.</p>
<p><a class="anchor" id="Tables_select_and_sort"></a><a class="anchor" id="Tables:select and sort"></a> </p>
<h3><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> Selection and Sorting</h3>
<p>The result of a select and sort of a table is another table, which references the original table. This means that an update of a sorted or selected table results in the update of the original table. The result is, however, a table in itself, so all table functions (including select and sort) can be used with it. Note that a true copy of such a reference table can be made with the <a class="el" href="classcasacore_1_1Table.html">Table::deepCopy</a> function. </p>
<p>Rows or columns can be selected from a table. Columns can be selected by the <a class="el" href="classcasacore_1_1Table.html">Table::project(...)</a> function, while rows can be selected by the various <a class="el" href="classcasacore_1_1Table.html">Table operator()</a> functions. Usually a row is selected by giving a select expression with <a class="el" href="classcasacore_1_1TableExprNode.html">TableExprNode</a> objects. These objects represent the various nodes in an expression, e.g. a constant, a column, or a subexpression. The <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> function <a class="el" href="classcasacore_1_1Table.html">Table::col(...)</a> creates a <a class="el" href="classcasacore_1_1TableExprNode.html" title="Handle class for a table column expression tree. ">TableExprNode</a> object for a column. The function <a class="el" href="classcasacore_1_1Table.html">Table::key(...)</a> does the same for a keyword by reading the keyword value and storing it as a constant in an expression node. All column nodes in an expression must belong to the same table, otherwise an exception is thrown. In the following example we select all rows with RA&gt;10: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;casacore/tables/Tables/ExprNode.h&gt;</span></div>
<div class="line">Table table (<span class="stringliteral">&quot;Table.name&quot;</span>);</div>
<div class="line">Table result = table (table.col(<span class="stringliteral">&quot;RA&quot;</span>) &gt; 10);</div>
</div><!-- fragment --><p> while in the next one we select rows with RA and DEC in the given intervals: </p>
<div class="fragment"><div class="line">Table result = table (table.col(<span class="stringliteral">&quot;RA&quot;</span>) &gt; 10</div>
<div class="line">&amp;&amp; table.col(<span class="stringliteral">&quot;RA&quot;</span>) &lt; 14</div>
<div class="line">&amp;&amp; table.col(<span class="stringliteral">&quot;DEC&quot;</span>) &gt;= -10</div>
<div class="line">&amp;&amp; table.col(<span class="stringliteral">&quot;DEC&quot;</span>) &lt;= 10);</div>
</div><!-- fragment --><p> The following operators can be used to form arbitrarily complex expressions: </p>
<ul>
<li>
Relational operators ==, !=, &gt;, &gt;=, &lt; and &lt;=. </li>
<li>
Logical operators &amp;&amp;, || and !. </li>
<li>
Arithmetic operators +, -, *, /, %, and unary + and -. </li>
<li>
Bit operators ^, &amp;, |, and unary ~. </li>
<li>
Operator() to take a subsection of an array. </li>
</ul>
<p>Many functions (like sin, max, conj) can be used in an expression. Class <a class="el" href="classcasacore_1_1TableExprNode.html">TableExprNode</a> shows the available functions. E.g. </p>
<div class="fragment"><div class="line">Table result = table (<a class="code" href="namespacecasacore.html#a763d957004a4bfed935f5fa6a8be9417">sin</a> (table.col(<span class="stringliteral">&quot;RA&quot;</span>)) &gt; 0.5);</div>
</div><!-- fragment --><p> <a class="el" href="classcasacore_1_1Function.html" title="Numerical functional interface class. ">Function</a> <code>in</code> can be used to select from a set of values. A value set can be constructed using class <a class="el" href="classcasacore_1_1TableExprNodeSet.html">TableExprNodeSet</a>. </p>
<div class="fragment"><div class="line">TableExprNodeSet set;</div>
<div class="line">set.add (TableExprNodeSetElem (<span class="stringliteral">&quot;abc&quot;</span>));</div>
<div class="line">set.add (TableExprNodeSetElem (<span class="stringliteral">&quot;defg&quot;</span>));</div>
<div class="line">set.add (TableExprNodeSetElem (<span class="stringliteral">&quot;h&quot;</span>));</div>
<div class="line">Table result = table (table.col(<span class="stringliteral">&quot;NAME).in (set));</span></div>
</div><!-- fragment --><p> select rows with a NAME equal to <code>abc</code>, <code>defg</code>, or <code>h</code>.</p>
<p>You can sort a table on one or more columns containing scalars. In this example we simply sort on column RA (default is ascending): </p>
<div class="fragment"><div class="line">Table table (<span class="stringliteral">&quot;Table.name&quot;</span>);</div>
<div class="line">Table result = table.sort (<span class="stringliteral">&quot;RA&quot;</span>);</div>
</div><!-- fragment --><p> Multiple <a class="el" href="classcasacore_1_1Table.html">Table::sort(...)</a> functions exist which allow for more flexible control over the sort order. In the next example we sort first on RA in descending order and then on DEC in ascending order: </p>
<div class="fragment"><div class="line">Table table (<span class="stringliteral">&quot;Table.name&quot;</span>);</div>
<div class="line">Block&lt;String&gt; sortKeys(2);</div>
<div class="line">Block&lt;int&gt;    sortOrders(2);</div>
<div class="line">sortKeys(0)   = <span class="stringliteral">&quot;RA&quot;</span>;</div>
<div class="line">sortOrders(0) = <a class="code" href="classcasacore_1_1Sort.html#a8c6d6c1ed95e2848332f370b3acf9c8ca5d1faf306457ef2c5eb7fdda6286ecc5">Sort::Descending</a>;</div>
<div class="line">sortKeys(1)   = <span class="stringliteral">&quot;DEC&quot;</span>;</div>
<div class="line">sortOrders(1) = <a class="code" href="classcasacore_1_1Sort.html#a8c6d6c1ed95e2848332f370b3acf9c8ca673791f898abcfa422fe314bdba2dd2e">Sort::Ascending</a>;</div>
<div class="line">Table result = table.sort (sortKeys, sortOrders);</div>
</div><!-- fragment --><p>Tables stemming from the same root, can be combined in several ways with the help of the various logical <a class="el" href="classcasacore_1_1Table.html">Table operators</a> (operator|, etc.).</p>
<h4><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> Query Language</h4>
<p>The selection and sorting mechanism described above can only be used in a hard-coded way in a C++ program. There is, however, another way. Strings containing selection and sorting commands can be used. The syntax of these commands is based on SQL and is described in the <a href="../notes/199.html">Table Query Language</a> (TaQL) note 199. The language supports UDFs (User Defined Functions) in dynamically loadable libraries as explained in the note. <br/>
A TaQL command can be executed with the static function <code>tableCommand</code> defined in class <a class="el" href="classcasacore_1_1TableParse.html">TableParse</a>.</p>
<p><a class="anchor" id="Tables_concatenation"></a><a class="anchor" id="Tables:concatenation"></a> </p>
<h3><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> Concatenation</h3>
<p>Tables with identical descriptions can be concatenated in a virtual way using the <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> concatenation constructor. Such a <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> object behaves as any other <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> object, thus any operation can be performed on it. An identical description means that the number of columns, the column names, and their data types of the columns must be the same. The columns do not need to be ordered in the same way nor to be stored in the same way. <br/>
Note that if tables have different column names, it is possible to form a projection (as described in the previous section) first to make them appear identical.</p>
<p>Sometimes a <a class="el" href="classcasacore_1_1MeasurementSet.html" title="A Table intended to hold astronomical data (a set of Measurements). ">MeasurementSet</a> is partitioned, for instance in chunks of one hour. All those chunks can be virtually concatenated this way. Note that all tables in the concatenation will be opened, thus one might run out of file descriptors if there are many chunks.</p>
<p>Similar to reference tables, it is possible to make a concatenated <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> persistent by using the <code>rename</code> function. It will not copy the data; only the names of the tables used are written.</p>
<p>The keywords of a concatenated table are taken from the first table. It is possible to change or add keywords, but that is not persistent, not even if the concatenated table is made persistent. <br/>
The keywords holding subtables can be handled in a special way. Normally the subtables of the concatenation are the subtables of the first table are used, but is it possible to concatenate subtables as well by giving their names in the constructor. In this way the, say, SYSCAL subtable of a <a class="el" href="classcasacore_1_1MeasurementSet.html" title="A Table intended to hold astronomical data (a set of Measurements). ">MeasurementSet</a> can be concatenated as well. </p>
<div class="fragment"><div class="line"><span class="comment">// Create virtual concatenation of ms0 and ms1.</span></div>
<div class="line">Block&lt;String&gt; names(2);</div>
<div class="line">names[0] = <span class="stringliteral">&quot;ms0&quot;</span>;</div>
<div class="line">names[1] = <span class="stringliteral">&quot;ms1&quot;</span>;</div>
<div class="line"><span class="comment">// Also concatenate their SYSCAL subtables.</span></div>
<div class="line">Block&lt;String&gt; subNames(1, <span class="stringliteral">&quot;SYSCAL&quot;</span>);</div>
<div class="line">Table concTab (names, subNames);</div>
</div><!-- fragment --><p><a class="anchor" id="Tables_iterate"></a><a class="anchor" id="Tables:iterate"></a> </p>
<h3><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> Iterators</h3>
<p>You can iterate through a table in an arbitrary order by getting a subset of the table consisting of the rows in which the iteration columns have the same value. An iterator object is created by constructing a <a class="el" href="classcasacore_1_1TableIterator.html">TableIterator</a> object with the appropriate column names.</p>
<p>In the next example we define an iteration on the columns <a class="el" href="classcasacore_1_1Time.html" title="date and time enquiry functions, with some operations. ">Time</a> and Baseline. Each iteration step returns a table subset in which <a class="el" href="classcasacore_1_1Time.html" title="date and time enquiry functions, with some operations. ">Time</a> and Baseline have the same value.</p>
<div class="fragment"><div class="line"><span class="comment">// Iterate over Time and Baseline (by default in ascending order).</span></div>
<div class="line"><span class="comment">// Time is the main iteration order, thus the first column specified.</span></div>
<div class="line">Table t;</div>
<div class="line">Table tab (<span class="stringliteral">&quot;UV_Table.data&quot;</span>);</div>
<div class="line">Block&lt;String&gt; iv0(2);</div>
<div class="line">iv0[0] = <span class="stringliteral">&quot;Time&quot;</span>;</div>
<div class="line">iv0[1] = <span class="stringliteral">&quot;Baseline&quot;</span>;</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Create the iterator. This will prepare the first subtable.</span></div>
<div class="line">TableIterator iter(tab, iv0);</div>
<div class="line"><a class="code" href="namespacecasacore.html#abb6e2c1bac472ca1ebadadf96cc8426f">Int</a> nr = 0;</div>
<div class="line"><span class="keywordflow">while</span> (!iter.pastEnd()) {</div>
<div class="line"><span class="comment">// Get the first subtable.</span></div>
<div class="line"><span class="comment">// This will contain rows with equal Time and Baseline.</span></div>
<div class="line">t = iter.table();</div>
<div class="line">cout &lt;&lt; t.nrow() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">nr++;</div>
<div class="line"><span class="comment">// Prepare the next subtable with the next Time,Baseline value.</span></div>
<div class="line">iter.next();</div>
<div class="line">}</div>
<div class="line">cout &lt;&lt; endl &lt;&lt; nr &lt;&lt; <span class="stringliteral">&quot; iteration steps&quot;</span> &lt;&lt; endl;</div>
</div><!-- fragment --><p>You can define more than one iterator on the same table; they operate independently.</p>
<p>Note that the result of each iteration step is a table in itself which references the original table, just as in the case of a sort or select. This means that the resulting table can be used again in a sort, select, iteration, etc..</p>
<p><a class="anchor" id="Tables_vectors"></a><a class="anchor" id="Tables:vectors"></a> </p>
<h3><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> Vectors</h3>
<p>A table vector makes it possible to treat a column in a table as a vector. Almost all operators and functions defined for normal vectors, are also defined for table vectors. So it is, for instance, possible to add a constant to a table vector. This has the effect that the underlying column gets changed.</p>
<p>You can use the templated class <a class="el" href="classcasacore_1_1TableVector.html">TableVector</a> to make a scalar column appear as a (table) vector. Columns containing arrays or tables are not supported. The data type of the <a class="el" href="classcasacore_1_1TableVector.html" title="Templated readonly table column vectors. ">TableVector</a> object must match the data type of the column. A table vector can also hold a normal vector so that (temporary) results of table vector operations can be handled.</p>
<p>In the following example we double the data in column COL1 and store the result in a temporary table vector. </p>
<div class="fragment"><div class="line"><span class="comment">// Create a table vector for column COL1.</span></div>
<div class="line"><span class="comment">// Note that if the table is readonly, putting data in the table vector</span></div>
<div class="line"><span class="comment">// results in an exception.</span></div>
<div class="line">Table tab (<span class="stringliteral">&quot;Table.data&quot;</span>);</div>
<div class="line">TableVector&lt;Int&gt; tabvec(tab, <span class="stringliteral">&quot;COL1&quot;</span>);</div>
<div class="line"><span class="comment">// Multiply it by a constant. Result is kept in a Vector in memory.</span></div>
<div class="line">TableVector&lt;Int&gt; temp = 2 * tabvec;</div>
</div><!-- fragment --><p>In the next example we double the data in COL1 and put the result back in the column. </p>
<div class="fragment"><div class="line"><span class="comment">// Create a table vector for column COL1.</span></div>
<div class="line"><span class="comment">// It has to be a TableVector to be able to change the column.</span></div>
<div class="line">Table tab (<span class="stringliteral">&quot;Table.data&quot;</span>, <a class="code" href="classcasacore_1_1Table.html#a6c62d60a9691364e3aaaf137ea73cde0a8637ba6591ac13499d937d318cdfa4f6">Table::Update</a>);</div>
<div class="line">TableVector&lt;Int&gt; tabvec(tab, <span class="stringliteral">&quot;COL1&quot;</span>);</div>
<div class="line"><span class="comment">// Multiply it by a constant.</span></div>
<div class="line">tabvec *= 2;</div>
</div><!-- fragment --><p><a class="anchor" id="Tables_keywords"></a><a class="anchor" id="Tables:keywords"></a> </p>
<h3><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> Keywords</h3>
<p>Any number of keyword/value pairs may be attached to the table as a whole, or to any individual column. They may be freely added, retrieved, re-assigned, or deleted. They are, in essence, a self-resizing list of values (any of the primitive types) indexed by Strings (the keyword).</p>
<p>A table keyword/value pair might be </p>
<div class="fragment"><div class="line">Observer = Grote Reber</div>
<div class="line">Date = 10 october 1942</div>
</div><!-- fragment --><p> Column keyword/value pairs might be </p>
<div class="fragment"><div class="line">Units = mJy</div>
<div class="line">Reference Pixel = 320</div>
</div><!-- fragment --><p> The class <a class="el" href="classcasacore_1_1TableRecord.html">TableRecord</a> represents the keywords in a table. It is (indirectly) derived from the standard record classes in the class <a class="el" href="classcasacore_1_1Record.html">Record</a></p>
<p><a class="anchor" id="Tables_Table_Description"></a><a class="anchor" id="Tables:Table Description"></a> </p>
<h3><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> Description</h3>
<p>A table contains a description of itself, which defines the layout of the columns and the keyword sets for the table and for the individual columns. It may also define initial keyword sets and default values for the columns. Such a default value is automatically stored in a cell in the table column, whenever a row is added to the table.</p>
<p>The creation of the table descriptor is the first step in the creation of a new table. The description is part of the table itself, but may also exist in a separate file. This is useful if you need to create a number of tables with the same structure; in other circumstances it probably should be avoided.</p>
<p>The public classes to set up a table description are: </p>
<ul>
<li>
<a class="el" href="classcasacore_1_1TableDesc.html">TableDesc</a> &ndash; holds the table description. </li>
<li>
<a class="el" href="classcasacore_1_1ColumnDesc.html">ColumnDesc</a> &ndash; holds a generic column description. </li>
<li>
<a class="el" href="classcasacore_1_1ScalarColumnDesc.html">ScalarColumnDesc&lt;T&gt; </a> &ndash; defines a column containing a scalar value. </li>
<li>
<a class="el" href="classcasacore_1_1ScalarRecordColumnDesc.html">ScalarRecordColumnDesc; </a> &ndash; defines a column containing a scalar record value. </li>
<li>
<a class="el" href="classcasacore_1_1ArrayColumnDesc.html">ArrayColumnDesc&lt;T&gt; </a> &ndash; defines a column containing an (in)direct array. </li>
</ul>
<p>Here follows a typical example of the construction of a table description. For more specialized things &ndash; like the definition of a default data manager &ndash; we refer to the descriptions of the above mentioned classes.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="TableDesc_8h.html">casacore/tables/Tables/TableDesc.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ScaColDesc_8h.html">casacore/tables/Tables/ScaColDesc.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ArrColDesc_8h.html">casacore/tables/Tables/ArrColDesc.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;casacore/tables/Tables/ScaRecordTabDesc.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="TableRecord_8h.html">casacore/tables/Tables/TableRecord.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="IPosition_8h.html">casacore/casa/Arrays/IPosition.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Vector_8h.html">casacore/casa/Arrays/Vector.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line"><span class="comment">// Create a new table description</span></div>
<div class="line"><span class="comment">// Define a comment for the table description.</span></div>
<div class="line"><span class="comment">// Define some keywords.</span></div>
<div class="line">ColumnDesc colDesc1, colDesc2;</div>
<div class="line">TableDesc td(<span class="stringliteral">&quot;tTableDesc&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <a class="code" href="classcasacore_1_1TableDesc.html#a70d5536aba94ee3dbf7d86ce4114c001a5bf1a8f7a8b01a9d7bfb3ed71ec101f7">TableDesc::New</a>);</div>
<div class="line">td.comment() = <span class="stringliteral">&quot;A test of class TableDesc&quot;</span>;</div>
<div class="line">td.rwKeywordSet().define (<span class="stringliteral">&quot;ra&quot;</span> <span class="keywordtype">float</span>(3.14));</div>
<div class="line">td.rwKeywordSet().define (<span class="stringliteral">&quot;equinox&quot;</span>, <span class="keywordtype">double</span>(1950));</div>
<div class="line">td.rwKeywordSet().define (<span class="stringliteral">&quot;aa&quot;</span>, <a class="code" href="namespacecasacore.html#abb6e2c1bac472ca1ebadadf96cc8426f">Int</a>(1));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Define an integer column ab.</span></div>
<div class="line">td.addColumn (ScalarColumnDesc&lt;Int&gt; (<span class="stringliteral">&quot;ab&quot;</span>, <span class="stringliteral">&quot;Comment for column ab&quot;</span>));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add a scalar integer column ac, define keywords for it</span></div>
<div class="line"><span class="comment">// and define a default value 0.</span></div>
<div class="line"><span class="comment">// Overwrite the value of keyword unit.</span></div>
<div class="line">ScalarColumnDesc&lt;Int&gt; acColumn(<span class="stringliteral">&quot;ac&quot;</span>);</div>
<div class="line">acColumn.rwKeywordSet().define (<span class="stringliteral">&quot;scale&quot;</span> <a class="code" href="namespaceComplexfwd__global__functions__Complexfwd_1_1casacore.html#a245a79fb03ef03c52d9e7f5a4fe3f710">Complex</a>(0,0));</div>
<div class="line">acColumn.rwKeywordSet().define (<span class="stringliteral">&quot;unit&quot;</span>, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">acColumn.setDefault (0);</div>
<div class="line">td.addColumn (acColumn);</div>
<div class="line">td.rwColumnDesc(<span class="stringliteral">&quot;ac&quot;</span>).rwKeywordSet().define (<span class="stringliteral">&quot;unit&quot;</span>, <span class="stringliteral">&quot;DEG&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add a scalar string column ad and define its comment string.</span></div>
<div class="line">td.addColumn (ScalarColumnDesc&lt;String&gt; (<span class="stringliteral">&quot;ad&quot;</span>,<span class="stringliteral">&quot;comment for ad&quot;</span>));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Now define array columns.</span></div>
<div class="line"><span class="comment">// This one is indirect and has no dimensionality mentioned yet.</span></div>
<div class="line">td.addColumn (ArrayColumnDesc&lt;Complex&gt; (<span class="stringliteral">&quot;Arr1&quot;</span>,<span class="stringliteral">&quot;comment for Arr1&quot;</span>));</div>
<div class="line"><span class="comment">// This one is indirect and has 3-dim arrays.</span></div>
<div class="line">td.addColumn (ArrayColumnDesc&lt;Int&gt; (<span class="stringliteral">&quot;A2r1&quot;</span>,<span class="stringliteral">&quot;comment for Arr1&quot;</span>,3));</div>
<div class="line"><span class="comment">// This one is direct and has 2-dim arrays with axes length 4 and 7.</span></div>
<div class="line">td.addColumn (ArrayColumnDesc&lt;uInt&gt; (<span class="stringliteral">&quot;Arr3&quot;</span>,<span class="stringliteral">&quot;comment for Arr1&quot;</span>,</div>
<div class="line">IPosition(2,4,7),</div>
<div class="line"><a class="code" href="classcasacore_1_1ColumnDesc.html#a8345327ae9b644267a43d970370ef129a4f9ea1574b345a35326f151d80dafc0f">ColumnDesc::Direct</a>));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add columns containing records.</span></div>
<div class="line">td.addColumn (ScalarRecordColumnDesc (<span class="stringliteral">&quot;Rec1&quot;</span>));</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Tables_Data_Managers"></a><a class="anchor" id="Tables:Data Managers"></a> </p>
<h3>Data Managers</h3>
<p>Data managers take care of the actual access to the data in a column. There are two kinds of data managers: </p>
<ol>
<li>
<a href="#Tables:storage managers">Storage managers</a> &ndash; which store the data as such. They can only handle the standard data types (Bool,...,<a class="el" href="classcasacore_1_1String.html" title="String: the storage and methods of handling collections of characters. ">String</a>) as discussed in the section about the <a href="#Tables:properties">table properties</a>). </li>
<li>
<a href="#Tables:virtual column engines">Virtual column engines</a> &ndash; which manipulate the data. An engine could be a simple thing like scaling the data (as done in classic AIPS to reduce data storage), but it could also be an elaborate thing like applying corrections on-the-fly. <br/>
A special engine is <a class="el" href="classcasacore_1_1VirtualTaQLColumn.html" title="Virtual scalar column using TaQL. ">VirtualTaQLColumn</a> which can be used to define the contents of a column by means of a TaQL expression. In particular, it can be used to define a constant value for the entire column. But it can also be used to calculate the UVW-coordinates on-the-fly. <br/>
An engine must be used when storing data objects with a non-standard type. It has to break down the object into items with standard data types which can be stored with a storage manager. </li>
</ol>
<p>In general the user of a table does not need to be aware which data managers are being used underneath. Only when the table is created data managers have to be bound to the columns. Thereafter it is completely transparent.</p>
<p>Data managers needs to be registered, so they can be found when a table is opened. All data managers mentioned below are part of the system and pre-registered. It is, however, also possible to load data managers on demand. If a data manager is not registered it is tried to load a shared library with the part of the data manager name (in lowercase) before a dot or left arrow. The dot makes it possible to have multiple data managers in a shared library, while the left arrow is meant for templated data manager classes. <br/>
E.g. if <code><a class="el" href="classcasacore_1_1BitFlagsEngine.html" title="Templated virtual column engine to map bit flags to a Bool. ">BitFlagsEngine</a>&lt;uChar&gt;</code> was not registered, the shared library <code>libbitflagsengine.so</code> (or.dylib) will be loaded. If successful, its function <code>register_bitflagsengine()</code> will be executed which should register the data manager(s). Thereafter it is known and will be used. For example in a file Register.h and Register.cc: </p>
<div class="fragment"><div class="line"><span class="comment">// Declare in.h file as C function, so no name mangling is done.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line"><span class="keywordtype">void</span> register_bitflagsengine();</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Implement in.cc file.</span></div>
<div class="line"><span class="keywordtype">void</span> register_bitflagsengine()</div>
<div class="line">{</div>
<div class="line"><a class="code" href="classcasacore_1_1BitFlagsEngine.html#a3e7a2d17f086b7ce1270171e4fa8e111">BitFlagsEngine&lt;uChar&gt;::registerClass</a>();</div>
<div class="line"><a class="code" href="classcasacore_1_1BitFlagsEngine.html#a3e7a2d17f086b7ce1270171e4fa8e111">BitFlagsEngine&lt;Short&gt;::registerClass</a>();</div>
<div class="line"><a class="code" href="classcasacore_1_1BitFlagsEngine.html#a3e7a2d17f086b7ce1270171e4fa8e111">BitFlagsEngine&lt;Int&gt;::registerClass</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p> There are several functions that can give information which data managers are used for which columns and to obtain the characteristics and properties of them. Class <a class="el" href="classcasacore_1_1RODataManAccessor.html" title="Base class for the Data Manager Accessor classes. ">RODataManAccessor</a> and derived classes can be used for it as well as the functions <code>dataManagerInfo</code> and <code>showStructure</code> in class <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a>.</p>
<p><a class="anchor" id="Tables_storage_managers"></a><a class="anchor" id="Tables:storage managers"></a> </p>
<h3>Storage Managers</h3>
<p>Storage managers are used to store the data contained in the column cells. At table construction time the binding of columns to storage managers is done. <br/>
Each storage manager uses one or more files (usually called table.fi_xxx where i is a sequence number and _xxx is some kind of extension). Typically several file are used to store the data of the columns of a table. <br/>
In order to reduce the number of files (and to support large block sizes), it is possible to have a single container file (a <a class="el" href="classcasacore_1_1MultiFile.html" title="Class to combine multiple files in a single one. ">MultiFile</a>) containing all data files used by the storage managers. Such a file is called table.mf. Note that the program <em>lsmf</em> can be used to see which files are contained in a <a class="el" href="classcasacore_1_1MultiFile.html" title="Class to combine multiple files in a single one. ">MultiFile</a>. The program <em>tomf</em> can convert the files in a <a class="el" href="classcasacore_1_1MultiFile.html" title="Class to combine multiple files in a single one. ">MultiFile</a> to regular files. <br/>
At table creation time it is decided if a <a class="el" href="classcasacore_1_1MultiFile.html" title="Class to combine multiple files in a single one. ">MultiFile</a> will be used. It can be done by means of the <a class="el" href="classcasacore_1_1StorageOption.html" title="Options defining how table files are organized. ">StorageOption</a> object given to the <a class="el" href="classcasacore_1_1SetupNewTable.html" title="Create a new table - define shapes, data managers, etc. ">SetupNewTable</a> constructor and/or by the aipsrc variables: </p>
<ul>
<li>
<code>table.storage.option</code> which can have the value 'multifile', 'sepfile' (meaning separate files), or 'default'. Currently the default is to use separate files. </li>
<li>
<code>table.storage.blocksize</code> defines the block size to be used by a <a class="el" href="classcasacore_1_1MultiFile.html" title="Class to combine multiple files in a single one. ">MultiFile</a>. If 0 is given, the file system's block size will be used. </li>
</ul>
<p>About all standard storage managers support the <a class="el" href="classcasacore_1_1MultiFile.html" title="Class to combine multiple files in a single one. ">MultiFile</a>. The exception is <a class="el" href="classcasacore_1_1StManAipsIO.html" title="AipsIO table storage manager class. ">StManAipsIO</a>, because it is hardly ever used.</p>
<p>Several storage managers exist, each with its own storage characteristics. The default and preferred storage manager is <code><a class="el" href="classcasacore_1_1StandardStMan.html" title="The Standard Storage Manager. ">StandardStMan</a></code>. Other storage managers should only be used if they pay off in file space (like <code><a class="el" href="classcasacore_1_1IncrementalStMan.html" title="The Incremental Storage Manager. ">IncrementalStMan</a></code> for slowly varying data) or access speed (like the tiled storage managers for large data arrays). <br/>
The storage managers store the data in a big or little endian canonical format. The format can be specified when the table is created. By default it uses the endian format as specified in the aipsrc variable <code>table.endianformat</code> which can have the value local, big, or little. The default is local. </p>
<ol>
<li>
<p class="startli"><a class="el" href="classcasacore_1_1StandardStMan.html">StandardStMan</a> stores all the values in so-called buckets (equally sized chunks in the file). It requires little memory. <br/>
It replaces the old <code><a class="el" href="classcasacore_1_1StManAipsIO.html" title="AipsIO table storage manager class. ">StManAipsIO</a></code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classcasacore_1_1IncrementalStMan.html">IncrementalStMan</a> uses a storage mechanism resembling "incremental backups". A value is only stored if it is different from the previous row. It is very well suited for slowly varying data. <br/>
The class <a class="el" href="classcasacore_1_1ROIncrementalStManAccessor.html">ROIncrementalStManAccessor</a> can be used to tune the behaviour of the <code><a class="el" href="classcasacore_1_1IncrementalStMan.html" title="The Incremental Storage Manager. ">IncrementalStMan</a></code>. It contains functions to deal with the cache size and to show the behaviour of the cache.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The <a href="#Tables:TiledStMan">Tiled Storage Managers</a> store the data as a tiled hypercube allowing for more or less equally efficient data access along all main axes. It can be used for UV-data as well as for image data.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classcasacore_1_1StManAipsIO.html">StManAipsIO</a> uses <code><a class="el" href="classcasacore_1_1AipsIO.html" title="AipsIO is the object persistency mechanism of Casacore. ">AipsIO</a></code> to store the data in the columns. It supports all table functionality, but its I/O is probably not as efficient as other storage managers. It also requires that a large part of the table fits in memory. <br/>
It should not be used anymore, because it uses a lot of memory for larger tables and because it is not very robust in case an application or system crashes.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classcasacore_1_1MemoryStMan.html">MemoryStMan</a> holds the data in memory. It means that data 'stored' with this storage manager are NOT persistent. <br/>
This storage manager is primarily meant for tables held in memory, but it can also be useful for temporary columns in normal tables. Note, however, that if a table is accessed concurrently from multiple processes, <a class="el" href="classcasacore_1_1MemoryStMan.html" title="Memory-based table storage manager class. ">MemoryStMan</a> data cannot be synchronized.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classdyscostman_1_1DyscoStMan.html">dyscostman::DyscoStMan</a> is a class that stores data with lossy compression. It combines non-linear least-squares quantization and different kinds of normalizaton. With the typical factor of 4 compression, the loss in accuracy from lossy compression is negligable. It should only be used for real (non-simulated) data that is in a Measurement Set. The method is described in this article: <a href="https://arxiv.org/abs/1609.02019">https://arxiv.org/abs/1609.02019</a>.</p>
<p class="endli"></p>
</li>
<li>
<a class="el" href="classcasacore_1_1Adios2StMan.html">Adios2StMan</a> uses the <a href="https://github.com/ornladios/ADIOS2">ADIOS2 framework</a> to store and load column data. <br/>
ADIOS2 has several configurable storage backend itself, and this flexibility is also available via <a class="el" href="classcasacore_1_1Adios2StMan.html">Adios2StMan</a>. This includes, among other things, storing compressed data, or choosing a different on-disk formats. <br/>
This storage manager is also special in that it provides parallel writing capabilities for MPI processes, so that multiple processes can write into different sections of the same column concurrently. </li>
</ol>
<p>The storage manager framework makes it possible to support arbitrary files as tables. This has been used in a case where a file is filled by the data acquisition system of a telescope. The file is simultaneously used as a table using a dedicated storage manager. The table system and storage manager provide a sync function to synchronize the processes, i.e. to make CTDS aware of changes in the file size (thus in the table size) by the filling process.</p>
<p><br/>
<b>Tip:</b><em> Not all data managers support all the table functionality; So, the choice of a data manager can greatly influence the type of operations you can do on the table as a whole; For example, if a column uses the tiled storage manager, it is not possible to delete rows from the table, because that storage manager will not support deletion of rows; However, it is always possible to delete all columns of a data manager in one single call; </em><br/>
</p>
<p><a class="anchor" id="Tables_TiledStMan"></a><a class="anchor" id="Tables:TiledStMan"></a> </p>
<h3>Tiled Storage Manager</h3>
<p>The Tiled Storage Managers allow one to store the data of one or more columns in a tiled way. Tiling means that the data are stored without a preferred order to make access along the different main axes equally efficient. This is done by storing the data in so-called tiles (i.e. equally shaped subsets of an array) to increase data locality. The user can define the tile shape to optimize for the most frequently used access. </p>
<p>The Tiled Storage Manager has the following properties: </p>
<ul>
<li>
There can be more than one Tiled Storage Manager in a table; each with its own (unique) name. </li>
<li>
<p class="startli">Each Tiled Storage Manager can store an N-dimensional so-called hypercolumn. Elaborate hypercolumns can be defined using</p>
<p class="endli"><a class="el" href="classcasacore_1_1TableDesc.html#TableDesc_defineHypercolumn">TableDesc::defineHypercolumn</a>). <br/>
Note that defining a hypercolumn is only necessary if it contains multiple columns or if the <a class="el" href="classcasacore_1_1TiledDataStMan.html" title="Tiled Data Storage Manager. ">TiledDataStMan</a> is used. It means that in practice it is hardly ever needed to define a hypercolumn. <br/>
A hypercolumn consists of up to three types of columns: </p>
<dl>
<dt>Data columns </dt>
<dd>contain the data to be stored in a tiled way. This will be done in tiled hypercubes. There must be at least one data column. <br/>
 For example: a table contains UV-data with data columns "Visibility" and "Weight". </dd>
<dt><a class="el" href="classcasacore_1_1Coordinate.html" title="Interface for converting between world and pixel coordinates. ">Coordinate</a> columns </dt>
<dd>define the world coordinates of the pixels in the data columns. <a class="el" href="classcasacore_1_1Coordinate.html" title="Interface for converting between world and pixel coordinates. ">Coordinate</a> columns are optional, but if given there must be N coordinate columns for an N-dimensional hypercolumn. <br/>
 For example: the data in the example above is 4-dimensional and has coordinate columns "Time", "Baseline", "Frequency", and "Polarization". </dd>
<dt>Id columns </dt>
<dd>are needed if <a class="el" href="classcasacore_1_1TiledDataStMan.html" title="Tiled Data Storage Manager. ">TiledDataStMan</a> is used. Different rows in the data columns can be stored in different hypercubes. The values in the id column(s) uniquely identify the hypercube a row is stored in. <br/>
 For example: the line and continuum data in a <a class="el" href="classcasacore_1_1MeasurementSet.html" title="A Table intended to hold astronomical data (a set of Measurements). ">MeasurementSet</a> table need to be stored in 2 different hypercubes (because their shapes are different (see below)). A column containing the type (line or continuum) has to be used as an id column. </dd>
</dl>
</li>
<li>
If multiple data columns are used, the shape of their data must be conforming in each individual row. If data in different rows have different shapes, they must be stored in different hypercubes, because a hypercube can only hold data with conforming shapes. <br/>
 Thus in the example above, rows with line data will have conforming shapes and can be stored in one hypercube. The continuum data will have another shape and can be stored in another hypercube. <br/>
 The storage manager keeps track of the mapping of rows to/from hypercubes. </li>
<li>
Each hypercube can be tiled in its own way. It is not required that an integer number of tiles fits in the hypercube. The last tiles will be padded as needed. </li>
<li>
The last axis of a hypercube can be extensible. This means that the size of that axis does not need to be defined when the hypercube is defined in the storage manager. Instead, the hypercube can be extended when another chunk of data has to be stored. This can be very useful in, for example, a (quasi-)realtime environment where the size of the time axis is not known. </li>
<li>
If coordinate columns are defined, they describe the coordinates of the axes of the hypercubes. Each hypercube has its own set of coordinates. </li>
<li>
Data and id columns have to be stored with the Tiled Storage Manager. However, coordinate columns do not need to be stored with the Tiled Storage Manager. Especially in the case where the coordinates for a hypercube axis are varying (i.e. dependent on other axes), another storage manager has to be used (because the Tiled Storage Manager can only hold constant coordinates). </li>
</ul>
<p>The following Tiled Storage Managers are available: </p>
<dl>
<dt><a class="el" href="classcasacore_1_1TiledShapeStMan.html">TiledShapeStMan</a> </dt>
<dd>can be seen as a specialization of <code><a class="el" href="classcasacore_1_1TiledDataStMan.html" title="Tiled Data Storage Manager. ">TiledDataStMan</a></code> by using the array shape as the id value. Similarly to <code><a class="el" href="classcasacore_1_1TiledDataStMan.html" title="Tiled Data Storage Manager. ">TiledDataStMan</a></code> it can maintain multiple hypercubes and store multiple rows in a hypercube, but it is easier to use, because the special <code>addHypercube</code> and <code>extendHypercube</code> functions are not needed. An hypercube is automatically added when a new array shape is encountered. <br/>
 This storage manager could be used for a table with a column containing line and continuum data, which will result in 2 hypercubes. </dd>
<dt><a class="el" href="classcasacore_1_1TiledCellStMan.html">TiledCellStMan</a> </dt>
<dd>creates (automatically) a new hypercube for each row. Thus each row of the hypercolumn is stored in a separate hypercube. Note that the row number serves as the id value. So an id column is not needed, although there are multiple hypercubes. <br/>
 This storage manager is meant for tables where the data arrays in the different rows are not accessed together. One can think of a column containing images. Each row contains an image and only one image is shown at a time. </dd>
<dt><a class="el" href="classcasacore_1_1TiledColumnStMan.html">TiledColumnStMan</a> </dt>
<dd>creates one hypercube for the entire hypercolumn. Thus all cells in the hypercube have to have the same shape and therefore this storage manager is only possible if all columns in the hypercolumn have the attribute FixedShape. <br/>
 This storage manager could be used for a table with a column containing images for the <a class="el" href="classcasacore_1_1Stokes.html" title="Stokes parameter definitions for interface to table data. ">Stokes</a> parameters I, Q, U, and V. By storing them in one hypercube, it is possible to retrieve the 4 <a class="el" href="classcasacore_1_1Stokes.html" title="Stokes parameter definitions for interface to table data. ">Stokes</a> values for a subset of the image or for an individual pixel in a very efficient way. </dd>
<dt><a class="el" href="classcasacore_1_1TiledDataStMan.html">TiledDataStMan</a> </dt>
<dd><p class="startdd">allows one to control the creation and extension of hypercubes. This is done by means of the class</p>
<p class="enddd"><a class="el" href="classcasacore_1_1TiledDataStManAccessor.html">TiledDataStManAccessor</a>. It makes it possible to store, say, row 0-9 in hypercube A, row 10-34 in hypercube B, row 35-54 in hypercube A again, etc.. <br/>
 The drawback of this storage manager is that its hypercubes are not automatically extended when adding new rows. The special functions <code>addHypercube</code> and <code>extendHypercube</code> have to be used making it somewhat tedious to use. Therefore this storage manager may become obsolete in the near future. </p>
</dd>
</dl>
<p>The Tiled Storage Managers have 3 ways to access and cache the data. Class <a class="el" href="classcasacore_1_1TSMOption.html">TSMOption</a> can be used to setup an access choice and use it in a <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> constructor. </p>
<ul>
<li>
The old way (the only way until January 2010) uses a cache of its own to keep tiles that might need to be reused. It will always access entire tiles, even if only a small part is needed. It is possible to define a maximum cache size. The description of class <a class="el" href="classcasacore_1_1ROTiledStManAccessor.html">ROTiledStManAccessor</a> contains a discussion about the effect of defining a maximum cache size. </li>
<li>
Memory-mapping the data files. In this way the operating system takes care of the IO and caching. However, the limited address space may preclude using it for large tables on 32-bit systems. </li>
<li>
Use buffered IO and let the kernel's file cache take care of caching. It will access the data in chunks of the given buffer size, so the entire tile does not need to be accessed if only a small part is needed. </li>
</ul>
<p>Apart from reading, all access ways described above can also handle writing and extending tables. They create fully equal files. Both little and big endian data can be read or written.</p>
<p><a class="anchor" id="Tables_virtual_column_engines"></a><a class="anchor" id="Tables:virtual column engines"></a> </p>
<h3>Virtual Column Engines</h3>
<p>Virtual column engines are used to implement the virtual (i.e. calculated-on-the-fly) columns. CTDS provides an abstract base class (or "interface class") <a class="el" href="classcasacore_1_1VirtualColumnEngine.html">VirtualColumnEngine</a> that specifies the protocol for these engines. The programmer must derive a concrete class to implement the application-specific virtual column. </p>
<p>For example: the programmer needs a column in a table which is the difference between two other columns. (Perhaps these two other columns are updated periodically during the execution of a program.) A good way to handle this would be to have a virtual column in the table, and write a virtual column engine which knows how to calculate the difference between corresponding cells of the two other columns. So the result is that accessing a particular cell of the virtual column invokes the virtual column engine, which then gets the values from the other two columns, and returns their difference. This particular example could be done using <a class="el" href="classcasacore_1_1VirtualTaQLColumn.html">VirtualTaQLColumn</a>. </p>
<p>Several virtual column engines exist: </p>
<ol>
<li>
The class <a class="el" href="classcasacore_1_1VirtualTaQLColumn.html">VirtualTaQLColumn</a> makes it possible to define a column as an arbitrary expression of other columns. It uses the <a href="../notes/199.html">TaQL</a> CALC command. The virtual column can be a scalar or an array and can have one of the standard data types supported by CTDS. </li>
<li>
The class <a class="el" href="classcasacore_1_1BitFlagsEngine.html">BitFlagsEngine</a> maps an integer bit flags column to a Bool column. A read and write mask can be defined telling which bits to take into account when mapping to and from Bool (thus when reading or writing the Bool). </li>
<li>
The class <a class="el" href="classcasacore_1_1CompressFloat.html">CompressFloat</a> compresses a single precision floating point array by scaling the values to shorts (16-bit integer). </li>
<li>
The class <a class="el" href="classcasacore_1_1CompressComplex.html">CompressComplex</a> compresses a single precision complex array by scaling the values to shorts (16-bit integer). In fact, the 2 parts of the complex number are combined to an 32-bit integer. </li>
<li>
The class <a class="el" href="classcasacore_1_1CompressComplexSD.html">CompressComplexSD</a> does the same as <a class="el" href="classcasacore_1_1CompressComplex.html" title="Virtual column engine to scale a table Complex array. ">CompressComplex</a>, but optimizes for the case where the imaginary part is zero (which is often the case for Single Dish data). </li>
<li>
The double templated class <a class="el" href="classcasacore_1_1ScaledArrayEngine.html">ScaledArrayEngine</a> scales the data in an array from, for example, float to short before putting it. </li>
<li>
The double templated class <a class="el" href="classcasacore_1_1MappedArrayEngine.html">MappedArrayEngine</a> converts the data from one data type to another. Sometimes it might be needed to store the residual data in an MS in double precision. Because the imaging task can only handle single precision, this enigne can be used to map the data from double to single precision. </li>
<li>
The double templated class <a class="el" href="classcasacore_1_1RetypedArrayEngine.html">RetypedArrayEngine</a> converts the data from one data type to another with the possibility to reduce the number of dimensions. For example, it can be used to store an 2-d array of StokesVector objects as a 3-d array of floats by treating the 4 data elements as an extra array axis. If the StokesVector class is simple, it can be done very efficiently. </li>
<li>
<p class="startli">The class</p>
<p class="endli"><a class="el" href="classcasacore_1_1ForwardColumnEngine.html">ForwardColumnEngine</a> forwards the gets and puts on a row in a column to the same row in a column with the same name in another table. This provides a virtual copy of the referenced column. </p>
</li>
<li>
<p class="startli">The class</p>
<p class="endli"><a class="el" href="classcasacore_1_1ForwardColumnIndexedRowEngine.html">ForwardColumnIndexedRowEngine</a> is similar to <code><a class="el" href="classcasacore_1_1ForwardColumnEngine.html" title="Virtual column engine forwarding to other columns. ">ForwardColumnEngine</a>.</code>. However, instead of forwarding it to the same row it uses a a column to map its row number to a row number in the referenced table. In this way multiple rows can share the same data. This data manager only allows for get operations. </p>
</li>
<li>
The calibration module has implemented a virtual column engine to do on-the-fly calibration in a transparent way. </li>
</ol>
<p>To handle arbitrary data types the templated abstract base class <a class="el" href="classcasacore_1_1VSCEngine.html">VSCEngine</a> has been written. An example of how to use this class can be found in the demo program <code>dVSCEngine.cc</code>.</p>
<p><a class="anchor" id="Tables_LockSync"></a><a class="anchor" id="Tables:LockSync"></a> </p>
<h3><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> locking and synchronization</h3>
<p>Multiple concurrent readers and writers (also via NFS) of a table are supported by means of a locking/synchronization mechanism. This mechanism is not very sophisticated in the sense that it is very coarsely grained. When locking, the entire table gets locked. A special lock file is used to lock the table. This lock file also contains some synchronization data. </p>
<p>Five ways of locking are supported (see class <a class="el" href="classcasacore_1_1TableLock.html">TableLock</a>): </p>
<dl>
<dt>TableLock::PermanentLocking(Wait) </dt>
<dd>locks the table permanently (from open till close). This means that one writer OR multiple readers are possible. </dd>
<dt><a class="el" href="classcasacore_1_1TableLock.html#a318708fb4ef30014bba5289e7075b9a1a1780869c899a5fad9d5e3bef08e29176" title="The system takes care of acquiring/releasing locks. ">TableLock::AutoLocking</a> </dt>
<dd>does the locking automatically. This is the default mode. This mode makes it possible that a table is shared amongst processes without the user needing to write any special code. It also means that a lock is only released when needed. </dd>
<dt><a class="el" href="classcasacore_1_1TableLock.html#a318708fb4ef30014bba5289e7075b9a1a296133551fb51536c3d3ec5ff4343631" title="The system takes care of acquiring/releasing locks. ">TableLock::AutoNoReadLocking</a> </dt>
<dd>is similar to AutoLocking. However, no lock is acquired when reading the table making it possible to read the table while another process holds a write-lock. It also means that for read purposes no automatic synchronization is done when the table is updated in another process. Explicit synchronization can be done by means of the function <code><a class="el" href="classcasacore_1_1Table.html#ac366937366fd5ef08d5bf7a29144e292" title="Resynchronize the Table object with the table file. ">Table::resync</a></code>. </dd>
<dt><a class="el" href="classcasacore_1_1TableLock.html#a318708fb4ef30014bba5289e7075b9a1a153c46a2694332a7cc757ddf5d4d3f9e" title="The user is taking care of locking the table by means of the Table functions lock and unlock...">TableLock::UserLocking</a> </dt>
<dd>requires that the programmer explicitly acquires and releases a lock on the table. This makes some kind of transaction processing possible. E.g. set a write lock, add a row, write all data into the row and release the lock. The <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> functions <code>lock</code> and <code>unlock</code> have to be used to acquire and release a (read or write) lock. </dd>
<dt><a class="el" href="classcasacore_1_1TableLock.html#a318708fb4ef30014bba5289e7075b9a1a7aa61c419e3ae746329f9d02c5464d33" title="The user is taking care of locking the table by means of the Table functions lock and unlock...">TableLock::UserNoReadLocking</a> </dt>
<dd>is similar to UserLocking. However, similarly to AutoNoReadLocking no lock is needed to read the table. </dd>
<dt><a class="el" href="classcasacore_1_1TableLock.html#a318708fb4ef30014bba5289e7075b9a1ad3af0bcf5c6e5ea525d12fdb1c0869d0" title="Do not do any locking at all. ">TableLock::NoLocking</a> </dt>
<dd>does not use table locking. It is the responsibility of the user to ensure that no concurrent access is done on the same bucket or tile in a storage manager, otherwise a table might get corrupted. <br/>
This mode is always used if Casacore is built with -DAIPS_TABLE_NOLOCKING. </dd>
</dl>
<p>Synchronization of the processes accessing the same table is done by means of the lock file. When a lock is released, the storage managers flush their data into the table files. Some synchronization data is written into the lock file telling the new number of table rows and telling which storage managers have written data. This information is read when another process acquires the lock and is used to determine which storage managers have to refresh their internal caches. <br/>
Note that for the NoReadLocking modes (see above) explicit synchronization might be needed using <code><a class="el" href="classcasacore_1_1Table.html#ac366937366fd5ef08d5bf7a29144e292" title="Resynchronize the Table object with the table file. ">Table::resync</a></code>. </p>
<p>The function <code><a class="el" href="classcasacore_1_1Table.html#a7717e914f20c1e1c7e5d46e481f0ee52" title="Determine if column or keyword table data have changed (or is being changed) since the last time this...">Table::hasDataChanged</a></code> can be used to check if a table is (being) changed by another process. In this way a program can react on it. E.g. the table browser can refresh its screen when the underlying table is changed. </p>
<p>In general the default locking option will do. From the above it should be clear that heavy concurrent access results in a lot of flushing, thus will have a negative impact on performance. If uninterrupted access to a table is needed, the <code>PermanentLocking</code> option should be used. If transaction-like processing is done (e.g. updating a table containing an observation catalogue), the <code>UserLocking</code> option is probably best. </p>
<p>Creation or deletion of a table is not possible if that table is still open in another process. The function <code><a class="el" href="classcasacore_1_1Table.html#a8b3ced8e179e0b79b46724890c20b0af" title="Is the table used (i.e. ">Table::isMultiUsed()</a></code> can be used to check if a table is open in other processes. <br/>
 The function <code><a class="el" href="namespacecasacore_1_1TableUtil.html#a78df941c3d7655d5a1825e59f27330f6" title="Delete the table. ">TableUtil::deleteTable</a></code> should be used to delete a table. Before deleting the table it ensures that it is writable and that it is not open in the current or another process. </p>
<p>The following example wants to read the table uninterrupted, thus it uses the <code>PermanentLocking</code> option. It also wants to wait until the lock is actually acquired. Note that the destructor closes the table and releases the lock. </p>
<div class="fragment"><div class="line"><span class="comment">// Open the table (readonly).</span></div>
<div class="line"><span class="comment">// Acquire a permanent (read) lock.</span></div>
<div class="line"><span class="comment">// It waits until the lock is acquired.</span></div>
<div class="line">Table tab (<span class="stringliteral">&quot;some.name&quot;</span>,</div>
<div class="line">TableLock(<a class="code" href="classcasacore_1_1TableLock.html#a318708fb4ef30014bba5289e7075b9a1af3571e14dc67ed2e93633cc4bd3c7efd">TableLock::PermanentLockingWait</a>));</div>
</div><!-- fragment --><p>The following example uses the automatic locking.. It tells the system to check about every 20 seconds if another process wants access to the table. </p>
<div class="fragment"><div class="line"><span class="comment">// Open the table (readonly).</span></div>
<div class="line">Table tab (<span class="stringliteral">&quot;some.name&quot;</span>,</div>
<div class="line">TableLock(<a class="code" href="classcasacore_1_1TableLock.html#a318708fb4ef30014bba5289e7075b9a1a1780869c899a5fad9d5e3bef08e29176">TableLock::AutoLocking</a>, 20));</div>
</div><!-- fragment --><p>The following example gets data (say from a GUI) and writes it as a row into the table. The lock the table as little as possible the lock is acquired just before writing and released immediately thereafter. </p>
<div class="fragment"><div class="line"><span class="comment">// Open the table (writable).</span></div>
<div class="line">Table tab (<span class="stringliteral">&quot;some.name&quot;</span>,</div>
<div class="line">TableLock(<a class="code" href="classcasacore_1_1TableLock.html#a318708fb4ef30014bba5289e7075b9a1a153c46a2694332a7cc757ddf5d4d3f9e">TableLock::UserLocking</a>),</div>
<div class="line"><a class="code" href="classcasacore_1_1Table.html#a6c62d60a9691364e3aaaf137ea73cde0a8637ba6591ac13499d937d318cdfa4f6">Table::Update</a>);</div>
<div class="line"><span class="keywordflow">while</span> (<a class="code" href="namespacecasacore.html#ad5c850f9e177173e0f7d0ad57091501d">True</a>) {</div>
<div class="line"><span class="keyword">get</span> input data</div>
<div class="line">tab.lock();     <span class="comment">// Acquire a write lock and wait for it.</span></div>
<div class="line">tab.addRow();</div>
<div class="line">write data into the row</div>
<div class="line">tab.unlock();   <span class="comment">// Release the lock.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The following example deletes a table if it is not used in another process. </p>
<div class="fragment"><div class="line">Table tab (<span class="stringliteral">&quot;some.name&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (! tab.isMultiUsed()) {</div>
<div class="line">tab.markForDelete();</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Tables_KeyLookup"></a><a class="anchor" id="Tables:KeyLookup"></a> </p>
<h3><a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> lookup based on a key</h3>
<p>Class <a class="el" href="classcasacore_1_1ColumnsIndex.html">ColumnsIndex</a> offers the user a means to find the rows matching a given key or key range. It is a somewhat primitive replacement of a B-tree index and in the future it may be replaced by a proper B+-tree implementation. </p>
<p>The <code><a class="el" href="classcasacore_1_1ColumnsIndex.html" title="Index to one or more columns in a table. ">ColumnsIndex</a></code> class makes it possible to build an in-core index on one or more columns. Looking a key or key range is done using a binary search on that index. It returns a vector containing the row numbers of the rows matching the key (range). </p>
<p>The class is not capable of tracing changes in the underlying column(s). It detects a change in the number of rows and updates the index accordingly. However, it has to be told explicitly when a value in the underlying column(s) changes. </p>
<p>The following example shows how the class can be used. </p>
<h3>Example</h3>
<p><a class="anchor" id="Tables_example1"></a> Suppose one has an antenna table with key ANTENNA. </p>
<div class="fragment"><div class="line"><span class="comment">// Open the table and make an index for column ANTENNA.</span></div>
<div class="line">Table tab(<span class="stringliteral">&quot;antenna.tab&quot;</span>)</div>
<div class="line">ColumnsIndex colInx(tab, &quot;ANTENNA&quot;);</div>
<div class="line"><span class="comment">// Make a RecordFieldPtr for the ANTENNA field in the index key record.</span></div>
<div class="line"><span class="comment">// Its data type has to match the data type of the column.</span></div>
<div class="line">RecordFieldPtr&lt;<a class="code" href="namespacecasacore.html#abb6e2c1bac472ca1ebadadf96cc8426f">Int</a>&gt; antFld(colInx.accessKey(), &quot;ANTENNA&quot;);</div>
<div class="line"><span class="comment">// Now loop in some way and find the row for the antenna</span></div>
<div class="line"><span class="comment">// involved in that loop.</span></div>
<div class="line"><a class="code" href="namespacecasacore.html#abd5691f9e13acc90d901e4007740ff98">Bool</a> found;</div>
<div class="line">while (...) {</div>
<div class="line"><span class="comment">// Fill the key field and get the row number.</span></div>
<div class="line"><span class="comment">// ANTENNA is a unique key, so only one row number matches.</span></div>
<div class="line"><span class="comment">// Otherwise function getRowNumbers had to be used.</span></div>
<div class="line">*antFld = antenna;</div>
<div class="line"><a class="code" href="namespacecasacore.html#a5c559d8d8bf2ae7f67b439955d6be88a">uInt</a> antRownr = colInx.getRowNumber (found);</div>
<div class="line"><span class="keywordflow">if</span> (!found) {</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Antenna &quot;</span> &lt;&lt; antenna &lt;&lt; <span class="stringliteral">&quot; is unknown&quot;</span> &lt;&lt; endl;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line"><span class="comment">// antRownr can now be used to get data from that row in</span></div>
<div class="line"><span class="comment">// the antenna table.</span></div>
<div class="line">}</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="classcasacore_1_1ColumnsIndex.html">ColumnsIndex</a> itself contains a more advanced example. It shows how to use a private compare function to adjust the lookup if the index does not contain single key values, but intervals instead. This is useful if a row in a (sub)table is valid for, say, a time range instead of a single timestamp.</p>
<p><a class="anchor" id="Tables_performance"></a><a class="anchor" id="Tables:performance"></a> </p>
<h3>Performance and robustness considerations</h3>
<p>CTDS resembles a database system, but it is not as robust. It lacks the transaction and logging facilities common to data base systems. It means that in case of a crash data might be lost. To reduce the risk of data loss to a minimum, it is advisable to regularly do a <code>flush</code>, optionally with an <code>fsync</code> to ensure that all data are really written. However, that can degrade the performance because it involves extra writes. So one should find the right balance between robustness and performance.</p>
<p>To get a good feeling for the performance issues, it is important to understand some of the internals of CTDS. <br/>
The storage managers drive the performance. All storage managers use buckets (called tiles for the <a class="el" href="classcasacore_1_1TiledStMan.html" title="Base class for Tiled Storage Manager classes. ">TiledStMan</a>) which contain the data. All IO is done by bucket. The bucket/tile size is defined when creating the storage manager objects. Sometimes the default will do, but usually it is better to set it explicitly.</p>
<p>It is best to do a flush when a tile is full. For example: <br/>
 When creating a <a class="el" href="classcasacore_1_1MeasurementSet.html" title="A Table intended to hold astronomical data (a set of Measurements). ">MeasurementSet</a> containing N antennae (thus N*(N-1) baselines or N*(N+1) if auto-correlations are stored as well) it makes sense to store, say, N/2 rows in a tile and do a flush each time all baselines are written. In that way tiles are fully filled when doing the flush, so no extra IO is involved. <br/>
Here is some code showing this when creating a <a class="el" href="classcasacore_1_1MeasurementSet.html" title="A Table intended to hold astronomical data (a set of Measurements). ">MeasurementSet</a>. The code should speak for itself. </p>
<div class="fragment"><div class="line"><a class="code" href="namespacecasacore.html#aa5e78960516bef4822a438d3e84c9079">MS</a>* createMS (<span class="keyword">const</span> String&amp; msName, <span class="keywordtype">int</span> nrchan, <span class="keywordtype">int</span> nrant)</div>
<div class="line">{</div>
<div class="line"><span class="comment">// Get the MS main default table description.</span></div>
<div class="line">TableDesc td = <a class="code" href="classcasacore_1_1MSTable.html#a5f5f9aee28ad2bf905d0a126b73e628b">MS::requiredTableDesc</a>();</div>
<div class="line"><span class="comment">// Add the data column and its unit.</span></div>
<div class="line"><a class="code" href="classcasacore_1_1MSTable.html#a1ae25de25bbfaabec535bea0f45da8cd">MS::addColumnToDesc</a>(td, <a class="code" href="classcasacore_1_1MSMainEnums.html#a612b887846f70716850e235c411e48a9aadb9b459841fdbdb238484d63cadf0f0">MS::DATA</a>, 2);</div>
<div class="line">td.rwColumnDesc(<a class="code" href="classcasacore_1_1MSTable.html#a66be6569045313b99638c21e81477acb">MS::columnName</a>(<a class="code" href="classcasacore_1_1MSMainEnums.html#a612b887846f70716850e235c411e48a9aadb9b459841fdbdb238484d63cadf0f0">MS::DATA</a>)).rwKeywordSet().</div>
<div class="line">define(<span class="stringliteral">&quot;UNIT&quot;</span>,<span class="stringliteral">&quot;Jy&quot;</span>);</div>
<div class="line"><span class="comment">// Store the DATA and FLAG column in two separate files.</span></div>
<div class="line"><span class="comment">// In this way accessing FLAG only is much cheaper than</span></div>
<div class="line"><span class="comment">// when combining DATA and FLAG.</span></div>
<div class="line"><span class="comment">// All data have the same shape, thus use TiledColumnStMan.</span></div>
<div class="line"><span class="comment">// Also store UVW with TiledColumnStMan.</span></div>
<div class="line">Vector&lt;String&gt; tsmNames(1);</div>
<div class="line">tsmNames[0] = <a class="code" href="classcasacore_1_1MSTable.html#a66be6569045313b99638c21e81477acb">MS::columnName</a>(<a class="code" href="classcasacore_1_1MSMainEnums.html#a612b887846f70716850e235c411e48a9aadb9b459841fdbdb238484d63cadf0f0">MS::DATA</a>);</div>
<div class="line">td.rwColumnDesc(tsmNames[0]).setShape (IPosition(2,itsNrCorr,itsNrFreq));</div>
<div class="line">td.defineHypercolumn(<span class="stringliteral">&quot;TiledData&quot;</span>, 3, tsmNames);</div>
<div class="line">tsmNames[0] = <a class="code" href="classcasacore_1_1MSTable.html#a66be6569045313b99638c21e81477acb">MS::columnName</a>(<a class="code" href="classcasacore_1_1MSMainEnums.html#a612b887846f70716850e235c411e48a9a2c80ac3e56fe76d87b08f2fe37c8715f">MS::FLAG</a>);</div>
<div class="line">td.rwColumnDesc(tsmNames[0]).setShape (IPosition(2,itsNrCorr,itsNrFreq));</div>
<div class="line">td.defineHypercolumn(<span class="stringliteral">&quot;TiledFlag&quot;</span>, 3, tsmNames);</div>
<div class="line">tsmNames[0] = <a class="code" href="classcasacore_1_1MSTable.html#a66be6569045313b99638c21e81477acb">MS::columnName</a>(<a class="code" href="classcasacore_1_1MSMainEnums.html#a612b887846f70716850e235c411e48a9af14726485aa69d09e0c1d796687b9e3d">MS::UVW</a>);</div>
<div class="line">td.defineHypercolumn(<span class="stringliteral">&quot;TiledUVW&quot;</span>, 2, tsmNames);</div>
<div class="line"><span class="comment">// Setup the new table.</span></div>
<div class="line">SetupNewTable newTab(msName, td, <a class="code" href="classcasacore_1_1Table.html#a6c62d60a9691364e3aaaf137ea73cde0a72527bb2e368badd05319f61ab3dee6f">Table::New</a>);</div>
<div class="line"><span class="comment">// Most columns vary slowly and use the IncrStMan.</span></div>
<div class="line">IncrementalStMan incrStMan(<span class="stringliteral">&quot;ISMData&quot;</span>);</div>
<div class="line"><span class="comment">// A few columns use he StandardStMan (set an appropriate bucket size).</span></div>
<div class="line">StandardStMan    stanStMan(<span class="stringliteral">&quot;SSMData&quot;</span>, 32768);</div>
<div class="line"><span class="comment">// Store all pol and freq and some rows in a single tile.</span></div>
<div class="line"><span class="comment">// autocorrelations are written, thus in total there are</span></div>
<div class="line"><span class="comment">// nrant*(nrant+1)/2 baselines. Ensure a baseline takes up an</span></div>
<div class="line"><span class="comment">// integer number of tiles.</span></div>
<div class="line">TiledColumnStMan tiledData(<span class="stringliteral">&quot;TiledData&quot;</span>,</div>
<div class="line">IPosition(3,4,nchan,(nrant+1)/2));</div>
<div class="line">TiledColumnStMan tiledFlag(<span class="stringliteral">&quot;TiledFlag&quot;</span>,</div>
<div class="line">IPosition(3,4,nchan,8*(nrant+1)/2));</div>
<div class="line">TiledColumnStMan tiledUVW(<span class="stringliteral">&quot;TiledUVW&quot;</span>, IPosition(2,3,));</div>
<div class="line">IPosition(2,3,nrant*(nrant+1)/2));</div>
<div class="line">newTab.bindAll (incrStMan);</div>
<div class="line">newTab.bindColumn(<a class="code" href="classcasacore_1_1MSTable.html#a66be6569045313b99638c21e81477acb">MS::columnName</a>(<a class="code" href="classcasacore_1_1MSMainEnums.html#a612b887846f70716850e235c411e48a9a963680b3bf15604795aeb47e2c2f8c78">MS::ANTENNA1</a>),stanStMan);</div>
<div class="line">newTab.bindColumn(<a class="code" href="classcasacore_1_1MSTable.html#a66be6569045313b99638c21e81477acb">MS::columnName</a>(<a class="code" href="classcasacore_1_1MSMainEnums.html#a612b887846f70716850e235c411e48a9a2e226e66cb10d2a220f1fcc4a690ac75">MS::ANTENNA2</a>),stanStMan);</div>
<div class="line">newTab.bindColumn(<a class="code" href="classcasacore_1_1MSTable.html#a66be6569045313b99638c21e81477acb">MS::columnName</a>(<a class="code" href="classcasacore_1_1MSMainEnums.html#a612b887846f70716850e235c411e48a9aadb9b459841fdbdb238484d63cadf0f0">MS::DATA</a>),tiledData);</div>
<div class="line">newTab.bindColumn(<a class="code" href="classcasacore_1_1MSTable.html#a66be6569045313b99638c21e81477acb">MS::columnName</a>(<a class="code" href="classcasacore_1_1MSMainEnums.html#a612b887846f70716850e235c411e48a9a2c80ac3e56fe76d87b08f2fe37c8715f">MS::FLAG</a>),tiledFlag);</div>
<div class="line">newTab.bindColumn(<a class="code" href="classcasacore_1_1MSTable.html#a66be6569045313b99638c21e81477acb">MS::columnName</a>(<a class="code" href="classcasacore_1_1MSMainEnums.html#a612b887846f70716850e235c411e48a9af14726485aa69d09e0c1d796687b9e3d">MS::UVW</a>),tiledUVW);</div>
<div class="line"><span class="comment">// Create the MS and its subtables.</span></div>
<div class="line"><span class="comment">// Get access to its columns.</span></div>
<div class="line"><a class="code" href="namespacecasacore.html#aa5e78960516bef4822a438d3e84c9079">MS</a>* msp = <span class="keyword">new</span> MeasurementSet(newTab);</div>
<div class="line"><span class="comment">// Create all subtables.</span></div>
<div class="line"><span class="comment">// Do this after the creation of optional subtables,</span></div>
<div class="line"><span class="comment">// so the MS will know about those optional sutables.</span></div>
<div class="line">msp-&gt;createDefaultSubtables (<a class="code" href="classcasacore_1_1Table.html#a6c62d60a9691364e3aaaf137ea73cde0a72527bb2e368badd05319f61ab3dee6f">Table::New</a>);</div>
<div class="line"><span class="keywordflow">return</span> msp;</div>
<div class="line">}</div>
</div><!-- fragment --><h4>Some more performance considerations</h4>
<p>Which storage managers to use and how to use them depends heavily on the type of data and the access patterns to the data. Here follow some guidelines: </p>
<ol>
<li>
Scalar data can be stored with the <a class="el" href="classcasacore_1_1StandardStMan.html" title="The Standard Storage Manager. ">StandardStMan</a> (SSM) or <a class="el" href="classcasacore_1_1IncrementalStMan.html" title="The Incremental Storage Manager. ">IncrementalStMan</a> (ISM). For slowly varying data (e.g. the TIME column in a <a class="el" href="classcasacore_1_1MeasurementSet.html" title="A Table intended to hold astronomical data (a set of Measurements). ">MeasurementSet</a>) it is best to use the ISM. Otherwise the SSM. Note that very long strings (longer than the bucketsize) can only be stored with the SSM. </li>
<li>
Any number of storage managers can be used. In fact, each column can have a storage manager of its own resulting in column-wise stored data which is more and more used in data base systems. In that way a query or sort on that column is very fast, because the buckets to read only contain data of that column. In practice one can decide to combine a few frequently used columns in a storage manager. </li>
<li>
<a class="el" href="classcasacore_1_1Array.html" title="A templated N-D Array class with zero origin. Array&lt;T, Alloc&gt; is a templated, N-dimensional, Array class. The origin is zero, but by default indices are zero-based. This Array class is the base class for the Vector, Matrix, and Cube subclasses. ">Array</a> data can be stored with any column manager. Small fixed size arrays can be stored directly with the SSM (or ISM if not changing much). However, they can also be stored with a <a class="el" href="classcasacore_1_1TiledStMan.html" title="Base class for Tiled Storage Manager classes. ">TiledStMan</a> (TSM) as shown for the UVW column in the example above. <br/>
 Large arrays should usually be stored with a TSM. However, if it must be possible to change the shape of an array after it was stored, the SSM (or ISM) must be used. Note that in that case a lot of disk space can be wasted, because the SSM and ISM store the array data at the end of the file if the array got bigger and do not reuse the old space. The only way to reclaim it is by making a deep copy of the entire table. </li>
<li>
If an array is stored with a TSM, it is important to decide which TSM to use. <ol>
<li>
The <a class="el" href="classcasacore_1_1TiledColumnStMan.html" title="Tiled Column Storage Manager. ">TiledColumnStMan</a> is the most efficient, but only suitable for arrays having the same shape in the entire column. </li>
<li>
The <a class="el" href="classcasacore_1_1TiledShapeStMan.html" title="Tiled Data Storage Manager using the shape as id. ">TiledShapeStMan</a> is suitable for columns where the arrays can have a few shapes. </li>
<li>
The <a class="el" href="classcasacore_1_1TiledCellStMan.html" title="Tiled Cell Storage Manager. ">TiledCellStMan</a> is suitable for columns where the arrays can have many different shapes. </li>
</ol>
This is discussed in more detail <a href="#Tables:TiledStMan">above</a>. </li>
<li>
If storing an array with a TSM, it can be very important to choose the right tile shape. Not only does this define the size of a tile, but it also defines if access in other directions than the natural direction can be fast. It is also discussed in more detail <a href="#Tables:TiledStMan">above</a>. </li>
<li>
Columns can be combined in a single <a class="el" href="classcasacore_1_1TiledStMan.html" title="Base class for Tiled Storage Manager classes. ">TiledStMan</a>. For instance, combining DATA and FLAG is advantageous if FLAG is always used with DATA. However, if FLAG is used on its own (e.g. in combination with CORRECTED_DATA), it is better to separate them, otherwise tiles containing FLAG also contain DATA making the tiles much bigger, thus more expensive to access. </li>
</ol>
<p><a class="anchor" id="Tables_iotracing"></a><a class="anchor" id="Tables:iotracing"></a> </p>
<h4>IO Tracing</h4>
<p>Several forms of tracing can be done to see how the <a class="el" href="classcasacore_1_1Table.html" title="Main interface class to a read/write table. ">Table</a> I/O performs. </p>
<ul>
<li>
On Linux/UNIX systems the <code>strace</code> command can be used to collect trace information about the physical IO. </li>
<li>
The function <code>showCacheStatistics</code> in class TiledStManAccessor can be used to show the number of actual reads and writes and the percentage of cache hits. </li>
<li>
The software has some options to trace the operations done on tables. It is possible to specify the columns and/or the operations to be traced. The following <code>aipsrc</code> variables can be used. <ul>
<li>
<code>table.trace.filename</code> specifies the file to write the trace output to. If not given or empty, no tracing will be done. The file name can contain environment variables or a tilde. </li>
<li>
<code>table.trace.operation</code> specifies the operations to be traced. It is a string containing s, r, and/or w where s means tracing <a class="el" href="classcasacore_1_1RefTable.html" title="Class for a table as a view of another table. ">RefTable</a> construction (selection/sort), r means column reads, and w means column writes. If empty, only the high level table operations (open, create, close) will be traced. </li>
<li>
<code>table.trace.columntype</code> specifies the types of columns to be traced. It is a string containing the characters s, a, and/or r. s means all scalar columns, a all array columns, and r all record columns. If empty and if <code>table.trace.column</code> is empty, its default value is a. </li>
<li>
<code>table.trace.column</code> specifies names of columns to be traced. Its value can be one or more glob-like patterns separated by commas without any whitespace. The default is empty. For example: <div class="fragment"><div class="line">table.trace.column: *DATA,FLAG,WEIGHT*</div>
</div><!-- fragment --> to trace all DATA, the FLAG, and all WEIGHT columns. </li>
</ul>
The trace output is a text file with the following columns separated by a space. <ul>
<li>
The UTC time the trace line was written (with msec accuracy). </li>
<li>
The operation: n(ew), o(pen), c(lose), t(able), r(ead), w(rite), s(election/sort/iter), p(rojection). t means an arbitrary table operation as given in the name column. </li>
<li>
The table-id (as t=i) given at table creation (new) or open. </li>
<li>
The table name, column name, or table operation (as <code>*oper*</code>). <code>*reftable*</code> means that the operation is on a <a class="el" href="classcasacore_1_1RefTable.html" title="Class for a table as a view of another table. ">RefTable</a> (thus result of selection, sort, projection, or iteration). </li>
<li>
The row or rows to access (* means all rows). Multiple rows are given as a series of ranges like s:e:i,s:e:i,... where e and i are only given if applicable (default i is 1). Note that e is inclusive and defaults to s. </li>
<li>
The optional array shape to access (none means scalar). In case multiple rows are accessed, the last shape value is the number of rows. </li>
<li>
The optional slice of the array in each row as [start][end][stride]. </li>
</ul>
Shape, start, end, and stride are given in Fortran-order as [n1,n2,...]. </li>
</ul>
<p><a class="anchor" id="Tables_applications"></a><a class="anchor" id="Tables:applications"></a> </p>
<h4>Applications to inspect/manipulate a table</h4>
<ul>
<li>
<em>showtableinfo</em> shows the structure of a table. It can show: <ul>
<li>
the columns and their format (optionally sorted on name) </li>
<li>
the data managers used to store the column data </li>
<li>
the table and/or column keywords and their values </li>
<li>
recursively the same info of the subtables </li>
</ul>
</li>
<li>
<em>showtablelock</em> if a table is locked or opened and by which process. </li>
<li>
<em>lsmf</em> shows the virtual files contained in a <a class="el" href="classcasacore_1_1MultiFile.html" title="Class to combine multiple files in a single one. ">MultiFile</a>. </li>
<li>
<em>tomf</em> copies the given files to a <a class="el" href="classcasacore_1_1MultiFile.html" title="Class to combine multiple files in a single one. ">MultiFile</a>. </li>
<li>
<em>taql</em> can be used to query a table using the <a href="../notes/199.html">Table Query Language</a> (TaQL). </li>
</ul>
<p><a class="anchor" id="Tables_module_Class_List"></a> </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
